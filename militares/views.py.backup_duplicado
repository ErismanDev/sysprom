from militares.permissoes_simples import (
    requer_edicao_militares, requer_edicao_fichas_conceito,
    requer_gerenciamento_quadros_vagas, requer_gerenciamento_comissoes,
    requer_gerenciamento_usuarios, requer_assinatura_documentos,
    requer_funcao_especial, apenas_visualizacao_comissao
)
# Imports para sistema de permissões
from .permissoes_sistema import (
    requer_perm_militares_visualizar, requer_perm_militares_criar, requer_perm_militares_editar, requer_perm_militares_excluir, requer_perm_militares_admin,
    requer_perm_fichas_visualizar, requer_perm_fichas_criar, requer_perm_fichas_editar, requer_perm_fichas_aprovar, requer_perm_fichas_admin,
    requer_perm_quadros_visualizar, requer_perm_quadros_criar, requer_perm_quadros_editar, requer_perm_quadros_excluir, requer_perm_quadros_admin,
    requer_perm_promocoes_visualizar, requer_perm_promocoes_criar, requer_perm_promocoes_editar, requer_perm_promocoes_aprovar, requer_perm_promocoes_homologar, requer_perm_promocoes_admin,
    requer_perm_vagas_visualizar, requer_perm_vagas_criar, requer_perm_vagas_editar, requer_perm_vagas_excluir, requer_perm_vagas_admin,
    requer_perm_comissao_visualizar, requer_perm_comissao_criar, requer_perm_comissao_editar, requer_perm_comissao_excluir, requer_perm_comissao_assinar, requer_perm_comissao_admin,
    requer_perm_documentos_visualizar, requer_perm_documentos_criar, requer_perm_documentos_editar, requer_perm_documentos_excluir, requer_perm_documentos_gerar_pdf, requer_perm_documentos_imprimir, requer_perm_documentos_assinar, requer_perm_documentos_admin,
    requer_perm_usuarios_visualizar, requer_perm_usuarios_criar, requer_perm_usuarios_editar, requer_perm_usuarios_excluir, requer_perm_usuarios_admin,
    requer_perm_relatorios_visualizar, requer_perm_relatorios_gerar_pdf, requer_perm_relatorios_imprimir, requer_perm_relatorios_admin,
    requer_perm_configuracoes_visualizar, requer_perm_configuracoes_editar, requer_perm_configuracoes_admin,
)



from django.shortcuts import render, get_object_or_404, redirect
from django.core.files.base import ContentFile
from django.contrib import messages
from django.urls import reverse
from django.contrib.auth.decorators import login_required, user_passes_test, permission_required
from django.views.decorators.csrf import csrf_protect
from django.contrib.auth import update_session_auth_hash
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password
from django.core.paginator import Paginator
from django.db.models import Q, Sum, Count, Case, When, IntegerField, Case, When, IntegerField, Case, When, IntegerField, Case, When, IntegerField
from django.db.models.deletion import ProtectedError
from django.http import JsonResponse, HttpResponse
from django.utils import timezone
from datetime import date, datetime
from django.contrib.auth.models import User, Group, Permission
from django.db import models, IntegrityError
from django.conf import settings
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.http import JsonResponse
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import Promocao
from .models import Vaga
from django import forms
from django.http import FileResponse
from django.http import FileResponse
from .models import JustificativaEncerramento
from .models import AtaSessao
from .forms import AtaSessaoForm
from .models import AtaSessao
from .models import AtaSessao, AssinaturaAta
from .models import AtaSessao
from django.http import HttpResponse
from django.utils import timezone
from .models import AtaSessao
from django.utils import timezone
from .models import ModeloAta
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .models import ModeloAta
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .forms import ModeloAtaForm
from django import forms
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.db import models
from django.core.paginator import Paginator
from django.contrib.auth.models import User, Group, Permission
from django.contrib.contenttypes.models import ContentType
from django import forms
# from dal import autocomplete

# Importar views específicas para praças
from .views_pracas_import import *
from .utils import calcular_proxima_data_promocao
from .models import (
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Promocao, Vaga, Curso, MedalhaCondecoracao, Documento, Intersticio,
    POSTO_GRADUACAO_CHOICES, SITUACAO_CHOICES, QUADRO_CHOICES,
    PrevisaoVaga, AssinaturaQuadroAcesso, AssinaturaQuadroFixacaoVagas, ComissaoPromocao, MembroComissao, SessaoComissao, PresencaSessao, DeliberacaoComissao, VotoDeliberacao, DocumentoSessao, AtaSessao, ModeloAta, CargoComissao,
    VagaManual, QuadroFixacaoVagas, ItemQuadroFixacaoVagas, UsuarioFuncao,
    CargoFuncao, PermissaoFuncao, PerfilAcesso, CalendarioPromocao, ItemCalendarioPromocao,
    AssinaturaCalendarioPromocao, AlmanaqueMilitar, AssinaturaAlmanaque
)
from .forms import MilitarForm, DocumentoForm, UserRegistrationForm, ConfirmarSenhaForm, ComissaoPromocaoForm, MembroComissaoForm, SessaoComissaoForm, DeliberacaoComissaoForm, DocumentoSessaoForm, AtaSessaoForm, ModeloAtaForm, CargoComissaoForm, FichaConceitoPracasForm, FichaConceitoOficiaisForm, UsuarioFuncaoForm, UsuarioForm, CargoFuncaoForm
from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito, can_edit_militar
from .admin_decorators import admin_bypass, admin_or_permission_required
from .permissoes_simples import requer_gerenciamento_comissoes
from .permissoes import requer_funcao_ativa
from django import forms
from django.contrib.auth import authenticate
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from io import BytesIO
import qrcode
from reportlab.lib.utils import ImageReader
import os
from reportlab.lib.enums import TA_JUSTIFY
import re
from html import unescape
import logging
import unicodedata

@login_required
def teste_modal(request):
    """View temporária para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporária para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporária para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporária para testar modal simples"""
    return render(request, 'teste_modal_simples.html')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginação e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # Ordenação padrão por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,  # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que têm CHO, depois os que não têm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terá sua própria numeração de antiguidade
        # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vão para o final
            x.nome_completo
        ))
        
        # Reordenar numeração de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeração para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeração para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # Paginação
    itens_por_pagina = request.GET.get('itens_por_pagina', 20)
    try:
        itens_por_pagina = int(itens_por_pagina)
        if itens_por_pagina not in [20, 50, 100]:
            itens_por_pagina = 20
    except (ValueError, TypeError):
        itens_por_pagina = 20
    
    # Converter para lista se necessário
    if hasattr(militares, 'count'):
        # É um QuerySet
        militares_list = list(militares)
    else:
        # Já é uma lista
        militares_list = militares
    
    paginator = Paginator(militares_list, itens_por_pagina)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': len(militares_list),
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
def militar_detail_pessoal(request):
    """Exibe os detalhes do próprio militar do usuário logado"""
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Verificar se o usuário tem militar associado
    try:
        militar = request.user.militar
    except Militar.DoesNotExist:
        messages.error(request, 'Você não possui militar associado.')
        return redirect('militares:militar_dashboard')
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
        'is_own_ficha': True,  # Flag para indicar que é a própria ficha
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para cadastrar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para editar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeração anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeração de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenação automática: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para excluir militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    logger.info(f'🔍 Busca AJAX recebida: {query}')
    logger.info(f'📡 Método da requisição: {request.method}')
    logger.info(f'📡 Headers: {dict(request.headers)}')
    
    if len(query) < 2:
        logger.info('⚠️ Query muito curta, retornando vazio')
        return JsonResponse({'results': []})
    
    try:
        # Filtrar militares excluindo coronéis (último posto)
        militares = Militar.objects.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query)
        ).exclude(
            posto_graduacao='CB'  # Excluir coronéis
        )[:10]
        
        logger.info(f'✅ Encontrados {militares.count()} militares')
        
        results = []
        for militar in militares:
            result = {
                'id': militar.id,
                'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
                'nome': militar.nome_completo,
                'matricula': militar.matricula,
                'posto': militar.get_posto_graduacao_display(),
            }
            results.append(result)
            logger.info(f'👤 Militar encontrado: {result["nome"]} ({result["posto"]})')
        
        logger.info(f'📦 Retornando {len(results)} resultados')
        return JsonResponse({'results': results})
        
    except Exception as e:
        logger.error(f'❌ Erro na busca AJAX: {str(e)}')
        logger.error(f'❌ Stack trace: {e.__traceback__}')
        return JsonResponse({'results': [], 'error': str(e)}, status=500)

def buscar_usuarios_ajax(request):
    """Busca usuários via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    comissao_tipo = request.GET.get('comissao_tipo', '')  # CPO ou CPP
    logger.info(f'🔍 Busca de usuários AJAX recebida: {query} (comissão: {comissao_tipo})')
    
    if len(query) < 2:
        logger.info('⚠️ Query muito curta, retornando vazio')
        return JsonResponse({'usuarios': []})
    
    try:
        # Buscar usuários que têm militares vinculados e estão ativos
        usuarios = User.objects.filter(
            militar__isnull=False,  # Apenas usuários com militar vinculado
            militar__situacao='AT',  # Apenas militares ativos
            is_active=True  # Apenas usuários ativos
        ).filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query)
        )
        
        # Filtrar por tipo de comissão se especificado
        if comissao_tipo == 'CPO':
            # Para CPO: apenas usuários com funções CPO
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPO',  # Com função CPO
                funcoes__status='ATIVO'  # Função ativa
            ).distinct()
            
        elif comissao_tipo == 'CPP':
            # Para CPP: apenas usuários com funções CPP
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPP',  # Com função CPP
                funcoes__status='ATIVO'  # Função ativa
            ).distinct()
        
        usuarios = usuarios.order_by('militar__nome_completo')[:10]
        
        logger.info(f'📊 Encontrados {usuarios.count()} usuários')
        
        results = []
        for usuario in usuarios:
            militar = usuario.militar
            
            # Buscar a função específica do usuário
            funcao_cpo_cpp = usuario.funcoes.filter(
                status='ATIVO',
                cargo_funcao__nome__icontains=comissao_tipo if comissao_tipo else ''
            ).first()
            
            results.append({
                'id': usuario.id,
                'username': usuario.username,
                'first_name': usuario.first_name,
                'last_name': usuario.last_name,
                'militar': {
                    'id': militar.id,
                    'nome': militar.nome_completo,
                    'posto': militar.get_posto_graduacao_display(),
                    'matricula': militar.matricula,
                },
                'funcao': funcao_cpo_cpp.cargo_funcao.nome if funcao_cpo_cpp else None
            })
        
        logger.info(f'✅ Retornando {len(results)} resultados')
        return JsonResponse({'usuarios': results})
        
    except Exception as e:
        logger.error(f'❌ Erro na busca de usuários: {e}')
        return JsonResponse({'usuarios': [], 'error': str(e)})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    
    # Verificar se usuário é do tipo "Usuário" e redirecionar para sua ficha
    is_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO',
        cargo_funcao__nome='Usuário'
    ).exists()
    
    if is_usuario:
        return redirect('militares:redirect_usuario_ficha')
    
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    militares_inativos = total_militares - militares_ativos
    # Contar militares que possuem ficha de conceito (não o total de fichas)
    militares_com_ficha = Militar.objects.filter(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    ).distinct().count()
    
    # Contar militares ativos sem ficha de conceito
    militares_sem_ficha = militares_ativos - militares_com_ficha
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    total_quadros = QuadroAcesso.objects.count()
    
    # Estatísticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Estatísticas por posto/graduação
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    ).order_by('posto_graduacao')
    
    # Estatísticas de documentos por status
    documentos_por_status = Documento.objects.values('status').annotate(
        total=Count('id')
    ).order_by('status')
    
    # Militares aptos a quadro de acesso por posto/graduação
    from datetime import date
    hoje = date.today()
    
    # Buscar militares aptos (com ficha de conceito e interstício mínimo)
    militares_aptos_por_posto = {}
    
    # Definir interstícios mínimos por posto (em anos)
    intersticios_minimos = {
        '2T': 2,  # 2º Tenente -> 1º Tenente
        '1T': 3,  # 1º Tenente -> Capitão
        'CP': 4,  # Capitão -> Major
        'MJ': 4,  # Major -> Tenente-Coronel
        'TC': 4,  # Tenente-Coronel -> Coronel
        'ST': 3,  # Subtenente -> 1º Sargento
        '1S': 3,  # 1º Sargento -> 2º Sargento
        '2S': 3,  # 2º Sargento -> 3º Sargento
        '3S': 3,  # 3º Sargento -> Cabo
        'CAB': 2, # Cabo -> Soldado
    }
    
    # Buscar militares ativos com ficha de conceito (para cálculo de aptos)
    militares_aptos_candidatos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=intersticios_minimos.keys()
    ).filter(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    ).distinct()
    
    # Verificar aptidão por interstício
    for militar in militares_aptos_candidatos:
        posto = militar.posto_graduacao
        if posto in intersticios_minimos:
            # Calcular anos no posto atual
            anos_no_posto = (hoje - militar.data_promocao_atual).days / 365.25
            
            if anos_no_posto >= intersticios_minimos[posto]:
                if posto not in militares_aptos_por_posto:
                    militares_aptos_por_posto[posto] = 0
                militares_aptos_por_posto[posto] += 1
    
    # Ordenar por hierarquia
    hierarquia = ['2T', '1T', 'CP', 'MJ', 'TC', 'ST', '1S', '2S', '3S', 'CAB']
    militares_aptos_ordenados = []
    total_aptos = 0
    for posto in hierarquia:
        if posto in militares_aptos_por_posto:
            militares_aptos_ordenados.append({
                'posto': posto,
                'total': militares_aptos_por_posto[posto]
            })
            total_aptos += militares_aptos_por_posto[posto]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # Notificações do usuário
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificações (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibição
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'militares_inativos': militares_inativos,
        'militares_com_ficha': militares_com_ficha,
        'militares_sem_ficha': militares_sem_ficha,
        'documentos_pendentes': documentos_pendentes,
        'total_quadros': total_quadros,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto,
        'documentos_por_status': documentos_por_status,
        'militares_aptos_por_posto': militares_aptos_ordenados,
        'total_aptos_quadro': total_aptos,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # Capitão
            '1T': 5,   # 1º Tenente
            '2T': 6,   # 2º Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de Adaptação
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # Estatísticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulário usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # Formulário padrão para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # Formulário padrão para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required

@login_required
def teste_modal(request):
    """View temporária para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporária para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporária para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporária para testar modal simples"""
    return render(request, 'teste_modal_simples.html')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginação e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # Ordenação padrão por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,  # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que têm CHO, depois os que não têm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terá sua própria numeração de antiguidade
        # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vão para o final
            x.nome_completo
        ))
        
        # Reordenar numeração de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeração para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeração para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÇÃO OBRIGATÓRIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # Padrão mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginação


        total_militares = militares.count()


        


        # Aplicar paginação


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para cadastrar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para editar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeração anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeração de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenação automática: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para excluir militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronéis (último posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronéis
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # Estatísticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Últimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # Notificações do usuário
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificações (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibição
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # Capitão
            '1T': 5,   # 1º Tenente
            '2T': 6,   # 2º Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de Adaptação
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # Estatísticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulário usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # Formulário padrão para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # Formulário padrão para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluída com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    # Superusuários e staff têm acesso total
    if request.user.is_superuser or request.user.is_staff:
        quadros = QuadroAcesso.objects.all()
    else:
        # Permissão especial para funções administrativas
        cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções', 'Administrador do Sistema', 'Administrador']
        funcoes_ativas = request.user.funcoes.filter(
            cargo_funcao__nome__in=cargos_especiais,
            status='ATIVO',
        )
        if funcoes_ativas.exists():
            quadros = QuadroAcesso.objects.all()
        else:
            # Verificar se o usuário é membro de alguma comissão e aplicar filtro
            membros_comissao = MembroComissao.objects.filter(
                usuario=request.user,
                ativo=True,
                comissao__status='ATIVA'
            )
            if membros_comissao.exists():
                tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
                tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
                if tem_cpo and tem_cpp:
                    quadros = QuadroAcesso.objects.all()
                elif tem_cpo:
                    quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
                elif tem_cpp:
                    quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
                else:
                    quadros = QuadroAcesso.objects.none()
            else:
                quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # Ordenação
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se é uma requisição AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatísticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginação e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # Ordenação padrão por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,  # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que têm CHO, depois os que não têm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terá sua própria numeração de antiguidade
        # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vão para o final
            x.nome_completo
        ))
        
        # Reordenar numeração de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeração para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeração para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÇÃO OBRIGATÓRIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # Padrão mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginação


        total_militares = militares.count()


        


        # Aplicar paginação


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para cadastrar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para editar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeração anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeração de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenação automática: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para excluir militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronéis (último posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronéis
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # Estatísticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Últimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # Notificações do usuário
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificações (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibição
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulário usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # Formulário padrão para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # Formulário padrão para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluída com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # Permissão especial para Diretor de Gestão de Pessoas ou Chefe da Seção de Promoções
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # Ordenação
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se é uma requisição AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatísticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transições (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se é um quadro de praças
    if quadro.tipo == 'PRACAS':
        # Para quadros de praças: transições específicas para praças
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # Praças
                {
                    'numero': 'I',
                    'titulo': '1º SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2º SARGENTO para o posto de 1º SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3º SARGENTO para o posto de 2º SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3º SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transições específicas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TC→CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transições por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2º TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }

            ],
            'SAUDE': [  # Saúde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2º TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # Lógica especial para o quadro ID 312 - forçar exibição da transição Major → Tenente-Coronel
    if quadro.id == 312:
        # Criar transição especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transição especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transição
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transição ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibição da transição MJ→TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso único por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        categoria = request.POST.get('categoria', 'OFICIAIS')
        
        # Log para debug
        print(f"DEBUG - Tipo: {tipo}")
        print(f"DEBUG - Categoria: {categoria}")
        print(f"DEBUG - Data: {data_promocao}")
        print(f"DEBUG - Todos os POST data: {request.POST}")
        
        if not tipo:
            messages.error(request, 'O tipo de acesso é obrigatório.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se não foi fornecida uma data, usar a data automática
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Verificar se já existe um quadro para este tipo, data e categoria
        quadros_existentes = QuadroAcesso.objects.filter(
            tipo=tipo,
            data_promocao=data_promocao,
            categoria=categoria
        ).order_by('data_criacao')
        
        # Determinar se é um aditamento
        is_aditamento = quadros_existentes.exists()
        
        # Criar um único quadro que representará todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            print(f"DEBUG - Criando quadro com categoria: {categoria}")
            print(f"DEBUG - É aditamento: {is_aditamento}")
            
            # Determinar o número do aditamento se for um aditamento
            numero_aditamento = None
            if is_aditamento:
                # Contar quantos aditamentos já existem
                numero_aditamento = quadros_existentes.count() + 1
                print(f"DEBUG - Número do aditamento: {numero_aditamento}")
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Se for aditamento, forçar a geração do número com aditamento
            if is_aditamento and numero_aditamento:
                # Gerar o número base
                ano = data_promocao.year
                mes = data_promocao.month
                dia = data_promocao.day
                tipo_prefixo = 'OF' if categoria == 'OFICIAIS' else 'PR'
                
                # Prefixo do quadro
                if tipo == 'ANTIGUIDADE':
                    quadro_prefixo = 'QAA'
                elif tipo == 'MERECIMENTO':
                    quadro_prefixo = 'QAM'
                else:
                    quadro_prefixo = 'QAA'
                
                base_numero = f"{quadro_prefixo}-{tipo_prefixo}-{ano:04d}/{mes:02d}/{dia:02d}"
                
                # Se for o primeiro quadro (não aditamento), usar -01
                if numero_aditamento == 1:
                    novo_quadro.numero = f"{base_numero} - 01"
                else:
                    # Se for aditamento, usar -a01, -a02, etc.
                    novo_quadro.numero = f"{base_numero} - a{numero_aditamento:02d}"
                
                novo_quadro.save()
                print(f"DEBUG - Número gerado para aditamento: {novo_quadro.numero}")
            
            # --- SEGURANÇA EXTRA: Remover assinaturas órfãs e antigas ---
            from militares.models import AssinaturaQuadroAcesso, QuadroAcesso
            # Remove assinaturas órfãs (sem quadro)
            AssinaturaQuadroAcesso.objects.filter(quadro_acesso__isnull=True).delete()
            # Remove assinaturas associadas a quadros antigos com a mesma data, tipo e categoria
            quadros_antigos = QuadroAcesso.objects.filter(
                data_promocao=data_promocao,
                tipo=tipo,
                categoria=categoria
            ).exclude(pk=novo_quadro.pk)
            AssinaturaQuadroAcesso.objects.filter(quadro_acesso__in=quadros_antigos).delete()
            # --- FIM DA SEGURANÇA EXTRA ---
            
            print(f"DEBUG - Quadro criado com ID: {novo_quadro.pk}, categoria: {novo_quadro.categoria}")
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automática: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                
                # Redirecionar para a view correta baseada na categoria
                print(f"DEBUG - Redirecionando para categoria: {novo_quadro.categoria}")
                if novo_quadro.categoria == 'PRACAS':
                    print(f"DEBUG - Redirecionando para praças: quadro_acesso_pracas_detail")
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    print(f"DEBUG - Redirecionando para oficiais: quadro_acesso_detail")
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'Praças')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro está homologado (apenas para usuários não administradores)
        if quadro.status == 'HOMOLOGADO' and not request.user.is_superuser:
            messages.error(request, 'Não é possível excluir um quadro homologado. Apenas administradores podem excluir quadros homologados.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        if quadro.status == 'HOMOLOGADO':
            messages.success(request, 'Quadro de acesso homologado excluído com sucesso pelo administrador!')
        else:
            messages.success(request, 'Quadro de acesso excluído com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro não encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar não selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar já está no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} já está no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro é de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro não é de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados não podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar está no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} não está no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar não encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegíveis para promoção"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegíveis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmação de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissão de homologação - apenas presidente da comissão pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se é presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praças, verificar se é presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha é obrigatória.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuário que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuário que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso não elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lógica de geração automática
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # Edição básica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissão de homologação - apenas presidente da comissão pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se é presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praças, verificar se é presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

@login_required
def quadro_acesso_pdf(request, pk):
    """Gera PDF do quadro de acesso no modelo institucional solicitado"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para português brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrão se não conseguir configurar

    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        "COMISSÃO DE PROMOÇÕES DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Título centralizado e sublinhado
    tipo_quadro = quadro.get_tipo_display().upper()
    # O get_tipo_display() já retorna "QUADRO DE ACESSO POR ANTIGUIDADE" ou "QUADRO DE ACESSO POR MERECIMENTO"
    # Então usamos diretamente o valor retornado
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutório com data em português
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Definir tipo e sigla do quadro
    if quadro.tipo == 'ANTIGUIDADE':
        tipo_quadro = 'por Antiguidade'
        sigla_quadro = 'QAA'
    elif quadro.tipo == 'MERECIMENTO':
        tipo_quadro = 'por Merecimento'
        sigla_quadro = 'QAM'
    else:
        tipo_quadro = 'Manual'
        sigla_quadro = 'QAM'
    
    # Definir texto introdutório baseado no tipo de quadro
    if quadro.tipo == 'MERECIMENTO':
        texto_intro = (
            f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
            f"que visa às promoções do dia {data_formatada}, tudo com fulcro no parágrafo único do art. 6º c/c o § 2° do art. 20 da Lei n° 5.462, de 30 de junho de 2005 "
            "c/c o art. 10 da Lei 7.772 de 04 de abril de 2022."
        )
    else:
        texto_intro = (
            f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
            f"que visa às promoções do dia {data_formatada}, com fulcro nos artigos 12, 13, c/c § 3º do Art. 20, da Lei nº 5.461, de 30 de junho de 2005, "
            "alterada pela Lei Nº 7.772, de 04 de abril de 2022."
        )
    story.append(Paragraph(texto_intro, style_just))
    story.append(Spacer(1, 13))

    # Definir todos os quadros
    quadros_info = [
        {
            'numero': 1,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMBATENTES (QOBM/Comb.)',
            'codigo': 'COMB'
        },
        {
            'numero': 2,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES DE SAÚDE (QOBM/S)',
            'codigo': 'SAUDE'
        },
        {
            'numero': 3,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES ENGENHEIROS (QOBM/E)',
            'codigo': 'ENG'
        },
        {
            'numero': 4,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMPLEMENTARES (QOBM/C)',
            'codigo': 'COMP'
        }
    ]

    # Definir transições específicas por quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transições específicas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TC→CB, MJ→TC, CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transições por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2º TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2º TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Processar cada quadro
    for i, quadro_info in enumerate(quadros_info):
        # Adicionar espaçamento entre quadros (exceto no primeiro)
        if i > 0:
            story.append(Spacer(1, 16))
        
        story.append(Paragraph(f'<b>{quadro_info["numero"]}. {quadro_info["nome"]}</b>', style_center))
        story.append(Spacer(1, 13))

        # Processar cada transição de posto específica do quadro
        transicoes_do_quadro = transicoes_por_quadro.get(quadro_info['codigo'], [])
        
        # Ordenar transições para garantir ordem correta
        if quadro_info['codigo'] == 'COMB':
            # Para Combatente: TC→CB, MJ→TC, CP→MJ (ordem hierárquica)
            transicoes_ordenadas = []
            # Primeiro, adicionar TC→CB (mais alto)
            for transicao in transicoes_do_quadro:
                if transicao['origem'] == 'TC' and transicao['destino'] == 'CB':
                    transicoes_ordenadas.insert(0, transicao)
                else:
                    transicoes_ordenadas.append(transicao)
            # Reordenar para garantir MJ→TC antes de CP→MJ
            final_ordenadas = []
            for transicao in transicoes_ordenadas:
                if transicao['origem'] == 'MJ' and transicao['destino'] == 'TC':
                    final_ordenadas.insert(1, transicao)  # Após TC→CB
                else:
                    final_ordenadas.append(transicao)
            transicoes_do_quadro = final_ordenadas
        else:
            # Para outros quadros: MJ→TC, CP→MJ (ordem hierárquica)
            transicoes_ordenadas = []
            for transicao in transicoes_do_quadro:
                if transicao['origem'] == 'MJ' and transicao['destino'] == 'TC':
                    transicoes_ordenadas.insert(0, transicao)
                else:
                    transicoes_ordenadas.append(transicao)
            transicoes_do_quadro = transicoes_ordenadas
        for transicao in transicoes_do_quadro:
            story.append(Spacer(1, 13))
            story.append(Paragraph(f'<b>{transicao["numero"]} – {transicao["titulo"]}</b>', style_bold))
            story.append(Spacer(1, 13))
            
            # Buscar militares aptos para esta transição neste quadro específico
            todos_militares = quadro.itemquadroacesso_set.all()
            
            # Filtrar por quadro específico
            if quadro_info['codigo'] == 'COMB':
                # Quadro Combatente - incluir apenas militares do quadro COMB
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='COMB'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'SAUDE':
                # Quadro Saúde - incluir apenas militares do quadro SAUDE
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='SAUDE'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'ENG':
                # Quadro Engenheiro - incluir apenas militares do quadro ENG
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='ENG'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'COMP':
                # Quadro Complementar - incluir militares do quadro COMP
                # Para transição ST->2T, incluir subtenentes do quadro PRACAS
                if transicao['origem'] == 'ST' and transicao['destino'] == '2T':
                    aptos = todos_militares.filter(
                        militar__posto_graduacao=transicao['origem'],
                        militar__quadro='PRACAS'
                    ).order_by('posicao')
                else:
                    aptos = todos_militares.filter(
                        militar__posto_graduacao=transicao['origem'],
                        militar__quadro='COMP'
                    ).order_by('posicao')
            else:
                # Fallback - usar filtro genérico
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem']
                ).order_by('posicao')
            
            if aptos.exists():
                # Preparar dados da tabela
                from .utils import criptografar_cpf_lgpd
                if quadro.tipo == 'MERECIMENTO':
                    header_data = [['ORD', 'CPF', 'POSTO', 'NOME', 'PONTUAÇÃO']]
                    for idx, item in enumerate(aptos, 1):
                        header_data.append([
                            str(idx),
                            criptografar_cpf_lgpd(item.militar.cpf),
                            item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                            item.militar.nome_completo,
                            f"{item.pontuacao:.2f}" if item.pontuacao else "-"
                        ])
                    # Calcular larguras das colunas baseado no conteúdo
                    max_ord = max([len(str(row[0])) for row in header_data])
                    max_cpf = max([len(row[1]) for row in header_data])
                    max_posto = max([len(row[2]) for row in header_data])
                    max_pontuacao = max([len(row[4]) for row in header_data])
                    
                    # Definir larguras mínimas e ajustáveis
                    col_widths = [
                        max(1.2*cm, max_ord * 0.3*cm),  # ORD
                        max(3*cm, max_cpf * 0.3*cm),    # CPF
                        max(3*cm, max_posto * 0.3*cm),  # POSTO
                        6*cm,  # NOME (reduzido para dar espaço à pontuação)
                        max(2*cm, max_pontuacao * 0.3*cm)  # PONTUAÇÃO
                    ]
                else:
                    header_data = [['ORD', 'CPF', 'POSTO', 'NOME']]
                    for idx, item in enumerate(aptos, 1):
                        header_data.append([
                            str(idx),
                            criptografar_cpf_lgpd(item.militar.cpf),
                            item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                            item.militar.nome_completo
                        ])
                    # Calcular larguras das colunas baseado no conteúdo
                    max_ord = max([len(str(row[0])) for row in header_data])
                    max_cpf = max([len(row[1]) for row in header_data])
                    max_posto = max([len(row[2]) for row in header_data])
                    
                    # Definir larguras mínimas e ajustáveis
                    col_widths = [
                        max(1.2*cm, max_ord * 0.3*cm),  # ORD
                        max(3*cm, max_cpf * 0.3*cm),    # CPF
                        max(3*cm, max_posto * 0.3*cm),  # POSTO
                        8*cm  # NOME (fixo)
                    ]
                table = Table(header_data, colWidths=col_widths)
                # Aplicar estilo diferente baseado no tipo de quadro
                if quadro.tipo == 'MERECIMENTO':
                    table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                        ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                        ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                        ('ALIGN', (4, 1), (4, -1), 'CENTER'),  # Alinhar coluna de pontuação ao centro
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ]))
                else:
                    table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                        ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                        ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ]))
                story.append(table)
            else:
                # Mostrar mensagem padrão institucional quando não há militares
                if quadro.tipo == 'MERECIMENTO':
                    # Converter sigla do posto para nome completo
                    posto_nomes = {
                        'CB': 'CORONEL',
                        'TC': 'TENENTE-CORONEL', 
                        'MJ': 'MAJOR',
                        'CP': 'CAPITÃO',
                        '1T': '1º TENENTE',
                        '2T': '2º TENENTE',
                        'AS': 'ASPIRANTE A OFICIAL',
                        'AA': 'ALUNO DE ADAPTAÇÃO',
                        'ST': 'SUBTENENTE'
                    }
                    nome_posto = posto_nomes.get(transicao['destino'], transicao['destino'])
                    mensagem = (
                        f"Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de {nome_posto} em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022."
                    )
                else:
                    # Converter sigla do posto para nome completo
                    posto_nomes = {
                        'CB': 'CORONEL',
                        'TC': 'TENENTE-CORONEL', 
                        'MJ': 'MAJOR',
                        'CP': 'CAPITÃO',
                        '1T': '1º TENENTE',
                        '2T': '2º TENENTE',
                        'AS': 'ASPIRANTE A OFICIAL',
                        'AA': 'ALUNO DE ADAPTAÇÃO',
                        'ST': 'SUBTENENTE'
                    }
                    nome_posto = posto_nomes.get(transicao['destino'], transicao['destino'])
                    mensagem = (
                        f"Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de {nome_posto} em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022."
                    )
                
                story.append(Paragraph(mensagem, style_just))

    # Data e local por extenso, centralizado
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    # Buscar a primeira assinatura eletrônica para usar sua data
    primeira_assinatura = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('data_assinatura').first()
    if primeira_assinatura:
        data_assinatura = primeira_assinatura.data_assinatura
        data_extenso = f"Teresina - PI, {data_assinatura.day} de {meses_pt[data_assinatura.month]} de {data_assinatura.year}"
    else:
        # Se não houver assinatura, usar a data do quadro
        data_extenso = f"Teresina - PI, {quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # Seção de Assinaturas Físicas (sem título)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas válidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo não registrado"
        
        # Exibir no formato físico: Nome - Posto BM (negrito), Função (normal), Tipo (negrito menor)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Paragraph(f"<b>{tipo}</b>", style_center))
        story.append(Spacer(1, 13))

    # Seção de Assinaturas Eletrônicas (sem título)
    story.append(Spacer(1, 13))
    
    # Processar assinaturas eletrônicas
    for i, assinatura in enumerate(assinaturas):
        # Informações de assinatura eletrônica
        nome_assinante = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        # Se o nome estiver vazio, usar um nome padrão
        if not nome_assinante or nome_assinante.strip() == '':
            nome_assinante = "Usuário do Sistema"
        
        # Se o usuário tem militar associado, incluir posto com BM
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_assinante = f"{posto} {militar.nome_completo}"
        
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao}, em {data_formatada}, às {hora_formatada}, conforme horário oficial de Brasília, conforme portaria comando geral nº59/2020 publicada em boletim geral nº26/2020"
        
        # Adicionar logo do CBMEPI
        logo_path = os.path.join(settings.STATIC_ROOT, 'logo_cbmepi.png')
        if not os.path.exists(logo_path):
            logo_path = os.path.join(settings.STATICFILES_DIRS[0], 'logo_cbmepi.png') if settings.STATICFILES_DIRS else os.path.join(settings.BASE_DIR, 'static', 'logo_cbmepi.png')
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na última)
        if i < len(assinaturas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # Se não houver assinaturas, mostrar mensagem
    if not assinaturas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))

    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a função utilitária para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(quadro, request, tipo_documento='quadro')
    
    # Tabela do rodapé: QR + Texto de autenticação
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),

    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualização em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'quadro_acesso_{quadro.pk}.pdf')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginação e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # Ordenação padrão por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,  # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que têm CHO, depois os que não têm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terá sua própria numeração de antiguidade
        # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vão para o final
            x.nome_completo
        ))
        
        # Reordenar numeração de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeração para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeração para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÇÃO OBRIGATÓRIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # Padrão mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginação


        total_militares = militares.count()


        


        # Aplicar paginação


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para cadastrar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para editar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeração anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeração de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenação automática: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para excluir militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronéis (último posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronéis
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # Estatísticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Últimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # Notificações do usuário
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificações (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibição
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # Capitão
            '1T': 5,   # 1º Tenente
            '2T': 6,   # 2º Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de Adaptação
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # Estatísticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    oficiais_sem_ficha = total_oficiais_ativos - total_fichas_oficiais
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulário usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # Formulário padrão para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # Formulário padrão para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluída com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # Permissão especial para Diretor de Gestão de Pessoas ou Chefe da Seção de Promoções
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # Ordenação
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se é uma requisição AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatísticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transições (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se é um quadro de praças
    if quadro.tipo == 'PRACAS':
        # Para quadros de praças: transições específicas para praças
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # Praças
                {
                    'numero': 'I',
                    'titulo': '1º SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2º SARGENTO para o posto de 1º SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3º SARGENTO para o posto de 2º SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3º SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transições específicas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TC→CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transições por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2º TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }

            ],
            'SAUDE': [  # Saúde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2º TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # Lógica especial para o quadro ID 312 - forçar exibição da transição Major → Tenente-Coronel
    if quadro.id == 312:
        # Criar transição especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transição especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transição
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transição ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibição da transição MJ→TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso único por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso é obrigatório.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se não foi fornecida uma data, usar a data automática
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validação que bloqueava quadros para a mesma data/tipo
        # (permitir múltiplos quadros na mesma data)
        
        # Criar um único quadro que representará todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automática: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'Praças')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro está homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'Não é possível excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluído com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro não encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar não selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar já está no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} já está no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro é de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro não é de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados não podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar está no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} não está no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar não encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegíveis para promoção"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegíveis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmação de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissão de homologação - apenas presidente da comissão pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se é presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praças, verificar se é presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha é obrigatória.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuário que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuário que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso não elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lógica de geração automática
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # Edição básica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissão de homologação - apenas presidente da comissão pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se é presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praças, verificar se é presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

    buffer.seek(0)
    return FileResponse(buffer, as_attachment=True, filename=f'quadro_acesso_{quadro.pk}.pdf')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginação e busca"""
    militares = Militar.objects.filter(situacao='AT')
    
    # Busca
    query = request.GET.get('q')
    if query:
        militares = militares.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query) |
            Q(cpf__icontains=query) |
            Q(email__icontains=query)
        )
    
    # Filtros
    posto = request.GET.get('posto')
    if posto:
        # Mapear os valores do frontend para os códigos do banco
        posto_mapping = {
            'cb': 'CB',
            'tc': 'TC', 
            'mj': 'MJ',
            'cp': 'CP',
            '1t': '1T',
            '2t': '2T',
            'st': 'ST',
            '1s': '1S',
            '2s': '2S',
            '3s': '3S',
            'cab': 'CAB',
            'sd': 'SD',
            'nvrr': 'NVRR'
        }
        posto_codigo = posto_mapping.get(posto.lower())
        if posto_codigo:
            militares = militares.filter(posto_graduacao=posto_codigo)
    
    situacao = request.GET.get('situacao')
    if situacao:
        situacao_mapping = {
            'at': 'AT',
            'in': 'IN'
        }
        situacao_codigo = situacao_mapping.get(situacao.lower())
        if situacao_codigo:
            militares = militares.filter(situacao=situacao_codigo)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Ordenação padrão por hierarquia e antiguidade
    ordenacao = request.GET.get('ordenacao', 'hierarquia_antiguidade')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,  # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # NVRR é tratado separadamente - sem numeração de antiguidade
        # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para NVRR, não usar numeração de antiguidade
            0 if (x.posto_graduacao == 'NVRR' or x.quadro == 'NVRR') else (x.numeracao_antiguidade or 999999),
            x.nome_completo
        ))
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        # Excluir militares do NVRR da ordenação por antiguidade
        militares = militares.exclude(quadro='NVRR').exclude(posto_graduacao='NVRR').order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÇÃO OBRIGATÓRIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # Padrão mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginação


        total_militares = militares.count()


        


        # Aplicar paginação


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoções
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para cadastrar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save(commit=False)
            
            # Se for NVRR, garantir que não tenha numeração de antiguidade
            if militar.quadro == 'NVRR' or militar.posto_graduacao == 'NVRR':
                militar.numeracao_antiguidade = None
            
            militar.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para editar militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeração anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save(commit=False)
            
            # Se for NVRR, garantir que não tenha numeração de antiguidade
            if militar.quadro == 'NVRR' or militar.posto_graduacao == 'NVRR':
                militar.numeracao_antiguidade = None
            
            militar.save()
            
            # Se a numeração de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenação automática: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissão
    if not can_edit_militar(request.user):
        messages.error(request, 'Você não tem permissão para excluir militares. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
            'cpf': militar.cpf,
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    militares_inativos = total_militares - militares_ativos
    
    # Estatísticas detalhadas por posto/graduação
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    )
    
    # Definir hierarquia para ordenação
    hierarquia_posto = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
        'AL': 15,  # Aluno
    }
    
    # Ordenar estatísticas por hierarquia
    estatisticas_posto_list = list(estatisticas_posto)
    estatisticas_posto_list.sort(key=lambda x: hierarquia_posto.get(x['posto_graduacao'], 999))
    
    # Manter contadores gerais para compatibilidade
    oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    pracas_ativas = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['1S', '2S', '3S', 'CB', 'SD', 'AL']
    ).count()
    
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # Estatísticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Últimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # Notificações do usuário
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificações (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibição
    notificacoes = notificacoes_base[:10]
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_posto = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
        'AL': 15,  # Aluno
    }
    
    # Estatísticas por gênero - Posto/Graduação
    estatisticas_genero_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao', 'sexo').annotate(
        total=Count('id')
    ).order_by('posto_graduacao', 'sexo')
    
    # Ordenar por hierarquia
    estatisticas_genero_posto_list = list(estatisticas_genero_posto)
    estatisticas_genero_posto_list.sort(key=lambda x: hierarquia_posto.get(x['posto_graduacao'], 999))
    
    # Estatísticas por gênero - Quadro
    estatisticas_genero_quadro = Militar.objects.filter(situacao='AT').values('quadro', 'sexo').annotate(
        total=Count('id')
    ).order_by('quadro', 'sexo')
    
    # Totais por gênero
    total_homens = Militar.objects.filter(situacao='AT', sexo='M').count()
    total_mulheres = Militar.objects.filter(situacao='AT', sexo='F').count()
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'militares_inativos': militares_inativos,
        'oficiais_ativos': oficiais_ativos,
        'pracas_ativas': pracas_ativas,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto_list,
        'estatisticas_genero_posto': estatisticas_genero_posto_list,
        'estatisticas_genero_quadro': estatisticas_genero_quadro,
        'total_homens': total_homens,
        'total_mulheres': total_mulheres,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # Capitão
            '1T': 5,   # 1º Tenente
            '2T': 6,   # 2º Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de Adaptação
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # Estatísticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    
    # Buscar oficiais sem ficha
    oficiais_sem_ficha = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).exclude(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    )
    
    # Ordenar oficiais sem ficha por hierarquia
    hierarquia_oficiais = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
    }
    
    oficiais_sem_ficha_list = list(oficiais_sem_ficha)
    oficiais_sem_ficha_list.sort(key=lambda x: (
        hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
        x.nome_completo                                    # Depois por nome
    ))
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulário usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # Formulário padrão para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # Formulário padrão para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluída com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # Permissão especial para Diretor de Gestão de Pessoas ou Chefe da Seção de Promoções
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # Ordenação
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se é uma requisição AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatísticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transições (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se é um quadro de praças
    if quadro.tipo == 'PRACAS':
        # Para quadros de praças: transições específicas para praças
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # Praças
                {
                    'numero': 'I',
                    'titulo': '1º SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2º SARGENTO para o posto de 1º SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3º SARGENTO para o posto de 2º SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3º SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3º Sargento em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de não haver praça que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transições específicas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TC→CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJ→TC e CP→MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transições por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2º TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # Saúde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÇÃO para o posto de 2º TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1º TENENTE para o posto de CAPITÃO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Capitão em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2º TENENTE para o posto de 1º TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2º TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2º Tenente em virtude de não haver oficial que satisfaça os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nº 5.461, de 30 de junho de 2005, alterada pela Lei Nº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # Organizar militares por quadro e transição
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transição ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibição da transição MJ→TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso único por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso é obrigatório.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se não foi fornecida uma data, usar a data automática
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validação que bloqueava quadros para a mesma data/tipo
        # (permitir múltiplos quadros na mesma data)
        
        # Criar um único quadro que representará todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automática: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'Praças')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro está homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'Não é possível excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluído com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro não encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar não selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar já está no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} já está no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro é de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro não é de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados não podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar está no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} não está no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar não encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegíveis para promoção"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegíveis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmação de senha e função via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        funcao_id = request.POST.get('funcao_homologacao')
        
        # Verificar se a senha foi fornecida
        if not senha:
            messages.error(request, 'Senha é obrigatória.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a função foi selecionada
        if not funcao_id:
            messages.error(request, 'Função é obrigatória.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a senha está correta
        user = authenticate(username=request.user.username, password=senha)
        if user is None:
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a função existe e pertence ao usuário
        try:
            funcao = UsuarioFuncao.objects.get(id=funcao_id, usuario=request.user)
        except UsuarioFuncao.DoesNotExist:
            messages.error(request, 'Função inválida.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar permissão de homologação baseada na função selecionada
        if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
            # Para quadros de oficiais, verificar se é presidente da CPO
            comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
            if not comissao_cpo or not comissao_cpo.eh_presidente_por_funcao(request.user, funcao):
                messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                return redirect('militares:quadro_acesso_list')
        else:
            # Para quadros de praças, verificar se é presidente da CPP
            comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
            if not comissao_cpp or not comissao_cpp.eh_presidente_por_funcao(request.user, funcao):
                messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
                return redirect('militares:quadro_acesso_list')
        
        # Homologar o quadro
        if quadro.status == 'ELABORADO':
            quadro.status = 'HOMOLOGADO'
            quadro.data_homologacao = timezone.now().date()
            quadro.homologado_por = request.user
            quadro.save()
            messages.success(request, 'Quadro de acesso homologado com sucesso!')
            return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuário que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuário que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso não elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lógica de geração automática
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # Edição básica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissão de homologação - apenas presidente da comissão pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se é presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praças, verificar se é presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'Você não tem permissão para homologar quadros de praças. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros não elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

@login_required
def quadro_acesso_print(request, pk):
    """Versão para impressão do quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
        'itens': quadro.itemquadroacesso_set.all().order_by('posicao'),
    }
    
    return render(request, 'militares/quadro_acesso_print.html', context)

@login_required
def marcar_nao_elaborado(request, pk):
    """Marca um quadro como não elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        observacoes = request.POST.get('observacoes', '')
        
        quadro.status = 'NAO_ELABORADO'
        quadro.motivo_nao_elaboracao = motivo
        quadro.observacoes = observacoes
        quadro.save()
        
        # Limpar itens existentes
        quadro.itemquadroacesso_set.all().delete()
        
        messages.success(request, 'Quadro marcado como não elaborado.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

# Views para Promoções
@login_required
@requer_perm_promocoes_visualizar
def promocao_list(request):
    """Lista promoções"""
    # Filtros
    query = request.GET.get('q', '')
    criterio = request.GET.get('criterio', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    promocoes = Promocao.objects.all()
    
    # Aplicar filtros
    if query:
        promocoes = promocoes.filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(numero_ato__icontains=query)
        )
    
    if criterio:
        promocoes = promocoes.filter(criterio=criterio)
    
    if data_inicio:
        promocoes = promocoes.filter(data_promocao__gte=data_inicio)
    
    if data_fim:
        promocoes = promocoes.filter(data_promocao__lte=data_fim)
    
    promocoes = promocoes.order_by('-data_promocao')
    
    # Estatísticas
    total_promocoes = Promocao.objects.count()
    promocoes_este_ano = Promocao.objects.filter(data_promocao__year=timezone.now().year).count()
    militares_promovidos = Promocao.objects.values('militar').distinct().count()
    promocoes_merecimento = Promocao.objects.filter(criterio='MERECIMENTO').count()
    
    # Paginação
    paginator = Paginator(promocoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'promocoes': page_obj,
        'total_promocoes': total_promocoes,
        'promocoes_este_ano': promocoes_este_ano,
        'militares_promovidos': militares_promovidos,
        'promocoes_merecimento': promocoes_merecimento,
    }
    
    return render(request, 'militares/promocao_list.html', context)

@login_required
@requer_perm_promocoes_criar
def promocao_create(request):
    """Registra nova promoção"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')  # Novo campo
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        is_historica = request.POST.get('is_historica') == 'on'  # Novo campo
        
        if all([militar_id, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Se não foi informado posto anterior, usar o atual do militar
            if not posto_anterior:
                posto_anterior = militar.posto_graduacao
            
            # Cria promoção
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            # Só atualiza o militar se não for promoção histórica
            if not is_historica:
                # Capturar dados anteriores antes da promoção
                posto_anterior = militar.posto_graduacao
                quadro_anterior = militar.quadro
                
                # Atualizar posto e data de promoção
                militar.posto_graduacao = posto_novo
                militar.data_promocao_atual = data_promocao
                
                # Atribuir a próxima numeração disponível no novo posto
                nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
                
                # Reordenar os militares do posto anterior (preencher gap)
                militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
                
                militar.save()
                
                messages.success(
                    request, 
                    f'Promoção registrada com sucesso! {militar.nome_completo} recebeu a {nova_numeracao}ª numeração de antiguidade no posto de {militar.get_posto_graduacao_display()}. {militares_reordenados} militares foram reordenados no posto anterior.'
                )
            
            messages.success(request, f'Promoção registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    # Verificar se há um militar pré-selecionado na URL
    militar_pre_selecionado = None
    militar_id = request.GET.get('militar')
    if militar_id:
        try:
            militar_pre_selecionado = Militar.objects.get(pk=militar_id)
        except Militar.DoesNotExist:
            pass
    
    context = {
        'militares': Militar.objects.filter(situacao='AT').order_by('nome_completo'),
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'militar_pre_selecionado': militar_pre_selecionado,
    }
    
    return render(request, 'militares/promocao_form.html', context)

@login_required
def promocao_historica_create(request):
    """Registra promoção histórica (não atualiza o militar)"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        
        if all([militar_id, posto_anterior, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Cria promoção histórica (não atualiza o militar)
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-HIST-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            messages.success(request, f'Promoção histórica registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    context = {
        'militares': Militar.objects.all().order_by('nome_completo'),  # Todos os militares, não só ativos
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'is_historica': True,
    }
    
    return render(request, 'militares/promocao_form.html', context)

@login_required
@requer_perm_promocoes_admin
def promocao_delete(request, pk):
    promocao = get_object_or_404(Promocao, pk=pk)
    if request.method == 'POST':
        promocao.delete()
        messages.success(request, 'Promoção excluída com sucesso!')
        return redirect('militares:promocao_list')
    return render(request, 'militares/promocao_confirm_delete.html', {'promocao': promocao})

# Views para Vagas
@login_required
@requer_perm_vagas_visualizar
def vaga_list(request):
    """Quadro de Fixação de Vagas: mostra vagas do sistema separadas por quadro e permite inserir vagas manuais"""
    # Processa o formulário de vaga manual
    if request.method == 'POST':
        if 'vaga_manual' in request.POST:
            posto = request.POST.get('posto')
            quadro = request.POST.get('quadro')
            quantidade = request.POST.get('quantidade')
            justificativa = request.POST.get('justificativa')
            observacoes = request.POST.get('observacoes')
            if posto and quadro and quantidade and justificativa:
                try:
                    quantidade = int(quantidade)
                    if quantidade < 1:
                        quantidade = 1
                except ValueError:
                    quantidade = 1
                VagaManual.objects.create(
                    posto=posto,
                    quadro=quadro,
                    quantidade=quantidade,
                    justificativa=justificativa,
                    observacoes=observacoes or ''
                )
                messages.success(request, 'Vaga manual inserida com sucesso!')
                return redirect('vaga_list')
        
        # Processa atualização de vagas fixadas
        elif 'atualizar_vagas_fixadas' in request.POST:
            for key, value in request.POST.items():
                if key.startswith('vagas_fixadas_'):
                    # Extrai o ID da previsão de vaga
                    previsao_id = key.replace('vagas_fixadas_', '')
                    try:
                        previsao = PrevisaoVaga.objects.get(id=previsao_id)
                        vagas_fixadas = int(value) if value else 0
                        previsao.vagas_fixadas = vagas_fixadas
                        
                        # Busca observações correspondentes
                        obs_key = f'observacoes_vagas_fixadas_{previsao_id}'
                        observacoes = request.POST.get(obs_key, '')
                        previsao.observacoes_vagas_fixadas = observacoes
                        
                        previsao.save()
                    except (PrevisaoVaga.DoesNotExist, ValueError):
                        continue
            
            messages.success(request, 'Vagas fixadas atualizadas com sucesso!')
            return redirect('vaga_list')
    
    # Busca previsões de vagas por quadro (oficiais)
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        posto__in=['2T', '1T', 'CP', 'MJ', 'TC', 'CB'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Busca previsões de vagas por quadro (praças)
    previsoes_pracas = PrevisaoVaga.objects.filter(
        posto__in=['ST', 'SGT', 'CB', 'SD'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Organiza por quadro
    vagas_oficiais_por_quadro = {}
    vagas_pracas_por_quadro = {}
    
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_oficiais_por_quadro:
            vagas_oficiais_por_quadro[previsao.quadro] = []
        vagas_oficiais_por_quadro[previsao.quadro].append(previsao)
    
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_pracas_por_quadro:
            vagas_pracas_por_quadro[previsao.quadro] = []
        vagas_pracas_por_quadro[previsao.quadro].append(previsao)
    
    # Busca vagas manuais
    vagas_manuais = VagaManual.objects.all().order_by('-data_solicitacao')
    
    context = {
        'vagas_oficiais_por_quadro': vagas_oficiais_por_quadro,
        'vagas_pracas_por_quadro': vagas_pracas_por_quadro,
        'vagas_manuais': vagas_manuais,
        'quadros': [
            ('COMB', 'Quadro de Oficiais Bombeiros Militares Combatentes - QOBM/Comb.'),
            ('SAUDE', 'Quadro de Oficiais Bombeiros Militares de Saúde - QOBM/Saúde'),
            ('ENG', 'Quadro de Oficiais Bombeiros Militares Engenheiros - QOBM/Eng.'),
            ('COMP', 'Quadro de Oficiais Bombeiros Militares Complementar - QOBM/Comp.'),
        ]
    }
    
    return render(request, 'militares/vaga_list.html', context)

@login_required
@requer_perm_vagas_editar
def vaga_update(request, pk):
    """Atualiza vaga"""
    vaga = get_object_or_404(Vaga, pk=pk)
    
    if request.method == 'POST':
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        
        if efetivo_atual and efetivo_maximo:
            vaga.efetivo_atual = int(efetivo_atual)
            vaga.efetivo_maximo = int(efetivo_maximo)
            vaga.save()
            
            messages.success(request, f'Vaga atualizada com sucesso!')
            return redirect('militares:vaga_list')
    
    context = {
        'vaga': vaga,
    }
    
    return render(request, 'militares/vaga_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form(request, militar_pk):
    """Formulário de ficha de conceito com upload de documentos - redireciona para view específica"""
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se é oficial ou praça
    postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    is_oficial = militar.posto_graduacao in postos_oficiais
    
    if is_oficial:
        # Se é oficial, usar a view genérica (que já funciona para oficiais)
        return ficha_conceito_form_oficiais(request, militar_pk)
    else:
        # Se é praça, redirecionar para a view específica de praças
        from .views_pracas import ficha_conceito_pracas_form
        return ficha_conceito_pracas_form(request, militar_pk)

from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form_oficiais(request, militar_pk):
    """Formulário de ficha de conceito para oficiais com upload de documentos"""
    # Verificar permissão
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'Você não tem permissão para editar fichas de conceito. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se já existe uma ficha para este militar
    ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
    ficha_existente_pracas = militar.fichaconceitopracas_set.first()
    
    if request.method == 'POST':
        if ficha_existente_oficiais:
            # Se já existe ficha de oficiais, atualizar
            form = FichaConceitoOficiaisForm(request.POST, request.FILES, instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se já existe ficha de praças, atualizar
            form = FichaConceitoPracasForm(request.POST, request.FILES, instance=ficha_existente_pracas, militar=militar)
        else:
            # Se não existe, criar nova ficha baseada no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(request.POST, request.FILES, militar=militar)
            else:
                form = FichaConceitoPracasForm(request.POST, request.FILES, militar=militar)
        
        if form.is_valid():
            ficha = form.save(commit=False)
            ficha.militar = militar
            ficha.save()
            
            # Processar documentos se fornecidos
            documentos = request.FILES.getlist('documentos')
            for doc_file in documentos:
                Documento.objects.create(
                    militar=militar,
                    ficha_conceito=ficha,
                    tipo='OUTROS',
                    titulo=f"Documento: {doc_file.name}",
                    arquivo=doc_file
                )
            
            messages.success(request, 'Ficha de conceito salva com sucesso!')
            return redirect('militares:ficha_conceito_list')
        else:
            # Debug: mostrar erros do formulário
            print("Erros do formulário:", form.errors)
            messages.error(request, f'Erro ao salvar ficha de conceito: {form.errors}')
    else:
        if ficha_existente_oficiais:
            # Se já existe ficha de oficiais, carregar dados
            form = FichaConceitoOficiaisForm(instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se já existe ficha de praças, carregar dados
            form = FichaConceitoPracasForm(instance=ficha_existente_pracas, militar=militar)
        else:
            # Se não existe, criar formulário vazio baseado no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(militar=militar)
            else:
                form = FichaConceitoPracasForm(militar=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'ficha': ficha_existente_oficiais or ficha_existente_pracas,
        'documento_form': DocumentoForm(),
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_edit(request, pk):
    """Editar ficha de conceito"""
    # Verificar permissão
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'Você não tem permissão para editar fichas de conceito. Apenas administradores, chefes da seção de promoções e diretores de gestão de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        form_class = FichaConceitoOficiaisForm
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            form_class = FichaConceitoPracasForm
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = form_class(request.POST, instance=ficha, militar=ficha.militar)
        if form.is_valid():
            form.save()
            messages.success(request, 'Ficha de conceito atualizada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        form = form_class(instance=ficha, militar=ficha.militar)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    tipo_ficha = None
    
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        tipo_ficha = 'oficiais'
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            tipo_ficha = 'pracas'
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    # Calcular pontos detalhados para exibição
    if tipo_ficha == 'oficiais':
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': min(ficha.tempo_posto * 1.0, 5.0),
                'limite': 5.0,
                'descricao': 'Tempo de Serviço no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao + ficha.cursos_csbm,
                'pontos': min((ficha.cursos_especializacao * 2.5 + ficha.cursos_csbm * 4.0), 5.0),
                'limite': 5.0,
                'descricao': 'Conclusão de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho + ficha.cursos_cfo +
                         ficha.cursos_cao + ficha.cursos_instrutor_csbm),
                'pontos': min((ficha.cursos_cfsd * 0.5 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.0 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.5 + ficha.cursos_cfo * 1.75 +
                              ficha.cursos_cao * 3.0 + ficha.cursos_instrutor_csbm * 2.5), 10.0),
                'limite': 10.0,
                'descricao': 'Instrutor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_superior + ficha.cursos_civis_especializacao +
                         ficha.cursos_civis_mestrado + ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_superior * 1.5 + ficha.cursos_civis_especializacao * 2.0 +
                          ficha.cursos_civis_mestrado * 3.0 + ficha.cursos_civis_doutorado * 4.0),
                'limite': None,
                'descricao': 'Conclusão em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.5 + ficha.medalha_estadual * 0.25 +
                              ficha.medalha_cbmepi * 0.25), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e Condecorações'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.25 + ficha.elogio_coletivo * 0.125), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 0.25 + ficha.punicao_detencao * 0.5 +
                           ficha.punicao_prisao * 1.0),
                'limite': None,
                'descricao': 'Punições'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 0.5),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    else:  # praças
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': ficha.tempo_posto * 1.0,
                'limite': None,
                'descricao': 'Tempo de Serviço no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao,
                'pontos': min((ficha.cursos_especializacao * 2.0), 4.0),
                'limite': 4.0,
                'descricao': 'Conclusão de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho),
                'pontos': min((ficha.cursos_cfsd * 0.50 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.00 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.50), 5.0),
                'limite': 5.0,
                'descricao': 'Monitor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_tecnico + ficha.cursos_civis_superior + 
                         ficha.cursos_civis_especializacao + ficha.cursos_civis_mestrado + 
                         ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_tecnico * 1.75 + ficha.cursos_civis_superior * 3.00 +
                          ficha.cursos_civis_especializacao * 4.00 + ficha.cursos_civis_mestrado * 9.00 +
                          ficha.cursos_civis_doutorado * 15.00),
                'limite': None,
                'descricao': 'Conclusão em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.50 + ficha.medalha_estadual * 0.30 +
                              ficha.medalha_cbmepi * 0.20), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e Condecorações'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.15 + ficha.elogio_coletivo * 0.10), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 1.0 + ficha.punicao_detencao * 2.0 +
                           ficha.punicao_prisao * 5.0),
                'limite': None,
                'descricao': 'Punições'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 10.0),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
        'pontos_detalhados': pontos_detalhados,
        'total_pontos': ficha.calcular_pontos(),
        'tipo_ficha': tipo_ficha,
    }
    
    response = render(request, 'militares/ficha_conceito_detail.html', context)
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    return response

@login_required
def documento_upload(request, ficha_pk):
    """Upload de documentos para ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    ficha_tipo = None
    
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
        ficha_tipo = 'oficiais'
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=ficha_pk)
            ficha_tipo = 'pracas'
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.militar = ficha.militar
            
            # Atribuir ao campo correto baseado no tipo de ficha
            if ficha_tipo == 'oficiais':
                documento.ficha_conceito_oficiais = ficha
            else:
                documento.ficha_conceito_pracas = ficha
            
            documento.save()
            
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    else:
        form = DocumentoForm()
    
    # Buscar documentos relacionados à ficha
    if ficha_tipo == 'oficiais':
        documentos = Documento.objects.filter(ficha_conceito_oficiais=ficha)
    else:
        documentos = Documento.objects.filter(ficha_conceito_pracas=ficha)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
        'documentos': documentos,
    }
    
    return render(request, 'militares/documento_upload.html', context)

@login_required
def conferir_ficha(request, pk):
    """Conferir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito não encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar']:
            # Atualiza apenas as observações, já que não há campo status
            ficha.observacoes = observacoes
            ficha.save()
            
            messages.success(request, f'Ficha {acao}da com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/conferir_ficha.html', context)

@login_required
def conferir_documento(request, pk):
    """Conferir documento"""
    documento = get_object_or_404(Documento, pk=pk)
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar', 'arquivar']:
            documento.status = acao.upper()
            documento.conferido_por = request.user
            documento.data_conferencia = timezone.now()
            documento.observacoes = observacoes
            documento.save()
            
            messages.success(request, f'Documento {acao}do com sucesso!')
            return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/conferir_documento.html', context)

@login_required
@requer_perm_promocoes_visualizar
def promocao_detail(request, pk):
    """Detalhes da promoção"""
    promocao = get_object_or_404(Promocao, pk=pk)
    
    context = {
        'promocao': promocao,
    }
    
    return render(request, 'militares/promocao_detail.html', context)

@login_required
def estatisticas(request):
    """Estatísticas do sistema"""
    # Estatísticas gerais
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    
    # Por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Por posto
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    ).order_by('posto_graduacao')
    
    # Fichas de conceito
    total_fichas = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    fichas_aprovadas = 0  # Removido filtro por status que não existe
    fichas_pendentes = 0  # Removido filtro por status que não existe
    
    # Documentos
    total_documentos = Documento.objects.count()
    documentos_aprovados = Documento.objects.filter(status='APROVADO').count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # Estatísticas dos quadros de acesso
    total_quadros_acesso = QuadroAcesso.objects.count()
    if total_quadros_acesso > 0:
        estatisticas_quadros_acesso = {
            'total': total_quadros_acesso,
            'elaborados': QuadroAcesso.objects.filter(status='ELABORADO').count(),
            'homologados': QuadroAcesso.objects.filter(status='HOMOLOGADO').count(),
            'nao_elaborados': QuadroAcesso.objects.filter(status='NAO_ELABORADO').count(),
            'em_elaboracao': QuadroAcesso.objects.filter(status='EM_ELABORACAO').count(),
            'militares_aptos': sum([q.itemquadroacesso_set.count() for q in QuadroAcesso.objects.filter(status='ELABORADO')]),
            'status': list(QuadroAcesso.objects.values('status').annotate(total=Count('id'))),
            'tipo': list(QuadroAcesso.objects.values('tipo').annotate(total=Count('id'))),
            'categoria': list(QuadroAcesso.objects.values('categoria').annotate(total=Count('id'))),
        }
    else:
        estatisticas_quadros_acesso = None
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto,
        'total_fichas': total_fichas,
        'fichas_aprovadas': fichas_aprovadas,
        'fichas_pendentes': fichas_pendentes,
        'total_documentos': total_documentos,
        'documentos_aprovados': documentos_aprovados,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadros_acesso': estatisticas_quadros_acesso,
    }
    
    return render(request, 'militares/estatisticas.html', context)

def register(request):
    """Registro de usuário"""
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Conta criada com sucesso! Faça login para continuar.')
            return redirect('login')
    else:
        form = UserRegistrationForm()
    
    return render(request, 'registration/register.html', {'form': form})

def intersticio_list(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # Saúde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # Praças
    }
    
    # Buscar interstícios ativos
    intersticios = list(Intersticio.objects.filter(ativo=True))
    
    # Filtrar apenas postos de praças no quadro de praças
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    return render(request, 'militares/intersticio_list.html', {'intersticios': intersticios_ordenados})

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_manage(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # Saúde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # Praças
    }
    
    # Buscar todos os interstícios
    intersticios = list(Intersticio.objects.all())
    
    # Filtrar apenas postos de praças no quadro de praças
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for inter in intersticios_ordenados:
            anos = request.POST.get(f'anos_{inter.id}', '').strip()
            meses = request.POST.get(f'meses_{inter.id}', '').strip()
            try:
                inter.tempo_minimo_anos = int(anos) if anos.isdigit() else 0
                inter.tempo_minimo_meses = int(meses) if meses.isdigit() else 0
                inter.save()
            except Exception as e:
                messages.error(request, f'Erro ao salvar {inter}: {e}')
        messages.success(request, 'Interstícios atualizados com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticios': intersticios_ordenados,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/intersticio_manage.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_create(request):
    """Criar novo interstício"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        anos = request.POST.get('novo_anos', '0')
        meses = request.POST.get('novo_meses', '0')
        
        try:
            # Verificar se já existe um interstício para este quadro/posto
            if Intersticio.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'Já existe um interstício para este quadro e posto!')
            else:
                Intersticio.objects.create(
                    quadro=quadro,
                    posto=posto,
                    tempo_minimo_anos=int(anos),
                    tempo_minimo_meses=int(meses),
                    ativo=True
                )
                messages.success(request, 'Interstício criado com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar interstício: {e}')
    
    return redirect('militares:intersticio_manage')

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_delete(request, pk):
    """Excluir interstício"""
    intersticio = get_object_or_404(Intersticio, pk=pk)
    
    if request.method == 'POST':
        intersticio.delete()
        messages.success(request, 'Interstício excluído com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticio': intersticio,
    }
    
    return render(request, 'militares/intersticio_confirm_delete.html', context)

@login_required
def marcar_cursos_inerentes(request, militar_pk):
    """Marca automaticamente os cursos inerentes ao quadro do militar"""
    if request.method == 'POST':
        militar = get_object_or_404(Militar, pk=militar_pk)
        militar.marcar_cursos_inerentes()
        return JsonResponse({'success': True, 'message': 'Cursos inerentes marcados com sucesso!'})
    return JsonResponse({'success': False, 'message': 'Método não permitido'}, status=405)

@login_required
def relatorio_requisitos_quadro(request, pk):
    """Relatório detalhado dos requisitos dos militares para um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    # Buscar militares candidatos para o quadro específico
    # Definir postos baseado no tipo de quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadro de merecimento: incluir TC apenas para COMB (TC→CB), excluir subtenentes (ST)
        postos = ['2T', '1T', 'CP', 'MJ', 'TC']
    else:
        # Para quadro de antiguidade: incluir todos os postos
        postos = ['ST', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    
    # Buscar militares candidatos baseado no tipo de quadro
    militares_candidatos = []
    
    # Para quadros de merecimento, buscar apenas militares com ficha de conceito
    if quadro.tipo == 'MERECIMENTO':
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        ).filter(
            posto_graduacao__in=postos
        )
    else:
        # Para quadros de antiguidade, buscar todos os militares ativos
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            posto_graduacao__in=postos
        )
    
    # Debug: imprimir quantidade de candidatos encontrados
    print(f"DEBUG: Encontrados {len(militares_candidatos)} militares candidatos para o quadro {quadro.tipo}")
    
    relatorio = []
    for militar in militares_candidatos:
        # Validar cada requisito individualmente
        tem_ficha = militar.fichaconceitooficiais_set.exists() or militar.fichaconceitopracas_set.exists()
        
        apto_intersticio = quadro._validar_intersticio_minimo(militar, quadro.data_promocao)
        motivo_intersticio = ""
        if not apto_intersticio:
            motivo_intersticio = "Interstício insuficiente até a data da promoção"
        
        apto_saude = quadro._validar_inspecao_saude(militar)
        motivo_saude = ""
        if not apto_saude:
            motivo_saude = "Inspeção de saúde vencida ou não realizada"
        
        apto_cursos = quadro._validar_cursos_inerentes(militar)
        motivo_cursos = ""
        if not apto_cursos:
            motivo_cursos = "Cursos inerentes insuficientes para o posto subsequente"
        
        # Status geral
        apto_geral = tem_ficha and apto_intersticio and apto_saude and apto_cursos
        
        relatorio.append({
            'militar': militar,
            'tem_ficha': tem_ficha,
            'apto_intersticio': apto_intersticio,
            'motivo_intersticio': motivo_intersticio,
            'apto_saude': apto_saude,
            'motivo_saude': motivo_saude,
            'apto_cursos': apto_cursos,
            'motivo_cursos': motivo_cursos,
            'apto_geral': apto_geral,
            'tempo_no_posto': militar.tempo_posto_atual(),
            'data_inspecao': militar.data_inspecao_saude,
            'validade_inspecao': militar.data_validade_inspecao_saude,
        })
    
    # Ordenar por status (aptos primeiro) e depois por nome
    relatorio.sort(key=lambda x: (not x['apto_geral'], x['militar'].nome_completo))
    
    context = {
        'quadro': quadro,
        'relatorio': relatorio,
        'total_candidatos': len(relatorio),
        'total_aptos': sum(1 for r in relatorio if r['apto_geral']),
        'total_inaptos': sum(1 for r in relatorio if not r['apto_geral']),
    }
    
    return render(request, 'militares/relatorio_requisitos_quadro.html', context)

@login_required
def test_template(request):
    """View de teste para verificar se o problema persiste"""
    quadros = QuadroAcesso.objects.all()
    
    # Calcular estatísticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/simple_test.html', context)

class RelatorioAptosPromocaoForm(forms.Form):
    tipo = forms.ChoiceField(choices=[('ANTIGUIDADE', 'Antiguidade'), ('MERECIMENTO', 'Merecimento')], label="Tipo de Quadro de Acesso")
    data_promocao = forms.DateField(label="Data prevista para promoção", widget=forms.DateInput(attrs={'type': 'date'}))

@login_required
def relatorio_aptos_promocao(request):
    QUADROS = [
        ('COMB', 'Combatente'),
        ('SAUDE', 'Saúde'),
        ('ENG', 'Engenharia'),
        ('COMP', 'Complementar'),
    ]
    POSTOS = [
        ('2T', '2º Tenente'),
        ('1T', '1º Tenente'),
        ('CP', 'Capitão'),
        ('MJ', 'Major'),
        ('TC', 'Tenente-Coronel'),
        ('CB', 'Coronel'),
    ]
    relatorio = []
    form = RelatorioAptosPromocaoForm(request.GET or None)
    if form.is_valid():
        tipo = form.cleaned_data['tipo']
        data_promocao = form.cleaned_data['data_promocao']
        for cod_quadro, nome_quadro in QUADROS:
            quadro_data = {'nome': nome_quadro, 'postos': []}
            for cod_posto, nome_posto in POSTOS:
                militares = Militar.objects.filter(
                    quadro=cod_quadro,
                    posto_graduacao=cod_posto,
                    situacao='AT'
                ).filter(
                    Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
                ).distinct()
                aptos = []
                for militar in militares:
                    # Usa as regras já implementadas no modelo QuadroAcesso
                    dummy_quadro = QuadroAcesso(tipo=tipo, categoria='OFICIAIS' if cod_quadro in ['COMB', 'SAUDE', 'ENG', 'COMP'] else 'PRACAS', data_promocao=data_promocao)
                    apto, _ = dummy_quadro.validar_requisitos_quadro_acesso(militar, data_promocao)
                    if apto:
                        aptos.append(militar)
                quadro_data['postos'].append({
                    'nome': nome_posto,
                    'aptos': aptos,
                })
            relatorio.append(quadro_data)
    context = {
        'form': form,
        'relatorio': relatorio,
        'form_submitted': form.is_valid(),
        'tipo': form.cleaned_data['tipo'] if form.is_valid() else None,
        'data_promocao': form.cleaned_data['data_promocao'] if form.is_valid() else None,
    }
    return render(request, 'militares/relatorio_aptos_promocao.html', context)

@login_required
def test_quadro_simple(request):
    """View de teste muito simples para verificar se o problema é específico da página de quadros"""
    return render(request, 'militares/simple_test.html', {
        'estatisticas': {
            'total': 0,
            'elaborados': 0,
            'nao_elaborados': 0,
            'em_elaboracao': 0,
        }
    })

@login_required
def criar_quadro_manual(request):
    """Cria um quadro de acesso manual"""
    if request.method == 'POST':
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not data_promocao:
            messages.error(request, 'A data de promoção é obrigatória.')
            return redirect('militares:criar_quadro_manual')
        
        try:
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoção inválida.')
            return redirect('militares:criar_quadro_manual')
        
        # Verificar se já existe um quadro manual para esta data (permitir múltiplos quadros)
        # quadro_existente = QuadroAcesso.objects.filter(
        #     tipo='MANUAL',
        #     data_promocao=data_promocao
        # ).first()
        
        # if quadro_existente:
        #     messages.warning(request, f'Já existe um quadro manual para a data {data_promocao.strftime("%d/%m/%Y")}.')
        #     return redirect('militares:quadro_acesso_detail', pk=quadro_existente.pk)
        
        # Criar o quadro manual
        try:
            novo_quadro = QuadroAcesso.objects.create(
                tipo='MANUAL',
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                is_manual=True,
                criterio_ordenacao_manual=request.POST.get('criterio_ordenacao', 'MANUAL'),
                observacoes=observacoes or f"Quadro manual para {data_promocao.strftime('%d/%m/%Y')}"
            )
            
            messages.success(request, f'Quadro manual criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            # Redirecionar para a view correta baseada na categoria
            if novo_quadro.categoria == 'PRACAS':
                return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
            else:
                return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro manual: {str(e)}')
        
        return redirect('militares:criar_quadro_manual')
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
    }
    
    return render(request, 'militares/criar_quadro_manual.html', context)

@login_required
def adicionar_militar_quadro_manual(request, pk):
    """Adiciona um militar ao quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares adicionados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao', 0)
        
        if not militar_id:
            messages.error(request, 'Selecione um militar.')
            return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Converter posição para inteiro se fornecida
            posicao_int = None
            if posicao:
                try:
                    posicao_int = int(posicao)
                except ValueError:
                    messages.error(request, 'Posição deve ser um número inteiro.')
                    return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
            
            # Converter pontuação para decimal
            try:
                pontuacao_decimal = float(pontuacao)
            except ValueError:
                pontuacao_decimal = 0
            
            # Adicionar militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao_int, pontuacao_decimal)
            
            messages.success(request, f'Militar {militar.nome_completo} adicionado ao quadro com sucesso!')
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_manual(request, pk, militar_id):
    """Remove um militar do quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} não encontrado. O quadro pode ter sido excluído anteriormente ou o ID está incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares removidos.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        try:
            militar = Militar.objects.get(pk=militar_id)
            quadro.remover_militar_manual(militar)
            messages.success(request, f'Militar {militar.nome_completo} removido do quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_militares_ajax(request):
    """Busca militares para adicionar ao quadro manual via AJAX"""
    if request.method == 'GET':
        termo = request.GET.get('termo', '')
        if len(termo) < 2:
            return JsonResponse({'militares': []})
        
        militares = Militar.objects.filter(
            situacao='AT',
            nome_completo__icontains=termo
        ).values('id', 'nome_completo', 'posto_graduacao', 'quadro', 'matricula')[:10]
        
        return JsonResponse({'militares': list(militares)})
    
    return JsonResponse({'militares': []})

@login_required
def buscar_pontuacao_militar(request, militar_id):
    """Retorna a pontuação da ficha de conceito do militar"""
    from militares.models import Militar
    try:
        militar = Militar.objects.get(pk=militar_id)
        ficha = militar.fichaconceitooficiais_set.first() or militar.fichaconceitopracas_set.first()
        pontuacao = ficha.pontos if ficha else 0
        return JsonResponse({'pontuacao': float(pontuacao)})
    except Militar.DoesNotExist:
        return JsonResponse({'pontuacao': 0})

@login_required
def gerar_fichas_conceito_todos(request):
    """Gera fichas de conceito para todos os militares cadastrados que ainda não possuem"""
    if request.method == 'POST':
        # Verificar se está sendo chamado da página de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas oficiais ativos
            militares_ativos = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            tipo_militar = "oficiais"
        else:
            # Buscar todos os militares ativos
            militares_ativos = Militar.objects.filter(situacao='AT')
            tipo_militar = "militares"
        
        # Buscar militares que não possuem ficha de conceito
        militares_sem_ficha = militares_ativos.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        fichas_criadas = 0
        militares_processados = 0
        
        for militar in militares_sem_ficha:
            # Verificar se já existe ficha para este militar (dupla verificação)
            ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
            ficha_existente_pracas = militar.fichaconceitopracas_set.first()
            
            if not ficha_existente_oficiais and not ficha_existente_pracas:
                # Determinar qual tipo de ficha criar baseado no posto
                if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                    # Criar ficha de oficiais
                    ficha = FichaConceitoOficiais.objects.create(
                        militar=militar,
                    )
                else:
                    # Criar ficha de praças
                    ficha = FichaConceitoPracas.objects.create(
                        militar=militar,
                    )
                fichas_criadas += 1
            
            militares_processados += 1
        
        # Mensagens informativas
        if fichas_criadas > 0:
            messages.success(request, f'✅ Foram criadas {fichas_criadas} fichas de conceito com tempo de serviço no posto para {tipo_militar} que não possuíam.')
        else:
            messages.info(request, f'ℹ️ Todos os {tipo_militar} ativos já possuem fichas de conceito.')
        
        if militares_processados > 0:
            messages.info(request, f'📊 Processados {militares_processados} {tipo_militar} ativos.')
        
        # Informação adicional sobre militares que já tinham fichas
        militares_com_ficha = militares_ativos.count() - militares_sem_ficha.count()
        if militares_com_ficha > 0:
            messages.info(request, f'🔒 {militares_com_ficha} {tipo_militar} já possuíam fichas de conceito e não foram alterados.')
    
    return redirect('militares:ficha_conceito_list')

@login_required
@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def limpar_pontos_fichas_conceito(request):
    """Limpa os pontos das fichas de conceito, mantendo apenas o tempo no posto"""
    if request.method == 'POST':
        # Verificar se está sendo chamado da página de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas fichas de oficiais
            oficiais = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
            tipo_militar = "oficiais"
        else:
            # Buscar todas as fichas de conceito
            fichas_oficiais = FichaConceitoOficiais.objects.all()
            fichas_pracas = FichaConceitoPracas.objects.all()
            fichas = list(fichas_oficiais) + list(fichas_pracas)
            tipo_militar = "militares"
        
        fichas_limpas = 0
        
        for ficha in fichas:
            # Salvar o tempo no posto atual
            tempo_posto_atual = ficha.militar.tempo_posto_atual()
            
            # Atualizar diretamente no banco para evitar chamar o método save()
            if isinstance(ficha, FichaConceitoOficiais):
                FichaConceitoOficiais.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            else:
                FichaConceitoPracas.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            fichas_limpas += 1
        
        if fichas_limpas > 0:
            messages.success(request, f'✅ Foram limpas {fichas_limpas} fichas de conceito de {tipo_militar}. Apenas o tempo no posto foi mantido.')
        else:
            messages.info(request, f'ℹ️ Nenhuma ficha de conceito de {tipo_militar} encontrada para limpeza.')
    
    return redirect('militares:ficha_conceito_list')

@login_required
@requer_perm_vagas_criar
def vaga_create(request):
    """Cria uma nova vaga"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        if posto and quadro and efetivo_maximo:
            vaga = Vaga(
                posto=posto,
                quadro=quadro,
                efetivo_atual=efetivo_atual or 0,
                efetivo_maximo=efetivo_maximo
            )
            vaga.save()
            messages.success(request, 'Vaga criada com sucesso!')
            return redirect('militares:vaga_list')
        else:
            messages.error(request, 'Preencha todos os campos obrigatórios.')
    # Para GET, exibe o mesmo modal, mas normalmente só é chamado via POST
    return redirect('militares:vaga_list')

# Views para Previsão de Vagas
def previsao_vaga_list(request):
    """Lista todas as previsões de vagas organizadas por quadro"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # Saúde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # Praças
    }
    
    # Buscar previsões de vagas ativas
    previsoes = list(PrevisaoVaga.objects.filter(ativo=True))
    
    # Calcular efetivo atual baseado nos militares cadastrados
    for previsao in previsoes:
        # Subtenentes estão cadastrados como COMP mas contam para PRACAS
        if previsao.posto == 'ST' and previsao.quadro == 'PRACAS':
            # Contar ST cadastrados como COMP (quadro de origem)
            efetivo_atual = Militar.objects.filter(
                posto_graduacao='ST',
                quadro='COMP',  # ST estão cadastrados como COMP
                situacao='AT'   # Apenas militares ativos
            ).count()
        else:
            # Para outros postos, contar normalmente
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'  # Apenas militares ativos
            ).count()
        
        previsao.efetivo_atual = efetivo_atual
        previsao.save()  # Isso vai recalcular vagas_disponiveis automaticamente
    
    # Remover previsões de vaga de ST em quadros que não sejam PRACAS
    previsoes = [p for p in previsoes if not (p.posto == 'ST' and p.quadro != 'PRACAS')]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    # Calcular estatísticas gerais
    total_efetivo_atual = sum(p.efetivo_atual for p in previsoes_ordenadas)
    total_efetivo_previsto = sum(p.efetivo_previsto for p in previsoes_ordenadas)
    total_vagas_disponiveis = sum(p.vagas_disponiveis for p in previsoes_ordenadas)
    
    context = {
        'previsoes': previsoes_ordenadas,
        'total_efetivo_atual': total_efetivo_atual,
        'total_efetivo_previsto': total_efetivo_previsto,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/previsao_vaga_list.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_manage(request):
    """Gerenciar previsões de vagas"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # Saúde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # Praças
    }
    
    # Buscar todas as previsões de vagas
    previsoes = list(PrevisaoVaga.objects.all())
    
    # Filtrar apenas postos de praças no quadro de praças
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    previsoes = [p for p in previsoes if p.quadro != 'PRACAS' or p.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for previsao in previsoes_ordenadas:
            efetivo_atual = request.POST.get(f'efetivo_atual_{previsao.id}', '').strip()
            efetivo_previsto = request.POST.get(f'efetivo_previsto_{previsao.id}', '').strip()
            try:
                previsao.efetivo_atual = int(efetivo_atual) if efetivo_atual.isdigit() else 0
                previsao.efetivo_previsto = int(efetivo_previsto) if efetivo_previsto.isdigit() else 0
                previsao.save()
                # Recarregar o objeto do banco para verificar se o cálculo foi aplicado
                previsao.refresh_from_db()
                print(f"[DEBUG] PrevisaoVaga ID {previsao.id} | Atual: {previsao.efetivo_atual} | Previsto: {previsao.efetivo_previsto} | Vagas Disponíveis: {previsao.vagas_disponiveis}")
            except Exception as e:
                messages.error(request, f'Erro ao salvar {previsao}: {e}')
        messages.success(request, 'Previsões de vagas atualizadas com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsoes': previsoes_ordenadas,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/previsao_vaga_manage.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_create(request):
    """Criar nova previsão de vaga"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        efetivo_atual = request.POST.get('novo_efetivo_atual', '0')
        efetivo_previsto = request.POST.get('novo_efetivo_previsto', '0')
        
        try:
            # Verificar se já existe uma previsão para este quadro/posto
            if PrevisaoVaga.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'Já existe uma previsão de vaga para este quadro e posto!')
            else:
                PrevisaoVaga.objects.create(
                    quadro=quadro,
                    posto=posto,
                    efetivo_atual=int(efetivo_atual),
                    efetivo_previsto=int(efetivo_previsto),
                    ativo=True
                )
                messages.success(request, 'Previsão de vaga criada com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar previsão de vaga: {e}')
    
    return redirect('militares:previsao_vaga_manage')

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_delete(request, pk):
    """Excluir previsão de vaga"""
    previsao = get_object_or_404(PrevisaoVaga, pk=pk)
    
    if request.method == 'POST':
        previsao.delete()
        messages.success(request, 'Previsão de vaga excluída com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsao': previsao,
    }
    
    return render(request, 'militares/previsao_vaga_confirm_delete.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_delete_ajax(request, pk):
    """Excluir previsão de vaga via AJAX"""
    if request.method == 'POST':
        try:
            previsao = PrevisaoVaga.objects.get(pk=pk)
            previsao.delete()
            return JsonResponse({'success': True})
        except PrevisaoVaga.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'Previsão de vaga não encontrada'})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Método não permitido'})

@login_required
@requer_perm_documentos_excluir
def documento_delete(request, pk):
    """Excluir documento"""
    try:
        documento = Documento.objects.get(pk=pk)
    except Documento.DoesNotExist:
        messages.error(request, f'Documento com ID {pk} não encontrado. O documento pode ter sido excluído anteriormente ou o ID está incorreto.')
        # Redirecionar para a lista de militares se não conseguir identificar o militar
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        nome_arquivo = documento.filename()
        militar_pk = documento.militar.pk
        documento.delete()
        messages.success(request, f'Documento "{nome_arquivo}" excluído com sucesso!')
        return redirect('militares:militar_detail', pk=militar_pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/documento_confirm_delete.html', context)

@login_required
def assinar_documentos_quadro(request, pk):
    """Página para assinar documentos de um quadro de acesso"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Buscar militares do quadro
    militares_quadro = []
    if quadro.status in ['ELABORADO', 'HOMOLOGADO']:
        militares_quadro = quadro.itemquadroacesso_set.all().order_by('posicao')
    
    # Buscar documentos pendentes de assinatura
    documentos_pendentes = Documento.objects.filter(
        militar__in=[item.militar for item in militares_quadro],
        status='PENDENTE'
    ).order_by('militar__nome_completo', 'data_upload')
    
    # Criar lista de documentos com informações do militar e posição
    documentos_com_info = []
    militares_sem_documentos = []
    
    for item in militares_quadro:
        documentos_militar = documentos_pendentes.filter(militar=item.militar)
        if documentos_militar.exists():
            for doc in documentos_militar:
                documentos_com_info.append({
                    'documento': doc,
                    'militar': item.militar,
                    'posicao': item.posicao,
                    'item_quadro': item
                })
        else:
            militares_sem_documentos.append(item)
    
    context = {
        'quadro': quadro,
        'militares_quadro': militares_quadro,
        'documentos_pendentes': documentos_pendentes,
        'documentos_com_info': documentos_com_info,
        'militares_sem_documentos': militares_sem_documentos,
        'total_documentos_pendentes': documentos_pendentes.count(),
    }
    
    return render(request, 'militares/assinar_documentos_quadro.html', context)

@login_required
def assinar_documento(request, pk):
    """Assinar documento com confirmação de senha"""
    documento = get_object_or_404(Documento, pk=pk)
    
    # Buscar funções do usuário para seleção
    from militares.models import UsuarioFuncao
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
    
    # Função atual selecionada (da sessão ou primeira disponível)
    funcao_atual = request.session.get('funcao_atual_nome', '')
    if not funcao_atual and funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes_assinatura', '')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'documento': documento,
                'militar': documento.militar,
                'funcoes_usuario': funcoes_usuario,
                'funcao_atual': funcao_atual,
            }
            return render(request, 'militares/assinar_documento.html', context)
        
        # Assinar o documento
        documento.status = 'ASSINADO'
        documento.assinado_por = request.user
        documento.data_assinatura = timezone.now()
        documento.observacoes_assinatura = observacoes
        documento.funcao_assinatura = funcao_assinatura
        documento.save()
        
        messages.success(request, f'Documento "{documento.titulo}" assinado com sucesso!')
        return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
    }
    
    return render(request, 'militares/assinar_documento.html', context)

@login_required
def assinar_quadro_acesso(request, pk):
    """Assinar quadro de acesso com confirmação de senha"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Buscar comissão relacionada ao quadro
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
    else:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
    membros_comissao = comissao.membros.filter(ativo=True).select_related('militar', 'usuario').order_by('tipo', 'militar__nome_completo') if comissao else []
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        membro_id = request.POST.get('membro_id')
        membro = membros_comissao.filter(id=membro_id).first() if membro_id else None
        
        # Verificar senha do usuário selecionado
        if not membro or not membro.usuario or not membro.usuario.check_password(senha):
            messages.error(request, 'Senha incorreta ou membro inválido. Tente novamente.')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Verificar se já existe uma assinatura deste membro para este tipo
        assinatura_existente = AssinaturaQuadroAcesso.objects.filter(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'Este membro já assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Obter função atual do membro
        if membro.cargo:
            funcao_atual = f"{membro.get_tipo_display()} - {membro.cargo.nome}"
        else:
            funcao_atual = membro.get_tipo_display()
        
        # Se não conseguir obter função do membro, tentar buscar função ativa do usuário
        if not funcao_atual or funcao_atual == " - ":
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=membro.usuario,
                status='ATIVO'
            ).first()
            
            if funcao_usuario:
                funcao_atual = funcao_usuario.cargo_funcao.nome
            else:
                funcao_atual = "Usuário do Sistema"
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroAcesso.objects.create(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura,
            funcao_assinatura=funcao_atual
        )
        
        messages.success(request, f'Quadro de acesso assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'membros_comissao': membros_comissao,
    }
    
    return render(request, 'militares/assinar_quadro_acesso.html', context)

@login_required
def retirar_assinatura_quadro_acesso(request, pk, assinatura_pk):
    """Retirar assinatura do quadro de acesso - apenas antes da homologação"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    assinatura = get_object_or_404(AssinaturaQuadroAcesso, pk=assinatura_pk, quadro_acesso=quadro)
    
    # Verificar se o quadro já foi homologado
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Não é possível retirar assinaturas de um quadro já homologado.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    # Verificar se o usuário é o autor da assinatura ou tem permissão administrativa
    if assinatura.assinado_por != request.user and not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'Você só pode retirar suas próprias assinaturas.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_quadro_acesso.html', context)
        
        # Verificar se a assinatura é de aprovação e se há outras assinaturas de aprovação
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = quadro.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se não há outras aprovações, voltar o status do quadro para EM_ELABORACAO
                quadro.status = 'EM_ELABORACAO'
                quadro.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a página de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_quadro_acesso.html', context)

# ============================================================================
# VIEWS DA COMISSÃO DE PROMOÇÃO DE OFICIAIS
# ============================================================================

@login_required
@requer_perm_comissao_visualizar
def comissao_list(request):
    """Lista todas as comissões de promoção de oficiais"""
    # Permissão especial para funções administrativas
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists() or request.user.is_superuser or request.user.is_staff:
        comissoes = ComissaoPromocao.objects.all()
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                comissoes = ComissaoPromocao.objects.all()
            elif tem_cpo:
                comissoes = ComissaoPromocao.objects.filter(tipo='CPO')
            elif tem_cpp:
                comissoes = ComissaoPromocao.objects.filter(tipo='CPP')
            else:
                comissoes = ComissaoPromocao.objects.none()
        else:
            comissoes = ComissaoPromocao.objects.none()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        comissoes = comissoes.filter(status=status)
    
    # Busca
    busca = request.GET.get('busca')
    if busca:
        comissoes = comissoes.filter(
            models.Q(nome__icontains=busca) |
            models.Q(observacoes__icontains=busca)
        )
    
    context = {
        'comissoes': comissoes,
        'status_choices': ComissaoPromocao.STATUS_CHOICES,
    }
    return render(request, 'militares/comissao/list.html', context)

@login_required
@requer_perm_comissao_visualizar
def comissao_detail(request, pk):
    """Detalhes de uma comissão de promoção de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('comissao_list')
    
    # Buscar quadros de acesso relacionados à comissão
    if comissao.tipo == 'CPO':
        # Para comissão de oficiais, buscar quadros de oficiais
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='OFICIAIS'
        ).order_by('-data_promocao')
    else:
        # Para comissão de praças, buscar quadros de praças
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='PRACAS'
        ).order_by('-data_promocao')
    
    # Aplicar slice para mostrar apenas os últimos 10 quadros
    quadros_acesso = quadros_acesso_base[:10]
    
    # Buscar quadros de fixação de vagas relacionados à comissão
    if comissao.tipo == 'CPO':
        # Para comissão de oficiais, buscar quadros de oficiais
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='OFICIAIS'
        ).order_by('-data_promocao')[:10]  # Últimos 10 quadros
    else:
        # Para comissão de praças, buscar quadros de praças
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='PRACAS'
        ).order_by('-data_promocao')[:10]  # Últimos 10 quadros
    
    # Buscar quadros de acesso por merecimento e suas fichas de conceito
    quadros_merecimento = quadros_acesso_base.filter(tipo='MERECIMENTO')
    fichas_conceito_merecimento = {}
    
    for quadro in quadros_merecimento:
        militares_quadro = []
        for item in quadro.itemquadroacesso_set.all().order_by('posicao'):
            militar = item.militar
            # Buscar ficha de conceito do militar
            if comissao.tipo == 'CPO':
                ficha = militar.fichaconceitooficiais_set.first()
            else:
                ficha = militar.fichaconceitopracas_set.first()
            
            if ficha:
                militares_quadro.append({
                    'militar': militar,
                    'ficha': ficha,
                    'posicao': item.posicao,
                    'pontuacao': item.pontuacao
                })
        
        if militares_quadro:
            fichas_conceito_merecimento[quadro] = militares_quadro
    
    # Buscar votos da comissão
    votos_comissao = VotoDeliberacao.objects.filter(
        deliberacao__sessao__comissao=comissao
    ).select_related(
        'deliberacao__sessao',
        'membro__militar'
    ).order_by('-data_registro')[:10]  # Últimos 10 votos
    
    # Calcular estatísticas dos votos
    total_votos = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao).count()
    votos_favor = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='FAVOR').count()
    votos_contra = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='CONTRA').count()
    votos_abstencao = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='ABSTENCAO').count()
    
    context = {
        'comissao': comissao,
        'membros': comissao.membros.all(),
        'sessoes': comissao.sessoes.all()[:5],  # Últimas 5 sessões
        'quadros_acesso': quadros_acesso,
        'quadros_fixacao_vagas': quadros_fixacao_vagas,
        'fichas_conceito_merecimento': fichas_conceito_merecimento,
        'votos_comissao': votos_comissao,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
    }
    return render(request, 'militares/comissao/detail.html', context)

@login_required
@requer_gerenciamento_comissoes
def comissao_create(request):
    """Criar nova comissão de promoção de oficiais"""
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST)
        if form.is_valid():
            nova_comissao = form.save(commit=False)
            # Inativar comissão ativa do mesmo tipo
            comissao_ativa = ComissaoPromocao.objects.filter(tipo=nova_comissao.tipo, status='ATIVA').first()
            if comissao_ativa:
                comissao_ativa.status = 'INATIVA'
                comissao_ativa.save()
            nova_comissao.status = 'ATIVA'
            nova_comissao.save()
            messages.success(request, 'Comissão criada com sucesso!')
            return redirect('militares:comissao_detail', pk=nova_comissao.pk)
    else:
        form = ComissaoPromocaoForm()
    context = {
        'form': form,
        'title': 'Nova Comissão de Promoções',
    }
    return render(request, 'militares/comissao/form.html', context)

@login_required
@requer_perm_comissao_editar
def comissao_update(request, pk):
    """Editar comissão de promoção de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('comissao_list')
    
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST, instance=comissao)
        if form.is_valid():
            form.save()
            messages.success(request, 'Comissão atualizada com sucesso!')
            return redirect('militares:comissao_detail', pk=comissao.pk)
    else:
        form = ComissaoPromocaoForm(instance=comissao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Editar Comissão de Promoção de Oficiais',
    }
    return render(request, 'militares/comissao/form.html', context)

@login_required
@login_required
@requer_perm_comissao_excluir
def comissao_delete(request, pk):
    """Excluir comissão de promoção de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar permissões
    def tem_permissao_exclusao(user):
        # Superusuários e staff sempre podem excluir
        if user.is_superuser or user.is_staff:
            return True
        
        # Verificar se usuário tem função de Diretor de Gestão de Pessoas
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=['Diretor de Gestão de Pessoas', 'Administrador do Sistema', 'Administrador']
        )
        return funcoes_especiais.exists()
    
    if not tem_permissao_exclusao(request.user):
        messages.error(request, 'Você não tem permissão para excluir comissões.')
        return redirect('militares:comissao_list')
    
    # Verificar se a comissão tem sessões
    if comissao.sessoes.exists():
        messages.error(request, 'Não é possível excluir uma comissão que possui sessões. Apenas edição é permitida.')
        return redirect('militares:comissao_detail', pk=pk)
    
    # Verificar se a comissão tem membros
    if comissao.membros.exists():
        messages.error(request, 'Não é possível excluir uma comissão que possui membros. Apenas edição é permitida.')
        return redirect('militares:comissao_detail', pk=pk)
    
    if request.method == 'POST':
        comissao.delete()
        messages.success(request, 'Comissão excluída com sucesso!')
        return redirect('militares:comissao_list')
    
    context = {
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/delete.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_list(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar membros e ordenar por hierarquia
    membros = list(comissao.membros.all())
    
    # Ordenar por tipo primeiro, depois por hierarquia de posto
    membros.sort(key=lambda x: (
        x.tipo,  # Primeiro por tipo (EFETIVO, NATO, SUPLENTE)
        hierarquia_postos.get(x.militar.posto_graduacao, 999),  # Depois por hierarquia
        x.militar.nome_completo  # Por último por nome
    ))
    
    # Calcular contagens para estatísticas usando list comprehension
    membros_ativos_count = sum(1 for membro in membros if membro.ativo)
    membros_com_usuario_count = sum(1 for membro in membros if membro.usuario is not None)
    membros_sem_usuario_count = sum(1 for membro in membros if membro.usuario is None)
    
    context = {
        'comissao': comissao,
        'membros': membros,
        'membros_ativos_count': membros_ativos_count,
        'membros_com_usuario_count': membros_com_usuario_count,
        'membros_sem_usuario_count': membros_sem_usuario_count,
        'title': 'Membros da Comissão',
    }
    return render(request, 'militares/comissao/membros/list.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_add(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar função atual do usuário
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma função selecionada. Selecione uma função primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'Função atual não encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            membro.comissao = comissao
            # Definir o usuário automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # Verificação de duplicidade
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exists()
            if existe:
                messages.error(request, 'Já existe um membro com esse militar e tipo nesta comissão!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })

            try:
                membro.save()
                messages.success(request, 'Membro adicionado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'Já existe um membro com esse militar e tipo nesta comissão!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })
    else:
        form = MembroComissaoForm(comissao_tipo=comissao.tipo)
        
        # Filtrar militares baseado no tipo de comissão
        if comissao.tipo == 'CPO':  # Comissão de Promoção de Oficiais
            # Membros de comissão podem adicionar oficiais
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
                
        elif comissao.tipo == 'CPP':  # Comissão de Promoções de Praças
            # Membros de comissão podem adicionar oficiais (membros da comissão são sempre oficiais)
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
    
    context = {
        'form': form,
        'comissao': comissao,
        'funcao_atual': funcao_atual,
        'title': 'Adicionar Membro',
    }
    return render(request, 'militares/comissao/membros/form.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_update(request, comissao_pk, pk):
    """Editar membro da comissão"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro não encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    # Verificar função atual do usuário
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma função selecionada. Selecione uma função primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'Função atual não encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, instance=membro, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            # Definir o usuário automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # Verificação de duplicidade (excluindo o próprio membro sendo editado)
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exclude(pk=membro.pk).exists()
            if existe:
                messages.error(request, 'Já existe um membro com esse militar e tipo nesta comissão!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da Comissão',
                })

            try:
                membro.save()
                messages.success(request, 'Membro atualizado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'Já existe um membro com esse militar e tipo nesta comissão!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da Comissão',
                })
    else:
        form = MembroComissaoForm(instance=membro, comissao_tipo=comissao.tipo)
        
        # Filtrar militares baseado no tipo de comissão
        if comissao.tipo == 'CPO':  # Comissão de Promoção de Oficiais
            # Membros de comissão podem editar oficiais
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
                
        elif comissao.tipo == 'CPP':  # Comissão de Promoção de Praças
            # Membros de comissão podem editar oficiais (membros da comissão são sempre oficiais)
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
    
    context = {
        'form': form,
        'comissao': comissao,
        'membro': membro,
        'funcao_atual': funcao_atual,
        'title': 'Editar Membro da Comissão',
    }
    return render(request, 'militares/comissao/membros/form.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_delete(request, comissao_pk, pk):
    """Remover membro da comissão"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro não encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    if request.method == 'POST':
        membro.delete()
        messages.success(request, 'Membro removido com sucesso!')
        return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
    
    context = {
        'comissao': comissao,
        'membro': membro,
    }
    return render(request, 'militares/comissao/membros/delete.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_list(request):
    """Lista sessões de uma comissão"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'Comissão não especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    
    sessoes = comissao.sessoes.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        sessoes = sessoes.filter(status=status)
    
    tipo = request.GET.get('tipo')
    if tipo:
        sessoes = sessoes.filter(tipo=tipo)
    
    context = {
        'comissao': comissao,
        'sessoes': sessoes,
        'status_choices': SessaoComissao.STATUS_CHOICES,
        'tipo_choices': SessaoComissao.TIPO_CHOICES,
    }
    return render(request, 'militares/comissao/sessoes/list.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_detail(request, pk):
    """Detalhes de uma sessão"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuário é membro da comissão
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    # Função para normalizar texto
    def normalizar(texto):
        if not texto:
            return ''
        return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII').upper()
    
    # Verificar se a pauta é sobre aprovação de quadro de acesso (singular/plural, ignorando acentos e case)
    pauta_aprovacao_quadro = False
    quadros_acesso_sessao = []
    pauta_normalizada = normalizar(sessao.pauta)
    if (
        'APROVACAO DE QUADRO DE ACESSO' in pauta_normalizada or
        'APROVACAO DE QUADROS DE ACESSO' in pauta_normalizada or
        'APROVACAO DE QUADROS DE ACESSOS' in pauta_normalizada
    ):
        pauta_aprovacao_quadro = True
        # Buscar quadros de acesso da comissão específica
        if comissao.tipo == 'CPO':
            quadros_acesso_sessao = QuadroAcesso.objects.filter(
                categoria='OFICIAIS',
                status__in=['ELABORADO', 'HOMOLOGADO', 'ASSINADO']
            ).order_by('-data_promocao')
        else:
            quadros_acesso_sessao = QuadroAcesso.objects.filter(
                categoria='PRACAS',
                status__in=['ELABORADO', 'HOMOLOGADO', 'ASSINADO']
            ).order_by('-data_promocao')
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all(),
        'user_membro': user_membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'votos_sessao': VotoDeliberacao.objects.filter(deliberacao__sessao=sessao).select_related('membro__militar', 'deliberacao').order_by('deliberacao__numero', 'membro__militar__nome_completo'),
        'pauta_aprovacao_quadro': pauta_aprovacao_quadro,
        'quadros_acesso_sessao': quadros_acesso_sessao,
    }
    return render(request, 'militares/comissao/sessoes/detail.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_create(request):
    """Criar nova sessão"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'Comissão não especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES)
        if form.is_valid():
            sessao = form.save(commit=False)
            sessao.comissao = comissao
            sessao.save()
            
            # Criar registros de presença para todos os membros
            for membro in comissao.membros.filter(ativo=True):
                PresencaSessao.objects.create(
                    sessao=sessao,
                    membro=membro,
                    presente=False
                )
            
            # Criar documento se fornecido
            documento_titulo = form.cleaned_data.get('documento_titulo')
            documento_tipo = form.cleaned_data.get('documento_tipo')
            documento_arquivo = form.cleaned_data.get('documento_arquivo')
            documento_descricao = form.cleaned_data.get('documento_descricao')
            
            if documento_titulo and documento_tipo and documento_arquivo:
                documento = DocumentoSessao.objects.create(
                    sessao=sessao,
                    tipo=documento_tipo,
                    titulo=documento_titulo,
                    descricao=documento_descricao,
                    arquivo=documento_arquivo,
                    upload_por=request.user
                )
                messages.success(request, f'Sessão criada com sucesso! Documento "{documento.titulo}" anexado.')
            else:
                messages.success(request, 'Sessão criada com sucesso!')
            
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = SessaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Nova Sessão da Comissão',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_update(request, pk):
    """Editar sessão"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES, instance=sessao)
        if form.is_valid():
            try:
                # Salvar a sessão
                sessao_atualizada = form.save()
                
                # Processar documento se fornecido
                documento_titulo = form.cleaned_data.get('documento_titulo')
                documento_tipo = form.cleaned_data.get('documento_tipo')
                documento_arquivo = form.cleaned_data.get('documento_arquivo')
                documento_descricao = form.cleaned_data.get('documento_descricao')
                
                if documento_titulo and documento_tipo and documento_arquivo:
                    # Criar ou atualizar documento da sessão
                    documento_sessao, created = DocumentoSessao.objects.get_or_create(
                        sessao=sessao_atualizada,
                        defaults={
                            'tipo': documento_tipo,
                            'titulo': documento_titulo,
                            'descricao': documento_descricao or '',
                            'arquivo': documento_arquivo,
                            'upload_por': request.user,
                        }
                    )
                    
                    if not created:
                        # Atualizar documento existente
                        documento_sessao.tipo = documento_tipo
                        documento_sessao.titulo = documento_titulo
                        documento_sessao.descricao = documento_descricao or ''
                        documento_sessao.arquivo = documento_arquivo
                        documento_sessao.save()
                
                messages.success(request, 'Sessão atualizada com sucesso!')
                return redirect('militares:sessao_comissao_detail', pk=sessao_atualizada.pk)
            except Exception as e:
                messages.error(request, f'Erro ao salvar sessão: {str(e)}')
        else:
            # Log dos erros de validação para debug
            print("Erros de validação do formulário:")
            for field, errors in form.errors.items():
                print(f"Campo {field}: {errors}")
            
            # Criar mensagem de erro mais específica
            error_messages = []
            for field, errors in form.errors.items():
                field_name = form.fields[field].label if field in form.fields else field
                for error in errors:
                    error_messages.append(f"{field_name}: {error}")
            
            if error_messages:
                messages.error(request, f'Erro ao atualizar sessão: {"; ".join(error_messages)}')
            else:
                messages.error(request, 'Erro ao atualizar sessão. Verifique os dados informados.')
    else:
        form = SessaoComissaoForm(instance=sessao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Editar Sessão da Comissão',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)

@login_required
def presenca_sessao_update(request, sessao_pk):
    """Atualizar presenças de uma sessão"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        # Obter todos os membros da comissão
        membros = comissao.membros.all()
        
        for membro in membros:
            # Verificar se o membro está presente
            presente = request.POST.get(f'presenca_{membro.pk}') == '1'
            
            # Obter ou criar presença
            presenca, created = PresencaSessao.objects.get_or_create(
                sessao=sessao,
                membro=membro,
                defaults={'presente': presente}
            )
            
            # Atualizar presença
            presenca.presente = presente
            presenca.save()
            
            # Debug: imprimir informações
            print(f"Membro: {membro.militar.nome_completo}, Presente: {presente}, POST data: {request.POST.get(f'presenca_{membro.pk}')}")
        
        # Debug: imprimir todos os dados POST
        print("POST data:", request.POST)
        print("Total de presenças salvas:", sessao.presencas.filter(presente=True).count())
        
        messages.success(request, 'Presenças atualizadas com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Obter membros da comissão
    membros = comissao.membros.all()
    
    # Obter presenças existentes
    presencas_existentes = set(sessao.presencas.filter(presente=True).values_list('membro_id', flat=True))
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'membros': membros,
        'presencas_existentes': presencas_existentes,
    }
    return render(request, 'militares/comissao/sessoes/presenca_form.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_create(request):
    """Criar nova deliberação"""
    sessao_pk = request.GET.get('sessao')
    resultado = request.GET.get('resultado')
    
    if not sessao_pk:
        messages.error(request, 'Sessão não especificada.')
        return redirect('militares:comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Se o parâmetro resultado estiver presente, redirecionar para a página de resultados
    if resultado:
        return redirect('militares:deliberacao_comissao_resultado', sessao_pk=sessao.pk)
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST)
        if form.is_valid():
            deliberacao = form.save(commit=False)
            deliberacao.sessao = sessao
            deliberacao.save()
            
            messages.success(request, 'Deliberação criada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Nova Deliberação',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_update(request, pk):
    """Editar deliberação"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'Deliberação não encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST, instance=deliberacao)
        if form.is_valid():
            form.save()
            messages.success(request, 'Deliberação atualizada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm(instance=deliberacao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'title': 'Editar Deliberação',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)

@login_required
@comissao_acesso_total
def voto_deliberacao_create(request, deliberacao_pk):
    """Registrar voto do usuário logado em uma deliberação"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=deliberacao_pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'Deliberação não encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuário logado é membro da comissão
    membro_usuario = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    if not membro_usuario:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se o membro estava presente na sessão
    presenca = sessao.presencas.filter(membro=membro_usuario, presente=True).first()
    if not presenca:
        messages.error(request, 'Você não estava presente nesta sessão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se já votou
    voto_existente = deliberacao.votos.filter(membro=membro_usuario).first()
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha é obrigatória para confirmar o voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Validar senha do usuário
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Obter dados do voto
        voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        
        if not voto:
            messages.error(request, 'Você deve escolher uma opção de voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Criar ou atualizar voto
        if voto_existente:
            voto_existente.voto = voto
            voto_existente.voto_proferido = voto_proferido
            voto_existente.save()
        else:
            voto_existente = VotoDeliberacao.objects.create(
                deliberacao=deliberacao,
                membro=membro_usuario,
                voto=voto,
                voto_proferido=voto_proferido
            )
        
        # Atualizar contadores da deliberação
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        if voto_existente:
            messages.success(request, f'✅ Voto atualizado com sucesso!')
        else:
            messages.success(request, f'✅ Voto registrado com sucesso!')
        
        # Redirecionar de volta para o formulário de voto para mostrar os dados atualizados
        return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
    
    # Criar formulário para o voto proferido com CKEditor
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que você proferiu durante a sessão...',
                    'class': 'ckeditor5',
                    'data-config-name': 'voto_proferido_config'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto_existente.voto_proferido if voto_existente else ''
    })
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'membro_usuario': membro_usuario,
        'voto_existente': voto_existente,
        'form': form,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)

@login_required
def voto_deliberacao_editor_popup(request, deliberacao_pk):
    """Editor de voto em modal/popup similar ao editor de atas"""
    deliberacao = get_object_or_404(DeliberacaoComissao, pk=deliberacao_pk)
    sessao = deliberacao.sessao
    comissao = sessao.comissao
    
    # Verificar se o usuário é membro da comissão
    membro_usuario = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    if not membro_usuario:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    
    # Verificar se já existe um voto para este membro
    voto_existente = VotoDeliberacao.objects.filter(
        deliberacao=deliberacao,
        membro=membro_usuario
    ).first()
    
    if request.method == 'POST':
        # Processar dados do formulário
        voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        senha_votante = request.POST.get('senha_votante')
        
        # Validações
        if not senha_votante:
            return JsonResponse({'success': False, 'error': 'Senha é obrigatória para confirmar o voto.'})
        
        if not request.user.check_password(senha_votante):
            return JsonResponse({'success': False, 'error': 'Senha incorreta. Tente novamente.'})
        
        if not voto:
            return JsonResponse({'success': False, 'error': 'Você deve escolher uma opção de voto.'})
        
        # Criar ou atualizar voto
        if voto_existente:
            voto_existente.voto = voto
            voto_existente.voto_proferido = voto_proferido
            voto_existente.save()
        else:
            voto_existente = VotoDeliberacao.objects.create(
                deliberacao=deliberacao,
                membro=membro_usuario,
                voto=voto,
                voto_proferido=voto_proferido
            )
        
        # Atualizar contadores da deliberação
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        return JsonResponse({
            'success': True, 
            'message': 'Voto salvo com sucesso!',
            'voto_id': voto_existente.pk,
            'redirect_url': f'/militares/meus-votos/{voto_existente.pk}/visualizar/'
        })
    
    # Preparar dados para o template
    context = {
        'deliberacao': deliberacao,
        'sessao': sessao,
        'comissao': comissao,
        'membro_usuario': membro_usuario,
        'voto_existente': voto_existente,
    }
    
    return render(request, 'militares/comissao/deliberacoes/voto_editor_popup.html', context)

@login_required
def comissao_pdf(request, pk):
    """Gerar PDF da comissão de promoção de oficiais"""
    from reportlab.platypus import SimpleDocTemplate, Image, Spacer, Paragraph
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('comissao_list')
    
    # Criar o PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="comissao_promocao_{pk}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    
    story = []
    
    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))
    
    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        f"{comissao.get_tipo_display().upper()} - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Informações da comissão
    story.append(Paragraph(f"<b>Nome:</b> {comissao.nome}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Data de Criação:</b> {comissao.data_criacao.strftime('%d/%m/%Y')}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Status:</b> {comissao.get_status_display()}", style_bold))
    story.append(Spacer(1, 6))
    
    if comissao.data_termino:
        story.append(Paragraph(f"<b>Data de Término:</b> {comissao.data_termino.strftime('%d/%m/%Y')}", style_bold))
        story.append(Spacer(1, 6))
    
    story.append(Spacer(1, 12))
    
    # Obter todos os membros ativos ordenados por tipo (presidente, membros, secretário)
    membros_ativos = comissao.membros.filter(ativo=True).order_by(
        'tipo'  # PRESIDENTE, EFETIVO, NATO, SECRETARIO
    )
    
    # Presidente
    presidente = membros_ativos.filter(tipo='PRESIDENTE').first()
    if presidente:
        story.append(Paragraph("<b>PRESIDENTE:</b>", style_bold))
        story.append(Paragraph(f"{presidente.militar.get_posto_graduacao_display()} {presidente.militar.get_quadro_display()} {presidente.militar.nome_completo} - {presidente.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Natos
    membros_natos = membros_ativos.filter(tipo='NATO')
    if membros_natos:
        story.append(Paragraph("<b>MEMBROS NATOS:</b>", style_bold))
        for membro in membros_natos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Efetivos
    membros_efetivos = membros_ativos.filter(tipo='EFETIVO')
    if membros_efetivos:
        story.append(Paragraph("<b>MEMBROS EFETIVOS:</b>", style_bold))
        for membro in membros_efetivos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Secretário
    secretario = membros_ativos.filter(tipo='SECRETARIO').first()
    if secretario:
        story.append(Paragraph("<b>SECRETÁRIO:</b>", style_bold))
        story.append(Paragraph(f"{secretario.militar.get_posto_graduacao_display()} {secretario.militar.get_quadro_display()} {secretario.militar.nome_completo} - {secretario.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Observações
    if comissao.observacoes:
        story.append(Spacer(1, 12))
        story.append(Paragraph("<b>OBSERVAÇÕES:</b>", style_bold))
        story.append(Paragraph(comissao.observacoes, style_center))
    
    # Gerar o PDF
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    
    response.write(pdf)
    return response

@login_required
def comissao_encerrar(request, pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'Comissão não encontrada.')
        return redirect('militares:comissao_list')
    if comissao.status == 'INATIVA':
        messages.info(request, 'Esta comissão já está inativa.')
    else:
        comissao.status = 'INATIVA'
        comissao.save()
        messages.success(request, 'Comissão encerrada com sucesso!')
    return redirect('militares:comissao_list')

@login_required
def documento_sessao_create(request):
    """Upload de documento para uma sessão"""
    sessao_pk = request.GET.get('sessao')
    if not sessao_pk:
        messages.error(request, 'Sessão não especificada.')
        return redirect('militares:sessao_comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:sessao_comissao_list')
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.sessao = sessao
            documento.upload_por = request.user
            documento.save()
            messages.success(request, f'Documento "{documento.titulo}" enviado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm()
    
    context = {
        'form': form,
        'sessao': sessao,
        'title': 'Enviar Documento',
        'action': 'create',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)

@login_required
def documento_sessao_update(request, pk):
    """Editar documento da sessão"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES, instance=documento)
        if form.is_valid():
            form.save()
            messages.success(request, f'Documento "{documento.titulo}" atualizado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
        else:
            messages.error(request, 'Erro ao atualizar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm(instance=documento)
    
    context = {
        'form': form,
        'documento': documento,
        'sessao': documento.sessao,
        'title': 'Editar Documento',
        'action': 'update',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)

@login_required
def documento_sessao_delete(request, pk):
    """Excluir documento da sessão (apenas admin/staff)"""
    if not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'Você não tem permissão para excluir documentos. Apenas administradores podem realizar esta ação.')
        documento = get_object_or_404(DocumentoSessao, pk=pk)
        return render(request, 'militares/comissao/documentos/delete.html', {'sessao': documento.sessao, 'documento': documento})
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    sessao_pk = documento.sessao.pk
    titulo = documento.titulo
    
    if request.method == 'POST':
        documento.delete()
        messages.success(request, f'Documento "{titulo}" excluído com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao_pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    return render(request, 'militares/comissao/documentos/delete.html', context)

@login_required
def documento_sessao_view(request, pk):
    """Visualizar documento da sessão"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    try:
        membro = MembroComissao.objects.get(
            comissao=documento.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        # Verificar se o usuário é membro mas não está ativo
        try:
            membro_inativo = MembroComissao.objects.get(
                comissao=documento.sessao.comissao,
                usuario=request.user
            )
            messages.error(request, 'Você não tem permissão para visualizar este documento. Seu cadastro na comissão não está ativo.')
        except MembroComissao.DoesNotExist:
            messages.error(request, 'Você não tem permissão para visualizar este documento. Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    
    if documento.can_preview():
        return render(request, 'militares/comissao/documentos/view.html', context)
    else:
        # Para arquivos que não podem ser visualizados, fazer download
        import os
        if os.path.exists(documento.arquivo.path):
            return FileResponse(open(documento.arquivo.path, 'rb'), content_type='application/octet-stream')
        else:
            messages.error(request, 'Arquivo não encontrado.')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)

@login_required
def documento_sessao_download(request, pk):
    """Download de documento da sessão"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=documento.sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        # Verificar se o usuário é membro mas não está ativo
        membro_inativo = MembroComissao.objects.filter(
            comissao=documento.sessao.comissao,
            usuario=request.user
        ).first()
        if membro_inativo:
            messages.error(request, 'Você não tem permissão para baixar este documento. Seu cadastro na comissão não está ativo.')
        else:
            messages.error(request, 'Você não tem permissão para baixar este documento. Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    import os
    if os.path.exists(documento.arquivo.path):
        response = FileResponse(open(documento.arquivo.path, 'rb'))
        response['Content-Disposition'] = f'attachment; filename="{documento.filename()}"'
        return response
    else:
        messages.error(request, 'Arquivo não encontrado.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)

@login_required
def sessao_encerrar(request, pk):
    """Encerrar sessão com confirmação de senha"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se todos os presentes (exceto presidente) votaram
    todos_votaram = sessao.todos_presentes_votaram_exceto_presidente
    
    # Se não todos votaram, apenas o secretário pode encerrar
    if not todos_votaram and membro.cargo != 'SECRETARIO':
        messages.error(request, 'Apenas o secretário pode encerrar a sessão quando nem todos os membros votaram.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar membros presentes que não votaram (excluindo o presidente)
    membros_sem_voto = []
    for presenca in sessao.presencas.filter(presente=True):
        membro_presenca = presenca.membro
        # O presidente não é obrigado a votar
        if membro_presenca.cargo == 'PRESIDENTE':
            continue
            
        votos_do_membro = VotoDeliberacao.objects.filter(
            deliberacao__sessao=sessao,
            membro=membro_presenca
        ).count()
        if votos_do_membro < sessao.deliberacoes.count():
            membros_sem_voto.append({
                'membro': membro_presenca,
                'votos_realizados': votos_do_membro,
                'total_deliberacoes': sessao.deliberacoes.count(),
                'deliberacoes_nao_votadas': sessao.deliberacoes.count() - votos_do_membro
            })
    
    if request.method == 'POST':
        password = request.POST.get('password')
        if not password:
            messages.error(request, 'Senha é obrigatória para encerrar a sessão.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        if not request.user.check_password(password):
            messages.error(request, 'Senha incorreta. Sessão não foi encerrada.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        # Coletar justificativas para membros sem voto (apenas se secretário e nem todos votaram)
        justificativas = {}
        if membro.cargo == 'SECRETARIO' and membros_sem_voto:
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                justificativa = request.POST.get(f'justificativa_{membro_id}', '').strip()
                if justificativa:
                    justificativas[membro_id] = justificativa
        
        # Encerrar a sessão
        sessao.status = 'CONCLUIDA'
        sessao.hora_fim = timezone.now().time()
        sessao.save()
        
        # Salvar justificativas se houver
        if justificativas:
            
            justificativas_salvas = []
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                if membro_id in justificativas:
                    # Salvar justificativa no modelo
                    justificativa_obj, created = JustificativaEncerramento.objects.get_or_create(
                        sessao=sessao,
                        membro=membro_info['membro'],
                        defaults={
                            'justificativa': justificativas[membro_id],
                            'registrado_por': request.user
                        }
                    )
                    
                    if not created:
                        # Atualizar justificativa existente
                        justificativa_obj.justificativa = justificativas[membro_id]
                        justificativa_obj.registrado_por = request.user
                        justificativa_obj.save()
                    
                    justificativas_salvas.append(
                        f"{membro_info['membro'].militar.nome_completo}: {justificativas[membro_id]}"
                    )
            
            if justificativas_salvas:
                messages.success(request, f'Sessão {sessao.numero} encerrada com sucesso! {len(justificativas_salvas)} justificativa(s) registrada(s).')
        else:
            messages.success(request, f'Sessão {sessao.numero} encerrada com sucesso!')
        
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Buscar votos da sessão para o modal de seleção
    votos_sessao = VotoDeliberacao.objects.filter(
        deliberacao__sessao=sessao
    ).select_related('membro__militar', 'membro__cargo', 'deliberacao').order_by('deliberacao__numero', 'membro__militar__nome_completo')
    
    return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'membros_sem_voto': membros_sem_voto,
        'todos_votaram': todos_votaram,
        'membro_usuario': membro,
        'votos_sessao': votos_sessao
    })

@login_required
def sessao_gerar_ata(request, pk):
    """Gerar ata da sessão da comissão"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se existe uma ata editada
    try:
        ata_editada = sessao.ata_editada
        tem_conteudo_editado = ata_editada and ata_editada.conteudo
    except:
        ata_editada = None
        tem_conteudo_editado = False
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
        'ata_editada': ata_editada,
        'tem_conteudo_editado': tem_conteudo_editado,
    }
    
    # Adicionar dados para assinaturas (se houver ata editada)
    if ata_editada:
        # Buscar funções do usuário para o modal de assinatura
        from militares.models import UsuarioFuncao
        funcoes_usuario = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO'
        ).order_by('cargo_funcao__nome')
        
        context.update({
            'funcoes_usuario': funcoes_usuario,
            'funcao_atual': request.session.get('funcao_atual_nome', 'Usuário do Sistema'),
        })
    
    return render(request, 'militares/comissao/sessoes/ata.html', context)

@login_required
def sessao_editar_ata(request, pk):
    """Editar ata da sessão com editor de texto rico"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    # Se for uma requisição AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if request.method == 'POST':
            print(f"DEBUG: Recebendo POST AJAX - dados: {request.POST}")
            form = AtaSessaoForm(request.POST, instance=ata)
            print(f"DEBUG: Form válido: {form.is_valid()}")
            if form.is_valid():
                ata = form.save(commit=False)
                ata.editado_por = request.user
                # Limpar assinaturas eletrônicas ao editar a ata
                ata.assinaturas.all().delete()
                ata.save()
                print(f"DEBUG: Ata salva com sucesso - versão: {ata.versao}")
                return JsonResponse({
                    'success': True,
                    'message': f'Ata salva com sucesso! Versão {ata.versao}. As assinaturas eletrônicas foram removidas.',
                    'versao': ata.versao
                })
            else:
                print(f"DEBUG: Erros no formulário: {form.errors}")
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                })
        else:
            return JsonResponse({
                'success': False,
                'errors': {'__all__': ['Método não permitido']}
            })
    
    # Processamento normal (não-AJAX)
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            # Limpar assinaturas eletrônicas ao editar a ata
            ata.assinaturas.all().delete()
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! Versão {ata.versao}. As assinaturas eletrônicas foram removidas e será necessário assinar novamente.')
            return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    return render(request, 'militares/comissao/sessoes/editar_ata.html', context)

@login_required
def ata_conteudo_ajax(request, pk):
    """Retornar conteúdo da ata via AJAX"""
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
        
        # Verificar se o usuário é membro da comissão
        membro = MembroComissao.objects.filter(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'Você não é membro desta comissão.'
            })
        
        return JsonResponse({
            'success': True,
            'conteudo': ata.conteudo or '',
            'sessao_numero': ata.sessao.numero,
            'data_sessao': ata.sessao.data_sessao.strftime('%d/%m/%Y'),
            'hora_sessao': ata.sessao.hora_inicio.strftime('%H:%M'),
            'local_sessao': ata.sessao.local,
            'versao': ata.versao,
            'editado_por': ata.editado_por.get_full_name() or ata.editado_por.username,
            'data_edicao': ata.data_edicao.strftime('%d/%m/%Y %H:%M')
        })
        
    except AtaSessao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Ata não encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao carregar ata: {str(e)}'
        })

@login_required
def sessao_editar_ata_popup(request, pk):
    """Editar ata da sessão em página separada/popup"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! Versão {ata.versao}.')
            return redirect('militares:sessao_editar_ata_popup', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    # Se for uma requisição AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.assinaturas.all().delete()
            ata.save()
            return JsonResponse({
                'success': True,
                'message': f'Ata salva com sucesso! Versão {ata.versao}.',
                'versao': ata.versao
            })
        else:
            return JsonResponse({
                'success': False,
                'errors': form.errors
            })
    
    return render(request, 'militares/comissao/sessoes/editar_ata_popup.html', context)

@login_required
def ata_para_assinatura(request, pk):
    """Marcar ata para assinatura dos membros"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuário é membro da comissão
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        ata.status = 'PARA_ASSINATURA'
        ata.save()
        messages.success(request, 'Ata marcada para assinatura dos membros.')
        return redirect('militares:ata_assinaturas', pk=pk)
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': ata.sessao.presencas.filter(presente=True),
    }
    return render(request, 'militares/comissao/sessoes/ata_para_assinatura.html', context)

@login_required
def ata_assinaturas(request, pk):
    """Gerenciar assinaturas da ata"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuário é membro da comissão
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        # Processar assinatura
        membro_id = request.POST.get('membro_id')
        observacoes = request.POST.get('observacoes', '').strip()
        
        if membro_id:
            try:
                membro_para_assinar = MembroComissao.objects.get(id=membro_id)
                # Verificar se o membro estava presente
                if not ata.sessao.presencas.filter(membro=membro_para_assinar, presente=True).exists():
                    messages.error(request, 'Apenas membros presentes podem assinar a ata.')
                    return redirect('militares:ata_assinaturas', pk=pk)
                
                # Criar ou atualizar assinatura
                assinatura, created = AssinaturaAta.objects.get_or_create(
                    ata=ata,
                    membro=membro_para_assinar,
                    defaults={
                        'assinado_por': request.user,
                        'observacoes': observacoes
                    }
                )
                
                if not created:
                    assinatura.assinado_por = request.user
                    assinatura.observacoes = observacoes
                    assinatura.save()
                
                messages.success(request, f'Assinatura de {membro_para_assinar.militar.nome_completo} registrada com sucesso!')
                
                # Verificar se todos assinaram
                if ata.pode_ser_finalizada():
                    ata.status = 'ASSINADA'
                    ata.save()
                    messages.info(request, 'Todos os membros presentes assinaram a ata!')
                
            except MembroComissao.DoesNotExist:
                messages.error(request, 'Membro não encontrado.')
    
    # Obter membros presentes e suas assinaturas
    membros_presentes = ata.sessao.presencas.filter(presente=True).select_related('membro__militar')
    assinaturas = ata.assinaturas.select_related('membro__militar', 'assinado_por')
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': membros_presentes,
        'assinaturas': assinaturas,
        'membro_usuario': membro,
    }
    return render(request, 'militares/comissao/sessoes/ata_assinaturas.html', context)

@login_required
def ata_gerar_pdf(request, pk):
    """Gerar PDF da ata finalizada"""
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_JUSTIFY
    from io import BytesIO
    import html2text
    import os
    import qrcode
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Permitir gerar PDF para qualquer status da ata
    # if ata.status != 'ASSINADA' and ata.status != 'FINALIZADA':
    #     messages.error(request, 'A ata deve estar assinada para gerar o PDF.')
    #     return redirect('militares:ata_assinaturas', pk=pk)
    
    # Criar o PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Configurar fonte para suportar caracteres especiais
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    
    # Registrar fonte que suporta UTF-8 (usando fonte padrão do sistema)
    try:
        # Tentar usar fonte Arial que suporta caracteres especiais
        pdfmetrics.registerFont(TTFont('Arial', 'arial.ttf'))
        font_name = 'Arial'
    except:
        # Se não conseguir, usar fonte padrão
        font_name = 'Helvetica'
    
    # Estilos customizados com fonte que suporta UTF-8
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11, fontName=font_name)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName=font_name, fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1, fontName=font_name)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8, fontName=font_name)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9, fontName=font_name)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11, spaceAfter=8, fontName=font_name)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6, fontName=font_name)
    
    # Estilos para cabeçalho institucional (padrão do sistema)
    style_header = ParagraphStyle('header', parent=styles['Heading1'], fontSize=12, alignment=1, spaceAfter=8, spaceBefore=12, fontName=font_name)
    style_subheader = ParagraphStyle('subheader', parent=styles['Heading2'], fontSize=11, alignment=1, spaceAfter=6, spaceBefore=10, fontName=font_name)
    
    # Novos estilos para formatação avançada
    style_heading1 = ParagraphStyle('heading1', parent=styles['Heading1'], fontSize=12, spaceAfter=8, spaceBefore=12, fontName=font_name)
    style_heading2 = ParagraphStyle('heading2', parent=styles['Heading2'], fontSize=11, spaceAfter=6, spaceBefore=10, fontName=font_name)
    style_heading3 = ParagraphStyle('heading3', parent=styles['Heading3'], fontSize=10, spaceAfter=4, spaceBefore=8, fontName=font_name)
    style_paragraph = ParagraphStyle('paragraph', parent=styles['Normal'], fontSize=10, spaceAfter=6, alignment=4, firstLineIndent=20, fontName=font_name)
    style_list_item = ParagraphStyle('list_item', parent=styles['Normal'], fontSize=10, spaceAfter=4, leftIndent=20, firstLineIndent=-10, fontName=font_name)
    style_quote = ParagraphStyle('quote', parent=styles['Normal'], fontSize=10, spaceAfter=6, leftIndent=30, rightIndent=30, fontName=font_name)
    
    story = []
    
    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional (igual aos quadros)
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
    ]
    
    # Determinar o tipo de comissão baseado no campo tipo
    if ata.sessao.comissao.tipo == 'CPO':
        tipo_comissao = "COMISSÃO DE PROMOÇÕES DE OFICIAIS - CBMEPI-PI"
    else:
        tipo_comissao = "COMISSÃO DE PROMOÇÕES DE PRAÇAS - CBMEPI-PI"
    
    cabecalho.extend([
        tipo_comissao,
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ])
    
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))
    
    # Título centralizado e sublinhado (mesma visualização do HTML)
    if ata.sessao.comissao.tipo == 'CPO':
        tipo_comissao = "ATA DA REUNIÃO DA COMISSÃO DE PROMOÇÃO DE OFICIAIS DO CBMEPI"
    elif ata.sessao.comissao.tipo == 'CPP':
        tipo_comissao = "ATA DA REUNIÃO DA COMISSÃO DE PROMOÇÃO DE PRAÇAS DO CBMEPI"
    else:
        tipo_comissao = "ATA DA REUNIÃO DA COMISSÃO DE PROMOÇÃO DO CBMEPI"
    
    titulo = f'<u>{tipo_comissao}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 56.7))  # 2cm de espaçamento após o título
    
    # Conteúdo da ata (mantendo HTML do CKEditor, mas limpo para ReportLab)
    style_html = ParagraphStyle('html', parent=styles['Normal'], fontSize=11, alignment=TA_JUSTIFY, spaceAfter=8, leading=16, fontName=font_name)
    conteudo_limpo = clean_html_for_reportlab(ata.conteudo)
    
    try:
        story.append(Paragraph(conteudo_limpo, style_html))
    except Exception as e:
        # Se houver erro no parsing do HTML, tentar com texto simples
        print(f"Erro ao processar HTML da ata: {str(e)}")
        # Remover todas as tags HTML e usar apenas texto
        import re
        texto_simples = re.sub(r'<[^>]+>', '', ata.conteudo or '')
        texto_simples = unescape(texto_simples)
        story.append(Paragraph(texto_simples, style_html))
    story.append(Spacer(1, 20))
    
    # Data da sessão centralizada após o conteúdo (sistema automático)
    if ata.sessao.data_sessao:
        # Converter data para extenso
        from datetime import datetime
        data_sessao = ata.sessao.data_sessao
        
        # Mapeamento de meses
        meses = {
            1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril',
            5: 'maio', 6: 'junho', 7: 'julho', 8: 'agosto',
            9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
        }
        
        dia = data_sessao.day
        mes = meses[data_sessao.month]
        ano = data_sessao.year
        
        # Formatar data por extenso
        data_extenso = f"Teresina, {dia} de {mes} de {ano}"
        story.append(Paragraph(f"<center><b>{data_extenso}</b></center>", style_center))
    story.append(Spacer(1, 30))
    
    # Assinaturas manuais
    story.append(Spacer(1, 15))
    
    assinaturas = ata.assinaturas.select_related('membro__militar').order_by('data_assinatura')
    for assinatura in assinaturas:
        # Função para obter a abreviação correta do quadro
        def get_quadro_abreviado(quadro):
            if quadro == 'Complementar':
                return 'QOBM/C'
            elif quadro == 'Combatente':
                return 'QOBM/Comb.'
            elif quadro == 'Engenheiro':
                return 'QOBM/E'
            elif quadro == 'Saúde':
                return 'QOBM/S'
            else:
                return quadro
        
        # Nome, posto e quadro na mesma linha
        quadro_abreviado = get_quadro_abreviado(assinatura.membro.militar.get_quadro_display())
        nome_posto_quadro = f"{assinatura.membro.militar.nome_completo} - {assinatura.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
        story.append(Paragraph(f"<center>{nome_posto_quadro}</center>", style_center))
        
        # Tipo de membro e função
        tipo_membro = assinatura.membro.get_tipo_display()
        cargo_membro = assinatura.membro.cargo.nome if assinatura.membro.cargo else ""
        if cargo_membro:
            story.append(Paragraph(f"<center>{tipo_membro} - {cargo_membro}</center>", style_center))
        else:
            story.append(Paragraph(f"<center>{tipo_membro}</center>", style_center))
        
        if assinatura.observacoes:
            story.append(Paragraph(f"Obs: {assinatura.observacoes}", style_signature))
        story.append(Spacer(1, 10))
    
    # Rodapé com Assinaturas Eletrônicas e QR Code
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas válidas da ata (da mais recente para a mais antiga)
    assinaturas_eletronicas = ata.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas_eletronicas.exists():
        for i, assinatura_eletronica in enumerate(assinaturas_eletronicas):
            # Informações de assinatura eletrônica
            nome_assinante = assinatura_eletronica.assinado_por.get_full_name() or assinatura_eletronica.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrão
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "Usuário do Sistema"
            
            from .utils import formatar_data_assinatura
            data_formatada, hora_formatada = formatar_data_assinatura(assinatura_eletronica.data_assinatura)
            
            # Função para obter a abreviação correta do quadro
            def get_quadro_abreviado(quadro):
                if quadro == 'Complementar':
                    return 'QOBM/C'
                elif quadro == 'Combatente':
                    return 'QOBM/Comb.'
                elif quadro == 'Engenheiro':
                    return 'QOBM/E'
                elif quadro == 'Saúde':
                    return 'QOBM/S'
                else:
                    return quadro
            
            # Nome, posto e quadro do militar
            quadro_abreviado = get_quadro_abreviado(assinatura_eletronica.membro.militar.get_quadro_display())
            nome_posto_quadro = f"{assinatura_eletronica.membro.militar.nome_completo} - {assinatura_eletronica.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
            
            # Obter a função da assinatura (que foi capturada durante a assinatura)
            funcao_atual = assinatura_eletronica.funcao_assinatura or 'Usuário do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_posto_quadro} - {funcao_atual}, em {data_formatada}, às {hora_formatada}, conforme horário oficial de Brasília, conforme portaria comando geral nº59/2020 publicada em boletim geral nº26/2020"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na última)
            if i < len(assinaturas_eletronicas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se não houver assinaturas eletrônicas, mostrar apenas documento gerado pelo usuário logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "Usuário do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuário {nome_usuario} em {data_formatada}, às {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a função utilitária para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(ata, request, tipo_documento='ata')
    
    # Tabela do rodapé: QR + Texto de autenticação
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Gerar PDF
    doc.build(story)
    buffer.seek(0)
    
    # Criar resposta HTTP
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="ata_sessao_{ata.sessao.numero}.pdf"'
    
    return response

@login_required
def ata_finalizar(request, pk):
    """Finalizar ata após todas as assinaturas"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuário é membro da comissão
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        if ata.pode_ser_finalizada():
            ata.status = 'FINALIZADA'
            ata.data_finalizacao = timezone.now()
            ata.save()
            messages.success(request, 'Ata finalizada com sucesso! Agora você pode gerar o PDF.')
        else:
            messages.error(request, 'A ata não pode ser finalizada. Todos os membros presentes devem assinar primeiro.')
    
    return redirect('militares:ata_assinaturas', pk=pk)

def clean_html_for_reportlab(html):
    if not html:
        return ""
    
    # Decodifica entidades HTML primeiro
    html = unescape(html)
    
    # Remove comentários HTML
    html = re.sub(r'<!--.*?-->', '', html, flags=re.DOTALL)
    
    # Remove atributos style, id, class, target, etc.
    html = re.sub(r'(<\w+)([^>]*)(style|id|class|target|rel|onclick|onmouseover|onmouseout|align|width|height|data-[^=]*)=["\"][^"\"]*["\"]', r'\1', html)
    
    # Remove todos os atributos de todas as tags, exceto href em <a>
    html = re.sub(r'<(?!a\b)(\w+)[^>]*>', r'<\1>', html)
    
    # Remove atributos de <a> exceto href
    html = re.sub(r'<a\s+[^>]*?href=(["\"][^"\"]*["\"])[^>]*>', r'<a href=\1>', html)
    
    # Remove tags não suportadas (mantém apenas p, b, i, u, br, a, ul, ol, li, strong, em)
    html = re.sub(r'</?(?!p\b|b\b|i\b|u\b|br\b|a\b|ul\b|ol\b|li\b|strong\b|em\b)[a-zA-Z0-9]+[^>]*>', '', html)
    
    # Corrigir tags <br> não fechadas - substituir por <br/>
    html = re.sub(r'<br\s*>', '<br/>', html)
    html = re.sub(r'<br\s+[^>]*>', '<br/>', html)
    
    # Corrigir tags <br> com fechamento incorreto
    html = re.sub(r'<br\s*></br>', '<br/>', html)
    
    # Remove espaços extras entre tags
    html = re.sub(r'>\s+<', '><', html)
    
    # Remove espaços em branco no início e fim
    html = html.strip()
    
    return html

@login_required
def modelo_ata_list(request):
    print(f"=== INÍCIO modelo_ata_list ===")
    print(f"GET params: {request.GET}")
    print(f"Headers: {dict(request.headers)}")
    
    modelos = ModeloAta.objects.all()
    tipo_comissao = request.GET.get('tipo_comissao')
    if tipo_comissao:
        modelos = modelos.filter(tipo_comissao=tipo_comissao)
    tipo_sessao = request.GET.get('tipo_sessao')
    if tipo_sessao:
        modelos = modelos.filter(tipo_sessao=tipo_sessao)
    ativo = request.GET.get('ativo')
    if ativo is not None:
        modelos = modelos.filter(ativo=ativo == 'true')
    padrao = request.GET.get('padrao')
    if padrao is not None:
        modelos = modelos.filter(padrao=padrao == 'true')
    
    print(f"Modelos encontrados: {modelos.count()}")
    
    context = {
        'modelos': modelos,
        'tipos_comissao': ModeloAta.TIPO_COMISSAO_CHOICES,
        'tipos_sessao': ModeloAta.TIPO_SESSAO_CHOICES,
        'filtros': {
            'tipo_comissao': tipo_comissao,
            'tipo_sessao': tipo_sessao,
            'ativo': ativo,
            'padrao': padrao,
        }
    }
    
    # Verificar se é uma requisição para JSON
    format_json = request.GET.get('format') == 'json'
    ajax_request = request.GET.get('ajax') == '1'
    
    print(f"Format JSON: {format_json}")
    print(f"Ajax Request: {ajax_request}")
    
    if format_json or ajax_request:
        print("=== RETORNANDO JSON ===")
        modelos_data = []
        for modelo in modelos:
            modelos_data.append({
                'id': modelo.pk,
                'nome': modelo.nome,
                'descricao': modelo.descricao,
                'tipo_comissao': modelo.tipo_comissao,
                'tipo_comissao_display': modelo.get_tipo_comissao_display(),
                'tipo_sessao': modelo.tipo_sessao,
                'tipo_sessao_display': modelo.get_tipo_sessao_display(),
                'ativo': modelo.ativo,
                'padrao': modelo.padrao,
                'criado_por': modelo.criado_por.get_full_name() if modelo.criado_por else modelo.criado_por.username,
                'data_criacao': modelo.data_criacao.strftime('%d/%m/%Y %H:%M') if modelo.data_criacao else '',
            })
        
        response_data = {
            'success': True,
            'modelos': modelos_data
        }
        print(f"Response data: {response_data}")
        return JsonResponse(response_data)
    
    print("=== RETORNANDO HTML ===")
    return render(request, 'militares/modelo_ata/list.html', context)

@login_required
def modelo_ata_create(request):
    if request.method == 'POST':
        form = ModeloAtaForm(request.POST)
        if form.is_valid():
            modelo = form.save(commit=False)
            modelo.criado_por = request.user
            modelo.save()
            messages.success(request, f'Modelo "{modelo.nome}" criado com sucesso!')
            return redirect('militares:modelo_ata_list')
    else:
        form = ModeloAtaForm()
    context = {
        'form': form,
        'titulo': 'Criar Novo Modelo de Ata',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - Número da sessão',
            '{{sessao.data_sessao}} - Data da sessão',
            '{{sessao.hora_inicio}} - Hora de início',
            '{{sessao.hora_fim}} - Hora de término',
            '{{sessao.local}} - Local da sessão',
            '{{sessao.tipo}} - Tipo da sessão',
            '{{sessao.pauta}} - Pauta da sessão',
            '{{comissao.nome}} - Nome da comissão',
            '{{comissao.tipo}} - Tipo da comissão',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_update(request, pk):
    print(f"=== INÍCIO modelo_ata_update ===")
    print(f"PK: {pk}")
    print(f"Método: {request.method}")
    print(f"Headers: {dict(request.headers)}")
    
    modelo = get_object_or_404(ModeloAta, pk=pk)
    print(f"Modelo encontrado: {modelo.nome}")
    
    # Verificar se é uma requisição AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    print(f"É AJAX: {is_ajax}")
    
    if request.method == 'POST':
        print("=== PROCESSANDO POST ===")
        print(f"POST data: {request.POST}")
        
        try:
            # Obter dados do formulário
            nome = request.POST.get('nome', '').strip()
            descricao = request.POST.get('descricao', '').strip()
            tipo_comissao = request.POST.get('tipo_comissao', 'GERAL')
            tipo_sessao = request.POST.get('tipo_sessao', 'GERAL')
            conteudo = request.POST.get('conteudo', '').strip()
            
            print(f"Nome: {nome}")
            print(f"Descrição: {descricao}")
            print(f"Tipo Comissão: {tipo_comissao}")
            print(f"Tipo Sessão: {tipo_sessao}")
            print(f"Conteúdo: {conteudo[:100] if conteudo else 'VAZIO'}")
            
            # Validações
            if not nome:
                error_msg = 'Nome do modelo é obrigatório.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:modelo_ata_list')
            
            if not conteudo:
                error_msg = 'Conteúdo do modelo é obrigatório.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:modelo_ata_list')
            
            # Atualizar o modelo
            modelo.nome = nome
            modelo.descricao = descricao
            modelo.tipo_comissao = tipo_comissao
            modelo.tipo_sessao = tipo_sessao
            modelo.conteudo = conteudo
            modelo.save()
            
            print(f"Modelo atualizado com sucesso: {modelo.nome}")
            
            success_msg = f'Modelo "{modelo.nome}" atualizado com sucesso!'
            
            if is_ajax:
                return JsonResponse({
                    'success': True,
                    'message': success_msg,
                    'modelo_id': modelo.pk,
                    'modelo_nome': modelo.nome
                })
            else:
                messages.success(request, success_msg)
                return redirect('militares:modelo_ata_list')
                
        except Exception as e:
            print(f"ERRO ao atualizar modelo: {str(e)}")
            import traceback
            traceback.print_exc()
            
            error_msg = f'Erro ao atualizar modelo: {str(e)}'
            
            if is_ajax:
                return JsonResponse({'success': False, 'error': error_msg})
            else:
                messages.error(request, error_msg)
                return redirect('militares:modelo_ata_list')
    else:
        print("=== MÉTODO GET ===")
        form = ModeloAtaForm(instance=modelo)
    
    context = {
        'form': form,
        'modelo': modelo,
        'titulo': f'Editar Modelo: {modelo.nome}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - Número da sessão',
            '{{sessao.data_sessao}} - Data da sessão',
            '{{sessao.hora_inicio}} - Hora de início',
            '{{sessao.hora_fim}} - Hora de término',
            '{{sessao.local}} - Local da sessão',
            '{{sessao.tipo}} - Tipo da sessão',
            '{{sessao.pauta}} - Pauta da sessão',
            '{{comissao.nome}} - Nome da comissão',
            '{{comissao.tipo}} - Tipo da comissão',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_delete(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    
    # Verificar se é uma requisição AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if request.method == 'POST':
        nome = modelo.nome
        modelo.delete()
        
        if is_ajax:
            return JsonResponse({
                'success': True,
                'message': f'Modelo "{nome}" excluído com sucesso!'
            })
        else:
            messages.success(request, f'Modelo "{nome}" excluído com sucesso!')
            return redirect('militares:modelo_ata_list')
    
    context = {
        'modelo': modelo,
        'titulo': f'Excluir Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/delete.html', context)

@login_required
def modelo_ata_detail(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    
    # Verificar se é uma requisição AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if is_ajax:
        return JsonResponse({
            'success': True,
            'modelo': {
                'id': modelo.pk,
                'nome': modelo.nome,
                'descricao': modelo.descricao,
                'tipo_comissao': modelo.tipo_comissao,
                'tipo_comissao_display': modelo.get_tipo_comissao_display(),
                'tipo_sessao': modelo.tipo_sessao,
                'tipo_sessao_display': modelo.get_tipo_sessao_display(),
                'conteudo': modelo.conteudo,
                'ativo': modelo.ativo,
                'padrao': modelo.padrao,
                'criado_por': modelo.criado_por.get_full_name() if modelo.criado_por else modelo.criado_por.username,
                'data_criacao': modelo.data_criacao.strftime('%d/%m/%Y %H:%M') if modelo.data_criacao else '',
            }
        })
    
    context = {
        'modelo': modelo,
        'titulo': f'Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/detail.html', context)

@login_required
def modelo_ata_aplicar(request, sessao_pk):
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    try:
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se é uma requisição AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if request.method == 'POST':
        modelo_id = request.POST.get('modelo_id')
        if modelo_id:
            try:
                modelo = ModeloAta.objects.get(pk=modelo_id, ativo=True)
                if modelo.pode_ser_usado_para(sessao):
                    conteudo_aplicado = modelo.aplicar_variaveis(sessao)
                    try:
                        ata = sessao.ata_editada
                    except AtaSessao.DoesNotExist:
                        ata = AtaSessao(sessao=sessao, editado_por=request.user)
                    ata.conteudo = conteudo_aplicado
                    ata.editado_por = request.user
                    ata.save()
                    
                    if is_ajax:
                        return JsonResponse({
                            'success': True,
                            'message': f'Modelo "{modelo.nome}" aplicado com sucesso!',
                            'conteudo': conteudo_aplicado
                        })
                    else:
                        messages.success(request, f'Modelo "{modelo.nome}" aplicado com sucesso!')
                        return redirect('militares:sessao_editar_ata', pk=sessao.pk)
                else:
                    error_msg = 'Este modelo não pode ser usado para esta sessão.'
                    if is_ajax:
                        return JsonResponse({'success': False, 'error': error_msg})
                    else:
                        messages.error(request, error_msg)
            except ModeloAta.DoesNotExist:
                error_msg = 'Modelo não encontrado.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
    
    modelos_disponiveis = ModeloAta.get_modelos_disponiveis(sessao)
    modelo_padrao = ModeloAta.get_modelo_padrao(sessao)
    context = {
        'sessao': sessao,
        'modelos_disponiveis': modelos_disponiveis,
        'modelo_padrao': modelo_padrao,
        'titulo': f'Aplicar Modelo à Sessão {sessao.numero}'
    }
    return render(request, 'militares/modelo_ata/aplicar.html', context)

@login_required
def modelo_ata_salvar_atual(request, sessao_pk):
    
    print(f"=== INÍCIO DA FUNÇÃO modelo_ata_salvar_atual ===")
    print(f"Sessão PK: {sessao_pk}")
    print(f"Método: {request.method}")
    
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    print(f"Sessão encontrada: {sessao}")
    
    # Verificar se existe uma ata
    try:
        ata = sessao.ata_editada
        print(f"Ata encontrada: {ata}")
        print(f"Conteúdo da ata: {ata.conteudo[:100] if ata.conteudo else 'VAZIO'}")
    except AtaSessao.DoesNotExist:
        print("ERRO: Não existe uma ata para esta sessão")
        messages.error(request, 'Não existe uma ata para esta sessão.')
        return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    
    # Criar formulário personalizado sem o campo conteudo
    class ModeloAtaSalvarForm(forms.ModelForm):
        class Meta:
            model = ModeloAta
            fields = ['nome', 'descricao', 'tipo_comissao', 'tipo_sessao', 'ativo', 'padrao']
            widgets = {
                'nome': forms.TextInput(attrs={
                    'class': 'form-control',
                    'placeholder': 'Ex: Modelo Padrão CPO Ordinária'
                }),
                'descricao': forms.Textarea(attrs={
                    'class': 'form-control',
                    'rows': 3,
                    'placeholder': 'Descrição do modelo e quando usá-lo...'
                }),
                'tipo_comissao': forms.Select(attrs={'class': 'form-control'}),
                'tipo_sessao': forms.Select(attrs={'class': 'form-control'}),
                'ativo': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
                'padrao': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            }
    
    if request.method == 'POST':
        print("=== PROCESSANDO POST ===")
        print(f"POST data: {request.POST}")
        
        # Verificar se é uma requisição AJAX
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.content_type == 'application/json'
        
        try:
            # Obter dados do formulário
            nome = request.POST.get('nome', '').strip()
            descricao = request.POST.get('descricao', '').strip()
            tipo_comissao = request.POST.get('tipo_comissao', 'GERAL')
            tipo_sessao = request.POST.get('tipo_sessao', 'GERAL')
            conteudo = request.POST.get('conteudo', '').strip()
            
            print(f"Nome: {nome}")
            print(f"Descrição: {descricao}")
            print(f"Tipo Comissão: {tipo_comissao}")
            print(f"Tipo Sessão: {tipo_sessao}")
            print(f"Conteúdo: {conteudo[:100] if conteudo else 'VAZIO'}")
            
            # Validações
            if not nome:
                error_msg = 'Nome do modelo é obrigatório.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:sessao_editar_ata', pk=sessao.pk)
            
            if not conteudo:
                error_msg = 'Conteúdo do modelo é obrigatório.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:sessao_editar_ata', pk=sessao.pk)
            
            # Criar o modelo
            modelo = ModeloAta.objects.create(
                nome=nome,
                descricao=descricao,
                tipo_comissao=tipo_comissao,
                tipo_sessao=tipo_sessao,
                conteudo=conteudo,
                criado_por=request.user,
                ativo=True,
                padrao=False
            )
            
            print(f"Modelo salvo com sucesso: {modelo.nome} (ID: {modelo.pk})")
            
            success_msg = f'Modelo "{modelo.nome}" criado com sucesso!'
            
            if is_ajax:
                return JsonResponse({
                    'success': True,
                    'message': success_msg,
                    'modelo_id': modelo.pk,
                    'modelo_nome': modelo.nome
                })
            else:
                messages.success(request, success_msg)
                return redirect('militares:modelo_ata_list')
                
        except Exception as e:
            print(f"ERRO ao salvar modelo: {str(e)}")
            import traceback
            traceback.print_exc()
            
            error_msg = f'Erro ao salvar modelo: {str(e)}'
            
            if is_ajax:
                return JsonResponse({'success': False, 'error': error_msg})
            else:
                messages.error(request, error_msg)
                return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    else:
        print("=== MÉTODO GET ===")
        form = ModeloAtaSalvarForm(initial={
            'nome': f'Modelo da Sessão {sessao.numero} - {sessao.comissao.nome}',
            'tipo_comissao': sessao.comissao.tipo,
            'tipo_sessao': sessao.tipo,
            'descricao': f'Modelo criado a partir da ata da sessão {sessao.numero} realizada em {sessao.data_sessao.strftime("%d/%m/%Y")}',
        })
    
    context = {
        'form': form,
        'sessao': sessao,
        'ata': ata,
        'titulo': f'Salvar Ata como Modelo - Sessão {sessao.numero}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - Número da sessão',
            '{{sessao.data_sessao}} - Data da sessão',
            '{{sessao.hora_inicio}} - Hora de início',
            '{{sessao.hora_fim}} - Hora de término',
            '{{sessao.local}} - Local da sessão',
            '{{sessao.tipo}} - Tipo da sessão',
            '{{sessao.pauta}} - Pauta da sessão',
            '{{comissao.nome}} - Nome da comissão',
            '{{comissao.tipo}} - Tipo da comissão',
        ]
    }
    
    print("=== RENDERIZANDO TEMPLATE ===")
    return render(request, 'militares/modelo_ata/salvar_atual.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_resultado(request, sessao_pk):
    """Exibir resultado das deliberações com votos dos membros"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuário é membro da comissão
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    # Buscar todas as deliberações da sessão com seus votos
    deliberacoes = sessao.deliberacoes.prefetch_related('votos__membro__militar').all()
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacoes': deliberacoes,
        'user_membro': user_membro,
        'membros_presentes': [p.membro for p in sessao.presencas.filter(presente=True)],
    }
    return render(request, 'militares/comissao/deliberacoes/resultado.html', context)

@login_required
@comissao_acesso_total
def deliberacao_resultado_update(request, pk):
    """Editar resultado da deliberação após votação concluída"""
    deliberacao = get_object_or_404(DeliberacaoComissao, pk=pk)
    
    # Verificar se o usuário é membro da comissão
    membro = MembroComissao.objects.filter(
        comissao=deliberacao.sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=deliberacao.sessao.pk)
    
    # Verificar se a votação foi concluída
    total_presentes = deliberacao.sessao.presencas.filter(presente=True).count()
    total_votos = deliberacao.votos.count()
    
    if total_votos < total_presentes:
        messages.error(request, 
            f'A votação ainda não foi concluída ({total_votos}/{total_presentes} votos). '
            'O resultado só pode ser registrado após todos os membros presentes votarem.'
        )
        return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    
    if request.method == 'POST':
        # Criar formulário apenas com o campo resultado
        class ResultadoForm(forms.Form):
            resultado = forms.CharField(
                widget=forms.Textarea(attrs={
                    'rows': 6,
                    'class': 'form-control',
                    'placeholder': 'Registre aqui a decisão ou resultado da deliberação após a votação...'
                }),
                required=True,
                label='Resultado da Deliberação'
            )
        
        form = ResultadoForm(request.POST)
        if form.is_valid():
            deliberacao.resultado = form.cleaned_data['resultado']
            deliberacao.save()
            
            messages.success(request, 'Resultado da deliberação registrado com sucesso!')
            return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    else:
        # Formulário inicial com o resultado atual
        class ResultadoForm(forms.Form):
            resultado = forms.CharField(
                widget=forms.Textarea(attrs={
                    'rows': 6,
                    'class': 'form-control',
                    'placeholder': 'Registre aqui a decisão ou resultado da deliberação após a votação...'
                }),
                required=True,
                label='Resultado da Deliberação',
                initial=deliberacao.resultado
            )
        
        form = ResultadoForm()
    
    context = {
        'deliberacao': deliberacao,
        'form': form,
        'sessao': deliberacao.sessao,
        'comissao': deliberacao.sessao.comissao,
        'membro': membro,
        'total_presentes': total_presentes,
        'total_votos': total_votos,
        'title': f'Registrar Resultado - Deliberação {deliberacao.numero}'
    }
    
    return render(request, 'militares/comissao/deliberacoes/resultado_form.html', context)

@login_required
def notificacoes_list(request):
    """Lista todas as notificações do usuário"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user
    ).order_by('-data_criacao')
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        notificacoes = notificacoes.filter(tipo=tipo)
    
    lida = request.GET.get('lida')
    if lida is not None:
        notificacoes = notificacoes.filter(lida=lida == 'true')
    
    # Paginação
    paginator = Paginator(notificacoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'notificacoes': page_obj,
        'tipos': NotificacaoSessao.TIPO_CHOICES,
        'filtros': {
            'tipo': tipo,
            'lida': lida,
        }
    }
    
    return render(request, 'militares/notificacoes/list.html', context)

@login_required
def notificacao_marcar_lida(request, pk):
    """Marca uma notificação como lida"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.marcar_como_lida()
        messages.success(request, 'Notificação marcada como lida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'Notificação não encontrada.')
    
    return redirect('militares:notificacoes_list')

@login_required
def notificacao_marcar_todas_lidas(request):
    """Marca todas as notificações do usuário como lidas"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    )
    
    count = notificacoes.count()
    notificacoes.update(lida=True, data_leitura=timezone.now())
    
    messages.success(request, f'{count} notificação(ões) marcada(s) como lida(s).')
    return redirect('militares:notificacoes_list')

@login_required
def notificacao_delete(request, pk):
    """Remove uma notificação"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.delete()
        messages.success(request, 'Notificação removida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'Notificação não encontrada.')
    
    return redirect('militares:notificacoes_list')

# Views para gerenciar cargos da comissão
@login_required
@comissao_acesso_total
def cargo_comissao_list(request):
    """Lista todos os cargos da comissão"""
    cargos = CargoComissao.objects.all()
    
    context = {
        'cargos': cargos,
        'title': 'Cargos da Comissão',
    }
    return render(request, 'militares/comissao/cargos/list.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_create(request):
    """Cria um novo cargo"""
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo criado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm()
    
    context = {
        'form': form,
        'title': 'Novo Cargo da Comissão',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_update(request, pk):
    """Edita um cargo existente"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo não encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST, instance=cargo)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo atualizado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm(instance=cargo)
    
    context = {
        'form': form,
        'cargo': cargo,
        'title': 'Editar Cargo da Comissão',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_delete(request, pk):
    """Exclui um cargo"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo não encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    # Buscar membros vinculados ao cargo
    # Como MembroComissao.cargo referencia CargoFuncao, não CargoComissao,
    # vamos buscar por membros que tenham o mesmo nome de cargo
    membros_vinculados = MembroComissao.objects.filter(cargo__nome=cargo.nome)
    erro_protegido = False
    

    
    if request.method == 'POST':
        try:
            cargo.delete()
            messages.success(request, 'Cargo excluído com sucesso!')
            return redirect('militares:cargo_comissao_list')
        except ProtectedError:
            erro_protegido = True
            messages.error(request, 'Não é possível excluir este cargo porque ele está vinculado a um ou mais membros da comissão. Troque o cargo desses membros antes de excluir.')
    
    context = {
        'cargo': cargo,
        'title': 'Excluir Cargo da Comissão',
        'membros_vinculados': membros_vinculados,
        'erro_protegido': erro_protegido,
    }
    return render(request, 'militares/comissao/cargos/delete.html', context)

# =============================================================================
# MÓDULO DE QUADROS DE FIXAÇÃO DE VAGAS
# =============================================================================

@login_required
def quadro_fixacao_vagas_list(request):
    """Lista todos os quadros de fixação de vagas de oficiais"""
    # Permissão especial para superusuários, staff e funções administrativas
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    
    # Superusuários e staff podem ver todos os quadros
    if request.user.is_superuser or request.user.is_staff or funcoes_ativas.exists():
        quadros = QuadroFixacaoVagas.objects.all().order_by('-data_criacao')
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroFixacaoVagas.objects.all().order_by('-data_criacao')
            elif tem_cpo:
                quadros = QuadroFixacaoVagas.objects.filter(tipo='OFICIAIS').order_by('-data_criacao')
            elif tem_cpp:
                quadros = QuadroFixacaoVagas.objects.filter(tipo='PRACAS').order_by('-data_criacao')
            else:
                quadros = QuadroFixacaoVagas.objects.none()
        else:
            quadros = QuadroFixacaoVagas.objects.none()
    
    # Filtros
    data_inicio = request.GET.get('data_inicio')
    if data_inicio:
        try:
            data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__gte=data_inicio)
        except ValueError:
            pass
    
    data_fim = request.GET.get('data_fim')
    if data_fim:
        try:
            data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__lte=data_fim)
        except ValueError:
            pass
    
    # Paginação
    paginator = Paginator(quadros, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estatísticas
    total_quadros = quadros.count()
    
    # Verificar se o usuário é membro de alguma comissão
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    context = {
        'quadros': page_obj,
        'total_quadros': total_quadros,
        'filtros': {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
        },
        'membro_comissao': membro_comissao,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/list.html', context)

@login_required
def quadro_fixacao_vagas_create(request):
    """Cria um novo quadro de fixação de vagas"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O título do quadro é obrigatório.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not tipo:
            messages.error(request, 'O tipo de quadro é obrigatório.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_fixacao_vagas_create')
        
        # Verificar se já existe um quadro para esta data
        # Removida a validação que impedia múltiplos quadros para a mesma data
        # (permitir múltiplos quadros de fixação de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo=tipo,
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Capturar previsões de vagas baseado no tipo
            if tipo == 'OFICIAIS':
                # Buscar previsões para oficiais (quadros COMB, SAUDE, ENG, COMP, NVRR)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
                    posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
                ).order_by('quadro', 'posto')
            else:  # PRACAS
                # Buscar previsões para praças (quadro PRACAS)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro='PRACAS',
                    posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
                ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsões
            for previsao in previsoes:
                # Capturar observação específica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual às vagas disponíveis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de Fixação de Vagas criado com sucesso! Data automática: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de Fixação de Vagas criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar previsões de vagas para mostrar no preview
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    previsoes_pracas = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro='PRACAS',
        posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
    )
    
    # Agrupar previsões por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    vagas_por_quadro_pracas = {}
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_por_quadro_pracas:
            vagas_por_quadro_pracas[previsao.quadro] = []
        vagas_por_quadro_pracas[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_pracas:
        vagas_por_quadro_pracas[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'tipos': QuadroFixacaoVagas.TIPO_CHOICES,
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'vagas_por_quadro_pracas': vagas_por_quadro_pracas,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/create.html', context)

@login_required
def quadro_fixacao_vagas_detail(request, pk):
    """Detalhes de um quadro de fixação de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuário é membro de alguma comissão e tem permissão para ver este quadro
    membros_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    )
    
    if membros_comissao.exists():
        # Verificar se é membro de ambas as comissões
        tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
        tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
        
        # Se é membro de ambas, pode ver todos os quadros
        if tem_cpo and tem_cpp:
            pass  # Pode ver todos os quadros
        elif tem_cpo and quadro.tipo != 'OFICIAIS':
            messages.error(request, 'Você não tem permissão para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')
        elif tem_cpp and quadro.tipo != 'PRACAS':
            messages.error(request, 'Você não tem permissão para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }

    return render(request, 'militares/quadro_fixacao_vagas/detail.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_update(request, pk):
    """Atualiza um quadro de fixação de vagas (geral)"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuário é membro de alguma comissão e tem permissão para editar este quadro
    # Superusuários e staff têm acesso total, independente de serem membros de comissão
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'Você não tem permissão para editar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'Você não tem permissão para editar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        # Atualizar dados básicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')

        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_fixacao_vagas_update', pk=pk)
        quadro.observacoes = observacoes
        # Limpar assinaturas eletrônicas ao editar o quadro
        quadro.assinaturas.all().delete()
        quadro.save()

        # Atualizar observações dos itens (vagas fixadas são automáticas)
        for key, value in request.POST.items():
            if key.startswith('observacoes_'):
                item_id = key.replace('observacoes_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    item.observacoes = value
                    # As vagas fixadas são automaticamente sincronizadas no save() do modelo
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        messages.success(request, 'Quadro de fixação de vagas atualizado com sucesso! As assinaturas eletrônicas foram removidas e será necessário assinar novamente.')
        return redirect('militares:quadro_fixacao_vagas_detail', pk=quadro.pk)

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    return render(request, 'militares/quadro_fixacao_vagas/update.html', context)

@login_required
def quadro_fixacao_vagas_pdf_view(request, pk):
    """Visualiza o PDF do quadro de fixação de vagas em nova aba"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuário é membro de alguma comissão e tem permissão para visualizar este quadro
    # Superusuários e staff têm acesso total, independente de serem membros de comissão
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'Você não tem permissão para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'Você não tem permissão para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/pdf_view.html', context)

@login_required
def quadro_fixacao_vagas_pdf(request, pk):
    """Gera PDF do quadro de fixação de vagas no modelo institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para português brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrão se não conseguir configurar

    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, f'Quadro de fixação de vagas com ID {pk} não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuário é membro de alguma comissão e tem permissão para visualizar este quadro
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    if membro_comissao:
        if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
            messages.error(request, 'Você não tem permissão para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')
        elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
            messages.error(request, 'Você não tem permissão para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        "DIRETORIA DE GESTÃO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Título centralizado e sublinhado
    tipo_quadro = "QUADRO DE FIXAÇÃO DE VAGAS"
    if quadro.tipo == 'OFICIAIS':
        tipo_quadro += " PARA OFICIAIS"
    elif quadro.tipo == 'PRACAS':
        tipo_quadro += " PARA PRACAS"
    
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutório com data em português
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Texto introdutório específico para oficiais ou praças
    if quadro.tipo == 'OFICIAIS':
        # Adicionar cada parágrafo separadamente
        story.append(Paragraph("O DIRETOR DE GESTÃO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ, no uso de suas atribuições que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1° da lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Anexo Único, da lei nº 5.949, de 17 de dezembro de 2009 (Lei de Organização Básica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Art. 2º da Lei nº 5.461 de 30 de junho de 2005 (Lei de Promoção de Oficiais do CBMEPI).", style_just))
    else:  # PRACAS
        # Adicionar cada parágrafo separadamente
        story.append(Paragraph("O DIRETOR DE GESTÃO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ, no uso de suas atribuições que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1º da lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Anexo Único, da lei nº 5.949, de 17 de dezembro de 2009 (Lei de Organização Básica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Art. 2º da Lei nº 5.462 de 30 de junho de 2005 (Lei de Promoção de Praças do CBMEPI);", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("RESOLVE:", style_just))
    story.append(Spacer(1, 16))
    
    # Artigo 1º em parágrafo separado
    artigo_1 = f"""
    <b>Art. 1º</b> Fixar as vagas para as promoções de {quadro.get_tipo_display()} em {data_formatada}, conforme segue:
    """
    
    story.append(Paragraph(artigo_1, style_bold))
    story.append(Spacer(1, 16))

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    # Tabela principal
    for cod_quadro, grupo in grupos.items():
        # Definir nomes completos dos quadros
        quadro_nomes_completos = {
            'COMB': 'Quadro de Oficiais Bombeiros Militares Combatentes (QOBM/Comb.)',
            'SAUDE': 'Quadro de Oficiais Bombeiros Militares de Saúde (QOBM/Saúde)',
            'ENG': 'Quadro de Oficiais Bombeiros Militares Engenheiros (QOBM/Eng.)',
            'COMP': 'Quadro de Oficiais Bombeiros Militares Complementar (QOBM/Comp.)',
            'PRACAS': 'Quadro de Praças (QP)',
        }
        
        # Título do quadro com nome completo
        nome_quadro_completo = quadro_nomes_completos.get(cod_quadro, grupo['nome'])
        story.append(Paragraph(f"<b>{nome_quadro_completo}</b>", style_subtitle))
        story.append(Spacer(1, 8))
        
        # Dados da tabela (sem cabeçalho)
        data = []
        
        # Dados da tabela
        for item in grupo['itens']:
            posto = item.previsao_vaga.get_posto_display()
            vagas_fixadas = str(item.vagas_fixadas)
            vagas_disponiveis = str(item.previsao_vaga.vagas_disponiveis)
            observacoes = item.observacoes or '-'
            
            data.append([posto, vagas_fixadas, vagas_disponiveis, observacoes])
        
        # Criar tabela com larguras específicas para evitar sobreposição
        table = Table(data, colWidths=[5*cm, 3*cm, 3*cm, 5*cm])
        table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('ALIGN', (3, 0), (3, -1), 'LEFT'),  # Observações alinhadas à esquerda
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 4),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
            ('WORDWRAP', (0, 0), (-1, -1), True),  # Quebra de linha automática
        ]))
        
        story.append(table)
        story.append(Spacer(1, 16))

    # Observações do quadro
    if quadro.observacoes:
        story.append(Paragraph("<b>Observações Gerais:</b>", style_bold))
        story.append(Spacer(1, 6))
        story.append(Paragraph(quadro.observacoes, style_just))
        story.append(Spacer(1, 16))

    # Data e local
    data_extenso = f"Teresina, {data_formatada}"
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # Seção de Assinaturas Físicas (sem título)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas válidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo não registrado"
        
        # Exibir no formato físico: Nome - Posto BM (negrito), Função (normal), Tipo (negrito menor)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Paragraph(f"<b>{tipo}</b>", style_center))
        story.append(Spacer(1, 13))

    # Seção de Assinaturas Eletrônicas (sem título)
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
    story.append(Spacer(1, 13))
    
    # Buscar todas as assinaturas para exibir na seção eletrônica
    assinaturas_eletronicas = quadro.assinaturas.filter(
        assinado_por__isnull=False
    ).order_by('-data_assinatura')
    
    for i, assinatura in enumerate(assinaturas_eletronicas):
        # Nome e posto - seguir o mesmo padrão dos quadros de acesso
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{posto} {militar.nome_completo}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo não registrado"
        
        # Data da assinatura
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        data_assinatura = f"{data_formatada} às {hora_formatada}"
        
        # Texto da assinatura eletrônica no padrão solicitado
        texto_assinatura = f"Documento assinado eletronicamente por {nome_completo} - {funcao}, em {data_assinatura}, conforme horário oficial de Brasília, conforme portaria comando geral nº59/2020 publicada em boletim geral nº26/2020"
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na última)
        if i < len(assinaturas_eletronicas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # Se não houver assinaturas, mostrar mensagem
    if not assinaturas.exists() and not assinaturas_eletronicas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))
    
    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a função utilitária para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(quadro, request, tipo_documento='quadro_fixacao')
    
    # Tabela do rodapé: QR + Texto de autenticação
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualização em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'quadro_fixacao_vagas_{quadro.pk}.pdf')

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_create(request):
    """Cria um novo quadro de fixação de vagas para oficiais"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O título do quadro é obrigatório.')
            return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        # Verificar se já existe um quadro para esta data
        quadro_existente = QuadroFixacaoVagas.objects.filter(
            data_promocao=data_promocao,
            tipo='OFICIAIS'
        ).first()
        
        # Removida a validação que impedia múltiplos quadros para a mesma data
        # (permitir múltiplos quadros de fixação de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo='OFICIAIS',
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Buscar previsões para oficiais (quadros COMB, SAUDE, ENG, COMP, NVRR)
            previsoes = PrevisaoVaga.objects.filter(
                ativo=True,
                quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
                posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
            ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsões
            for previsao in previsoes:
                # Capturar observação específica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual às vagas disponíveis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de Fixação de Vagas para Oficiais criado com sucesso! Data automática: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de Fixação de Vagas para Oficiais criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_oficiais_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
    }
    
    # Buscar previsões de vagas para oficiais
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    # Calcular efetivo atual em tempo real para cada previsão
    for previsao in previsoes_oficiais:
        if previsao.quadro == 'COMP':
            # Para COMP, incluir ST (Subtenentes) que são cadastrados como COMP mas contam para praças
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro='COMP',
                situacao='AT'
            ).count()
        else:
            # Para outros quadros, usar o quadro específico
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'
            ).count()
        
        # Atualizar o efetivo atual da previsão (apenas para exibição)
        previsao.efetivo_atual = efetivo_atual
    
    # Agrupar previsões por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequência: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_create.html', context)

@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixação de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Estatísticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)

@login_required
def assinar_quadro_fixacao_vagas(request, pk):
    """Assinar quadro de fixação de vagas com confirmação de senha"""
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    
    # Verificar se o usuário é membro de alguma comissão e tem permissão para assinar este quadro
    # Superusuários e staff têm acesso total, independente de serem membros de comissão
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'Você não tem permissão para assinar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'Você não tem permissão para assinar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Verificar se já existe uma assinatura deste usuário para este tipo
        assinatura_existente = AssinaturaQuadroFixacaoVagas.objects.filter(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'Você já assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroFixacaoVagas.objects.create(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura,
            funcao_assinatura=funcao_assinatura
        )
        
        # Se a assinatura for de aprovação, mudar o status do quadro para APROVADO
        if tipo_assinatura == 'APROVACAO':
            quadro.status = 'APROVADO'
            quadro.save()
        
        messages.success(request, f'Quadro de fixação de vagas assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)

@login_required
def retirar_assinatura_quadro_fixacao_vagas(request, pk, assinatura_pk):
    """Retirar assinatura do quadro de fixação de vagas - apenas antes da homologação"""
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    assinatura = get_object_or_404(AssinaturaQuadroFixacaoVagas, pk=assinatura_pk, quadro_fixacao_vagas=quadro)
    
    # Verificar se o quadro já foi homologado
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Não é possível retirar assinaturas de um quadro já homologado.')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    # Verificar se o usuário é o autor da assinatura ou tem permissão administrativa
    if assinatura.assinado_por != request.user and not request.user.is_staff:
        messages.error(request, 'Você só pode retirar suas próprias assinaturas.')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_quadro_fixacao_vagas.html', context)
        
        # Verificar se a assinatura é de aprovação e se há outras assinaturas de aprovação
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = quadro.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se não há outras aprovações, voltar o status do quadro para RASCUNHO
                quadro.status = 'RASCUNHO'
                quadro.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_quadro_fixacao_vagas.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_delete(request, pk):
    """Exclui um quadro de fixação de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        try:
            quadro.delete()
            messages.success(request, 'Quadro de fixação de vagas excluído com sucesso!')
            return redirect('militares:quadro_fixacao_vagas_list')
        except Exception as e:
            messages.error(request, f'Erro ao excluir quadro: {str(e)}')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/delete.html', context)

@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixação de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Estatísticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_update(request, pk):
    """Atualiza um quadro de fixação de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        # Atualizar dados básicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoção inválida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_update', pk=pk)
        
        quadro.observacoes = observacoes
        # Limpar assinaturas eletrônicas ao editar o quadro
        quadro.assinaturas.all().delete()
        quadro.save()
        
        # Atualizar vagas fixadas
        for key, value in request.POST.items():
            if key.startswith('vagas_fixadas_'):
                item_id = key.replace('vagas_fixadas_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    vagas_fixadas = int(value) if value else 0
                    item.vagas_fixadas = vagas_fixadas
                    
                    # Buscar observações correspondentes
                    obs_key = f'observacoes_{item_id}'
                    observacoes_item = request.POST.get(obs_key, '')
                    item.observacoes = observacoes_item
                    
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        
        messages.success(request, 'Quadro de fixação de vagas atualizado com sucesso! As assinaturas eletrônicas foram removidas e será necessário assinar novamente.')
        return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=quadro.pk)
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_update.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_delete(request, pk):
    """Exclui um quadro de fixação de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk, tipo='OFICIAIS')
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixação de vagas não encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        try:
            quadro.delete()
            messages.success(request, 'Quadro de fixação de vagas excluído com sucesso!')
            return redirect('militares:quadro_fixacao_vagas_list')
        except Exception as e:
            messages.error(request, f'Erro ao excluir quadro: {str(e)}')
            return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=pk)
    
    context = {
        'quadro': quadro,
    }
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_confirm_delete.html', context)

def gerar_codigo_verificacao(texto_documento):
    """
    Gera um código de verificação baseado no hash SHA-256 do texto do documento.
    Retorna os primeiros 10 caracteres do hash hexadecimal.
    """
    return hashlib.sha256(texto_documento.encode('utf-8')).hexdigest()[:10]

@login_required
def proxima_numeracao_disponivel(request):
    """Retorna a próxima numeração disponível para um posto/quadro específico"""
    
    if request.method == 'GET':
        posto = request.GET.get('posto')
        quadro = request.GET.get('quadro')
        
        if not posto or not quadro:
            return JsonResponse({'erro': 'Posto e quadro são obrigatórios'}, status=400)
        
        # Buscar todas as numerações existentes para o posto/quadro
        numeracoes_existentes = list(Militar.objects.filter(
            situacao='AT',
            posto_graduacao=posto,
            quadro=quadro,
            numeracao_antiguidade__isnull=False
        ).values_list('numeracao_antiguidade', flat=True).order_by('numeracao_antiguidade'))
        
        # Encontrar o primeiro número disponível (não necessariamente o maior + 1)
        proxima_numeracao = 1
        for num in numeracoes_existentes:
            if proxima_numeracao < num:
                # Encontrou um gap, usar este número
                break
            proxima_numeracao = num + 1
        
        return JsonResponse({
            'proxima_numeracao': proxima_numeracao,
            'posto': posto,
            'quadro': quadro,
            'numeracoes_existentes': numeracoes_existentes
        })
    
    return JsonResponse({'erro': 'Método não permitido'}, status=405)

def reordenar_numeracoes_militares(posto):
    """
    Reordena as numerações de antiguidade para um posto específico,
    corrigindo apenas repetições e gaps, mantendo a ordem atual dos demais.
    """
    # Buscar todos os militares ativos do posto, mantendo a ordem atual
    militares = Militar.objects.filter(
        situacao='AT',
        posto_graduacao=posto
    ).order_by('numeracao_antiguidade', 'id')

    if not militares:
        return 0

    # Detectar problemas (repetições e gaps)
    seen = set()
    start_reorder_index = None
    expected_num = 1
    
    for idx, militar in enumerate(militares):
        current_num = militar.numeracao_antiguidade
        
        # Verificar se há repetição
        if current_num in seen:
            start_reorder_index = idx
            break
        
        # Verificar se há gap (número faltando)
        if current_num != expected_num:
            start_reorder_index = idx
            break
            
        seen.add(current_num)
        expected_num += 1

    # Se não houver problemas (repetição ou gap), não faz nada
    if start_reorder_index is None:
        return 0

    # A partir do primeiro problema, reordena sequencialmente
    # Manter a ordem atual dos militares, apenas corrigindo a numeração
    nova_numeracao = militares[start_reorder_index-1].numeracao_antiguidade + 1 if start_reorder_index > 0 else 1
    militares_para_atualizar = []
    
    for militar in militares[start_reorder_index:]:
        if militar.numeracao_antiguidade != nova_numeracao:
            militar.numeracao_antiguidade = nova_numeracao
            militares_para_atualizar.append(militar)
        nova_numeracao += 1

    if militares_para_atualizar:
        Militar.objects.bulk_update(militares_para_atualizar, ['numeracao_antiguidade'])

    return len(militares_para_atualizar)

@login_required
def reordenar_numeracoes_view(request):
    """View para reordenar numerações de antiguidade por posto, baseado na data de promoção"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        
        # Exigir que o posto seja fornecido
        if not posto:
            messages.error(request, 'O posto é obrigatório para reordenar numerações')
            return redirect('militares:militar_list')
        
        try:
            # Executar reordenação baseada apenas no posto e data de promoção
            total_atualizados = reordenar_numeracoes_militares(posto)
            
            # Contar total de militares do posto
            total_militares = Militar.objects.filter(
                situacao='AT',
                posto_graduacao=posto
            ).count()
            
            posto_display = dict(POSTO_GRADUACAO_CHOICES).get(posto, posto)
            
            if total_atualizados > 0:
                messages.success(
                    request, 
                    f'Correções aplicadas com sucesso para o posto {posto_display}! '
                    f'{total_atualizados} militares foram corrigidos (repetições e gaps removidos).'
                )
            else:
                messages.info(
                    request, 
                    f'Nenhuma correção necessária para o posto {posto_display}. '
                    f'As numerações já estão corretas (sem repetições ou gaps).'
                )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:militar_list')
    
    return redirect('militares:militar_list')

@login_required
def aplicar_promocao_view(request):
    """View para aplicar promoção e atribuir numeração automaticamente"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        novo_posto = request.POST.get('novo_posto')
        novo_quadro = request.POST.get('novo_quadro')
        
        if not militar_id or not novo_posto or not novo_quadro:
            return JsonResponse({'erro': 'Dados incompletos para promoção'}, status=400)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = novo_posto
            militar.quadro = novo_quadro
            
            # Aplicar nova numeração por promoção
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÓGICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2º Tenente
            if posto_anterior == 'ST' and novo_posto == '2T':
                from militares.models import FichaConceitoPracas, FichaConceitoOficiais
                
                # Verificar se existe ficha de praças
                ficha_pracas = militar.fichaconceitopracas_set.first()
                if ficha_pracas:
                    # Criar nova ficha de oficiais com os dados da ficha de praças
                    ficha_oficiais = FichaConceitoOficiais.objects.create(
                        militar=militar,
                        tempo_posto=ficha_pracas.tempo_posto,
                        cursos_especializacao=ficha_pracas.cursos_especializacao,
                        cursos_cfsd=ficha_pracas.cursos_cfsd,
                        cursos_chc=ficha_pracas.cursos_chc,
                        cursos_chsgt=ficha_pracas.cursos_chsgt,
                        cursos_cas=ficha_pracas.cursos_cas,
                        cursos_cho=ficha_pracas.cursos_cho,
                        cursos_civis_superior=ficha_pracas.cursos_civis_superior,
                        cursos_civis_especializacao=ficha_pracas.cursos_civis_especializacao,
                        cursos_civis_mestrado=ficha_pracas.cursos_civis_mestrado,
                        cursos_civis_doutorado=ficha_pracas.cursos_civis_doutorado,
                        medalha_federal=ficha_pracas.medalha_federal,
                        medalha_estadual=ficha_pracas.medalha_estadual,
                        medalha_cbmepi=ficha_pracas.medalha_cbmepi,
                        elogio_individual=ficha_pracas.elogio_individual,
                        elogio_coletivo=ficha_pracas.elogio_coletivo,
                        punicao_repreensao=ficha_pracas.punicao_repreensao,
                        punicao_detencao=ficha_pracas.punicao_detencao,
                        punicao_prisao=ficha_pracas.punicao_prisao,
                        falta_aproveitamento=ficha_pracas.falta_aproveitamento,
                        observacoes=f"Ficha convertida automaticamente da promoção de Subtenente para 2º Tenente. Original: {ficha_pracas.id}"
                    )
                    
                    # Remover a ficha de praças antiga
                    ficha_pracas.delete()
                    
                    # Atualizar a mensagem para incluir informação sobre a conversão
                    mensagem_adicional = " Ficha de conceito convertida de praças para oficiais."
                else:
                    mensagem_adicional = ""
            else:
                mensagem_adicional = ""
            
            # Salvar as alterações
            militar.save()
            
            return JsonResponse({
                'sucesso': True,
                'nova_numeracao': nova_numeracao,
                'mensagem': f'Promoção aplicada com sucesso! Nova numeração: {nova_numeracao}º. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            })
            
        except Militar.DoesNotExist:
            return JsonResponse({'erro': 'Militar não encontrado'}, status=404)
        except Exception as e:
            return JsonResponse({'erro': f'Erro ao aplicar promoção: {str(e)}'}, status=500)
    
    return JsonResponse({'erro': 'Método não permitido'}, status=405)

@login_required
def militar_inativo_list(request):
    """Lista militares inativos (transferidos, aposentados, exonerados)"""
    
    # Filtrar apenas militares inativos
    militares = Militar.objects.filter(
        situacao__in=['IN', 'TR', 'AP', 'EX']
    ).order_by('posto_graduacao', 'nome_completo')
    
    # Filtros
    situacao = request.GET.get('situacao')
    if situacao:
        militares = militares.filter(situacao=situacao)
    
    posto = request.GET.get('posto')
    if posto:
        militares = militares.filter(posto_graduacao=posto)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Busca por nome
    busca = request.GET.get('busca')
    if busca:
        militares = militares.filter(
            models.Q(nome_completo__icontains=busca) |
            models.Q(nome_guerra__icontains=busca) |
            models.Q(matricula__icontains=busca)
        )
    
    # Estatísticas
    total_inativos = militares.count()
    por_situacao = militares.values('situacao').annotate(
        count=models.Count('id')
    ).order_by('situacao')
    
    # Paginação
    paginator = Paginator(militares, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'militares': page_obj,
        'situacoes': SITUACAO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
        'filtros': {
            'situacao': situacao,
            'posto': posto,
            'quadro': quadro,
            'busca': busca
        },
        'estatisticas': {
            'total': total_inativos,
            'por_situacao': por_situacao
        }
    }
    
    return render(request, 'militares/militar_inativo_list.html', context)

@login_required
def militar_inativo_detail(request, pk):
    """Detalhes de um militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Verificar se é realmente inativo
    if militar.situacao not in ['IN', 'TR', 'AP', 'EX']:
        messages.warning(request, 'Este militar não está inativo.')
        return redirect('militares:militar_detail', pk=pk)
    
    # Buscar histórico de promoções
    promocoes = Promocao.objects.filter(militar=militar).order_by('-data_promocao')
    
    # Buscar fichas de conceito
    fichas_conceito = []
    try:
        ficha_oficiais = FichaConceitoOficiais.objects.get(militar=militar)
        fichas_conceito.append(ficha_oficiais)
    except FichaConceitoOficiais.DoesNotExist:
        pass
    
    try:
        ficha_pracas = FichaConceitoPracas.objects.get(militar=militar)
        fichas_conceito.append(ficha_pracas)
    except FichaConceitoPracas.DoesNotExist:
        pass
    
    # Buscar documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'promocoes': promocoes,
        'fichas_conceito': fichas_conceito,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_inativo_detail.html', context)

@login_required
def militar_transferir_inativo(request, pk):
    """Transferir militar para situação inativa"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nova_situacao = request.POST.get('nova_situacao')
        data_transferencia = request.POST.get('data_transferencia')
        motivo = request.POST.get('motivo')
        
        if nova_situacao and data_transferencia:
            try:
                # Validar data
                from datetime import datetime
                data_transferencia = datetime.strptime(data_transferencia, '%Y-%m-%d').date()
                
                # Atualizar situação do militar
                situacao_anterior = militar.situacao
                militar.situacao = nova_situacao
                militar.observacoes = f"{militar.observacoes or ''}\n\nTransferido para {militar.get_situacao_display()} em {data_transferencia.strftime('%d/%m/%Y')}. Motivo: {motivo}"
                militar.save()
                
                messages.success(request, f'Militar {militar.nome_completo} transferido para {militar.get_situacao_display()} com sucesso!')
                return redirect('militares:militar_inativo_detail', pk=militar.pk)
                
            except ValueError:
                messages.error(request, 'Data inválida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Todos os campos são obrigatórios.')
    
    context = {
        'militar': militar,
        'situacoes_inativas': [
            ('IN', 'Inativo'),
            ('TR', 'Transferido'),
            ('AP', 'Aposentado'),
            ('EX', 'Exonerado'),
        ]
    }
    
    return render(request, 'militares/militar_transferir_inativo.html', context)

@login_required
def militar_reativar(request, pk):
    """Reativar militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        
        if motivo:
            # Reativar militar
            militar.situacao = 'AT'
            militar.observacoes = f"{militar.observacoes or ''}\n\nReativado em {timezone.now().strftime('%d/%m/%Y %H:%M')}. Motivo: {motivo}"
            militar.save()
            
            messages.success(request, f'Militar {militar.nome_completo} reativado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Motivo é obrigatório.')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_reativar.html', context)

    class Meta:
        model = User
        fields = [
            'username', 'first_name', 'last_name', 'email',
            'is_active', 'is_staff', 'is_superuser', 'groups'
        ]
        widgets = {
            'username': forms.TextInput(attrs={'class': 'form-control'}),
            'first_name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': '🔍 Digite o nome do militar para buscar e preencher automaticamente...',
                'autocomplete': 'off'
            }),
            'last_name': forms.TextInput(attrs={'class': 'form-control'}),
            'email': forms.EmailInput(attrs={'class': 'form-control'}),
            'groups': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }
    
    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        
        # Se é uma criação de usuário (não tem instance.pk), senha é obrigatória
        if not self.instance.pk:
            if not password:
                raise forms.ValidationError('Senha é obrigatória para novos usuários.')
            if not confirm_password:
                raise forms.ValidationError('Confirmação de senha é obrigatória para novos usuários.')
        
        if password and confirm_password and password != confirm_password:
            raise forms.ValidationError('As senhas não coincidem.')
        
        return cleaned_data

@login_required
@permission_required('auth.add_user')
def usuario_create(request):
    """Criar novo usuário"""
    if request.method == 'POST':
        form = UsuarioForm(request.POST)
        if form.is_valid():
            usuario = form.save(commit=False)
            password = form.cleaned_data.get('password')
            if password:
                usuario.set_password(password)
            usuario.save()
            form.save_m2m()  # Salvar grupos
            
            # Associar militar se fornecido
            militar_id = form.cleaned_data.get('militar_id')
            if militar_id:
                try:
                    militar = Militar.objects.get(id=militar_id)
                    # Vincular militar ao usuário
                    militar.user = usuario
                    militar.save()
                    messages.success(request, f'Usuário "{usuario.username}" criado com sucesso e vinculado ao militar "{militar.nome_completo}"!')
                except Militar.DoesNotExist:
                    messages.warning(request, f'Usuário "{usuario.username}" criado com sucesso, mas militar não encontrado.')
            else:
                messages.success(request, f'Usuário "{usuario.username}" criado com sucesso!')
            
            return redirect('militares:usuarios_custom_list')
    else:
        form = UsuarioForm()
    
    context = {
        'form': form,
        'title': 'Criar Novo Usuário',
        'submit_text': 'Criar Usuário'
    }
    
    return render(request, 'militares/usuarios/form.html', context)

class GrupoForm(forms.ModelForm):
    """Formulário para criação/edição de grupos"""
    
    class Meta:
        model = Group
        fields = ['name', 'permissions']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'permissions': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }

@login_required
@permission_required('auth.view_user')
def dashboard_permissoes(request):
    """Dashboard com estatísticas do sistema de permissões"""
    
    # Estatísticas básicas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    total_grupos = Group.objects.count()
    grupos_com_usuarios = Group.objects.filter(user__isnull=False).distinct().count()
    total_permissoes = Permission.objects.count()
    permissoes_utilizadas = Permission.objects.filter(group__isnull=False).distinct().count()
    
    # Aplicações e modelos
    content_types = ContentType.objects.all()
    total_apps = content_types.values('app_label').distinct().count()
    modelos_por_app = content_types.count()
    
    # Estatísticas por grupo
    grupos_estatisticas = {}
    grupos_nomes = {
        'admin': 'Administrador - Acesso total',
        'superusuario': 'Super Usuário - Acesso total',
        'membro_cpo': 'Membro CPO - Acesso a oficiais e comissões',
        'membro_cpp': 'Membro CPP - Acesso a praças e comissões',
        'comandante_geral': 'Comandante Geral - Acesso total exceto usuários e administração',
        'subcomandante_geral': 'Subcomandante Geral - Acesso total exceto usuários e administração',
        'diretor_gestao_pessoas': 'Diretor de Gestão de Pessoas - Acesso total exceto usuários e administração',
        'chefe_secao_promocoes': 'Chefe da Seção de Promoções - Acesso total exceto usuários e administração',
        'digitador': 'Digitador - Acesso total sem exclusão e sem usuários/administração',
        'usuario': 'Usuário - Acesso a documentos específicos e visualização'
    }
    
    for codigo, nome in grupos_nomes.items():
        try:
            grupo = Group.objects.get(name=nome)
            usuarios_count = grupo.user_set.count()
            permissoes_count = grupo.permissions.count()
            grupos_estatisticas[codigo] = {
                'usuarios': usuarios_count,
                'permissoes': permissoes_count
            }
        except Group.DoesNotExist:
            grupos_estatisticas[codigo] = {
                'usuarios': 0,
                'permissoes': 0
            }
    
    # Atividades recentes (simuladas)
    recent_activities = [
        {
            'icon': 'shield-alt',
            'title': 'Sistema de permissões simplificado',
            'description': 'Configuração de permissões por níveis de acesso concluída',
            'time': '5 minutos atrás'
        },
        {
            'icon': 'users-cog',
            'title': 'Grupos criados',
            'description': '10 grupos de permissões foram configurados',
            'time': '10 minutos atrás'
        },
        {
            'icon': 'key',
            'title': 'Permissões atribuídas',
            'description': 'Sistema de permissões organizado por níveis',
            'time': '15 minutos atrás'
        }
    ]
    
    context = {
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'total_grupos': total_grupos,
        'grupos_com_usuarios': grupos_com_usuarios,
        'total_permissoes': total_permissoes,
        'permissoes_utilizadas': permissoes_utilizadas,
        'total_apps': total_apps,
        'modelos_por_app': modelos_por_app,
        'recent_activities': recent_activities,
        # Estatísticas por grupo
        'admin_users': grupos_estatisticas.get('admin', {}).get('usuarios', 0),
        'admin_permissions': grupos_estatisticas.get('admin', {}).get('permissoes', 88),
        'super_users': grupos_estatisticas.get('superusuario', {}).get('usuarios', 0),
        'super_permissions': grupos_estatisticas.get('superusuario', {}).get('permissoes', 88),
        'cpo_users': grupos_estatisticas.get('membro_cpo', {}).get('usuarios', 0),
        'cpo_permissions': grupos_estatisticas.get('membro_cpo', {}).get('permissoes', 44),
        'cpp_users': grupos_estatisticas.get('membro_cpp', {}).get('usuarios', 0),
        'cpp_permissions': grupos_estatisticas.get('membro_cpp', {}).get('permissoes', 44),
        'comandante_users': grupos_estatisticas.get('comandante_geral', {}).get('usuarios', 0),
        'comandante_permissions': grupos_estatisticas.get('comandante_geral', {}).get('permissoes', 76),
        'subcomandante_users': grupos_estatisticas.get('subcomandante_geral', {}).get('usuarios', 0),
        'subcomandante_permissions': grupos_estatisticas.get('subcomandante_geral', {}).get('permissoes', 76),
        'diretor_users': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('usuarios', 0),
        'diretor_permissions': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('permissoes', 76),
        'chefe_users': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('usuarios', 0),
        'chefe_permissions': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('permissoes', 76),
        'digitador_users': grupos_estatisticas.get('digitador', {}).get('usuarios', 0),
        'digitador_permissions': grupos_estatisticas.get('digitador', {}).get('permissoes', 57),
        'usuario_users': grupos_estatisticas.get('usuario', {}).get('usuarios', 0),
        'usuario_permissions': grupos_estatisticas.get('usuario', {}).get('permissoes', 2),
    }
    
    return render(request, 'militares/usuarios/dashboard.html', context)

@login_required
def meus_votos_list(request):
    """Lista todos os votos do usuário logado"""
    # Verificar se o usuário é membro de alguma comissão
    membros_usuario = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True
    )
    
    if not membros_usuario.exists():
        messages.warning(request, 'Você não é membro de nenhuma comissão ativa.')
        return redirect('militares:comissao_list')
    
    # Buscar todos os votos do usuário
    votos = VotoDeliberacao.objects.filter(
        membro__usuario=request.user,
        membro__ativo=True
    ).select_related(
        'deliberacao__sessao__comissao',
        'membro__militar'
    ).order_by('-data_registro')
    
    # Calcular estatísticas
    total_votos = votos.count()
    votos_favor = votos.filter(voto='FAVOR').count()
    votos_contra = votos.filter(voto='CONTRA').count()
    votos_abstencao = votos.filter(voto='ABSTENCAO').count()
    
    context = {
        'votos': votos,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
        'title': 'Meus Votos',
    }
    return render(request, 'militares/comissao/deliberacoes/meus_votos_list.html', context)

@login_required
def meu_voto_detail(request, pk):
    """Visualizar detalhes de um voto específico do usuário"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto não encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuário logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'Você não tem permissão para visualizar este voto.')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Voto - Deliberação {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_detail.html', context)

@login_required
def meu_voto_update(request, pk):
    """Editar um voto específico do usuário"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto não encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuário logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'Você não tem permissão para editar este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessão ainda está aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'Não é possível editar votos de sessões finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Obter dados do voto
        novo_voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        senha_votante = request.POST.get('senha_votante')
        
        # Validar senha
        if not senha_votante:
            messages.error(request, 'Senha é obrigatória para confirmar a edição do voto.')
            
            # Criar formulário para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que você proferiu durante a sessão...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        # Validar senha do usuário
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            
            # Criar formulário para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que você proferiu durante a sessão...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        if not novo_voto:
            messages.error(request, 'Você deve escolher uma opção de voto.')
            
            # Criar formulário para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que você proferiu durante a sessão...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        # Atualizar voto
        voto.voto = novo_voto
        voto.voto_proferido = voto_proferido
        # Limpar assinatura eletrônica ao editar o voto
        voto.assinado = False
        voto.data_assinatura = None
        voto.funcao_assinatura = ''
        voto.tipo_assinatura = ''
        voto.observacoes_assinatura = ''
        voto.save()
        
        # Atualizar contadores da deliberação
        votos_favor = voto.deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = voto.deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = voto.deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        voto.deliberacao.votos_favor = votos_favor
        voto.deliberacao.votos_contra = votos_contra
        voto.deliberacao.votos_abstencao = votos_abstencao
        voto.deliberacao.save()
        
        messages.success(request, f'✅ Voto atualizado com sucesso!')
        return redirect('militares:voto_visualizar_assinar', pk=voto.pk)
    
    # Criar formulário para o voto proferido com CKEditor 5 (mesmo das atas)
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que você proferiu durante a sessão...',
                    'class': 'ckeditor5',
                    'data-config-name': 'voto_proferido_config'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto.voto_proferido
    })
    
    context = {
        'voto': voto,
        'form': form,
        'title': f'Editar Voto - Deliberação {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)

@login_required
def meu_voto_delete(request, pk):
    """Excluir um voto específico do usuário"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto não encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuário logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'Você não tem permissão para excluir este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessão ainda está aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'Não é possível excluir votos de sessões finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Salvar referências antes de excluir
        deliberacao = voto.deliberacao
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberação
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, '✅ Voto excluído com sucesso!')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Excluir Voto - Deliberação {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_confirm_delete.html', context)

@login_required
def status_efetivo_vagas(request):
    """Mostra o status do efetivo atual e permite atualização manual das vagas"""
    from .signals import atualizar_todas_vagas_efetivo
    
    # Contar militares por posto e quadro
    efetivo_por_posto_quadro = {}
    militares_ativos = Militar.objects.filter(situacao='AT')
    
    for militar in militares_ativos:
        key = f"{militar.get_posto_graduacao_display()} - {militar.get_quadro_display()}"
        if key not in efetivo_por_posto_quadro:
            efetivo_por_posto_quadro[key] = {
                'posto': militar.posto_graduacao,
                'quadro': militar.quadro,
                'efetivo_atual': 0,
                'militares': []
            }
        efetivo_por_posto_quadro[key]['efetivo_atual'] += 1
        efetivo_por_posto_quadro[key]['militares'].append(militar)
    
    # Buscar vagas existentes
    vagas = Vaga.objects.all().order_by('posto', 'quadro')
    vagas_dict = {}
    for vaga in vagas:
        key = f"{vaga.get_posto_display()} - {vaga.get_quadro_display()}"
        vagas_dict[key] = vaga
    
    # Buscar previsões existentes
    previsoes = PrevisaoVaga.objects.filter(ativo=True).order_by('posto', 'quadro')
    previsoes_dict = {}
    for previsao in previsoes:
        key = f"{previsao.get_posto_display()} - {previsao.get_quadro_display()}"
        previsoes_dict[key] = previsao
    
    # Processar atualização se solicitado
    if request.method == 'POST' and 'atualizar_efetivo' in request.POST:
        try:
            resultado = atualizar_todas_vagas_efetivo()
            messages.success(
                request, 
                f"Efetivo atualizado com sucesso! "
                f"Militares processados: {resultado['militares_processados']}, "
                f"Vagas criadas: {resultado['vagas_criadas']}, "
                f"Vagas atualizadas: {resultado['vagas_atualizadas']}, "
                f"Previsões atualizadas: {resultado['previsoes_atualizadas']}"
            )
            return redirect('militares:status_efetivo_vagas')
        except Exception as e:
            messages.error(request, f"Erro ao atualizar efetivo: {str(e)}")
    
    context = {
        'efetivo_por_posto_quadro': efetivo_por_posto_quadro,
        'vagas_dict': vagas_dict,
        'previsoes_dict': previsoes_dict,
        'total_militares_ativos': militares_ativos.count(),
        'total_vagas': vagas.count(),
        'total_previsoes': previsoes.count(),
    }
    
    return render(request, 'militares/status_efetivo_vagas.html', context)

@login_required
def reordenar_antiguidade_apos_inativacao(request):
    """View para reordenar numerações de antiguidade após inativações"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        
        try:
            # Executar reordenação
            total_reordenados = Militar.reordenar_todos_apos_inativacao(
                posto_graduacao=posto if posto else None,
                quadro=quadro if quadro else None
            )
            
            messages.success(
                request, 
                f'Reordenação concluída com sucesso! {total_reordenados} militares foram reordenados.'
            )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:status_efetivo_vagas')
    
    # GET - mostrar formulário
    context = {
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/reordenar_antiguidade_apos_inativacao.html', context)

@login_required
def promocao_subtenente_view(request):
    """View específica para promoção de subtenentes do quadro praças para complementar"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        data_promocao = request.POST.get('data_promocao')
        
        if not militar_id or not data_promocao:
            messages.error(request, 'Militar e data de promoção são obrigatórios.')
            return redirect('militares:militar_list')
        
        try:
            from datetime import datetime
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoção inválida.')
            return redirect('militares:militar_list')
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se é subtenente do quadro praças
            if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
                messages.error(request, 'Apenas subtenentes do quadro praças podem ser promovidos.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Verificar se está apto para promoção
            if not militar.apto_promocao_antiguidade():
                messages.error(request, 'Militar não está apto para promoção. Verifique inspeção de saúde, interstício e cursos obrigatórios.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = '2T'  # 2º Tenente
            militar.quadro = 'COMP'  # Complementar
            militar.data_promocao_atual = data_promocao
            
            # Aplicar nova numeração por promoção
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÓGICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2º Tenente
            ficha_oficiais, mensagem_conversao = militar.converter_ficha_pracas_para_oficiais(
                motivo_conversao="Promoção de Subtenente para 2º Tenente"
            )
            
            if ficha_oficiais:
                mensagem_adicional = " Ficha de conceito convertida de praças para oficiais."
            else:
                mensagem_adicional = f" {mensagem_conversao}"
            
            # Salvar as alterações
            militar.save()
            
            # Registrar a promoção no histórico
            from militares.models import Promocao
            Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo='2T',
                criterio='ANTIGUIDADE',
                data_promocao=data_promocao,
                data_publicacao=data_promocao,
                numero_ato='Promoção automática via sistema',
                observacoes=f'Promoção de Subtenente (Praças) para 2º Tenente (Complementar). Nova numeração: {nova_numeracao}º.{mensagem_adicional}'
            )
            
            messages.success(
                request, 
                f'Promoção realizada com sucesso! {militar.nome_completo} foi promovido de Subtenente (Praças) para 2º Tenente (Complementar) com a {nova_numeracao}ª numeração de antiguidade. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            )
            
            return redirect('militares:militar_detail', pk=militar_id)
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar não encontrado.')
            return redirect('militares:militar_list')
        except Exception as e:
            messages.error(request, f'Erro ao realizar promoção: {str(e)}')
            return redirect('militares:militar_detail', pk=militar_id)
    
    # GET - mostrar formulário de promoção
    militar_id = request.GET.get('militar_id')
    if not militar_id:
        messages.error(request, 'ID do militar é obrigatório.')
        return redirect('militares:militar_list')
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se é subtenente do quadro praças
        if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
            messages.error(request, 'Apenas subtenentes do quadro praças podem ser promovidos.')
            return redirect('militares:militar_detail', pk=militar_id)
        
        # Verificar se está apto para promoção
        apto_promocao = militar.apto_promocao_antiguidade()
        
        # Calcular próxima data de promoção
        from datetime import date
        hoje = date.today()
        proxima_data = date(hoje.year, 7, 18) if hoje < date(hoje.year, 7, 18) else date(hoje.year, 12, 25)
        
        context = {
            'militar': militar,
            'apto_promocao': apto_promocao,
            'proxima_data': proxima_data,
        }
        
        return render(request, 'militares/promocao_subtenente.html', context)
        
    except Militar.DoesNotExist:
        messages.error(request, 'Militar não encontrado.')
        return redirect('militares:militar_list')

@login_required
@administracao_required
def usuarios_custom_list(request):
    # Parâmetros de filtro
    query = request.GET.get('q', '').strip()
    status = request.GET.get('status', '')
    grupo = request.GET.get('grupo', '')
    ordenacao = request.GET.get('ordenacao', 'nome')
    
    # Query base
    usuarios = User.objects.all().select_related('militar').prefetch_related('groups', 'funcoes')
    
    # Aplicar filtros
    if query:
        usuarios = usuarios.filter(
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query) |
            Q(email__icontains=query) |
            Q(militar__nome_completo__icontains=query)
        )
    
    if status == 'ativo':
        usuarios = usuarios.filter(is_active=True)
    elif status == 'inativo':
        usuarios = usuarios.filter(is_active=False)
    
    if grupo:
        usuarios = usuarios.filter(groups__name__icontains=grupo)
    
    # Aplicar ordenação
    if ordenacao == 'nome':
        usuarios = usuarios.order_by('first_name', 'last_name')
    elif ordenacao == 'username':
        usuarios = usuarios.order_by('username')
    elif ordenacao == 'email':
        usuarios = usuarios.order_by('email')
    elif ordenacao == 'data_criacao':
        usuarios = usuarios.order_by('-date_joined')
    elif ordenacao == 'status':
        usuarios = usuarios.order_by('-is_active', 'first_name')
    else:
        usuarios = usuarios.order_by('first_name', 'last_name')
    
    # Buscar militar e funções/cargos
    usuarios_info = []
    for usuario in usuarios:
        militar = getattr(usuario, 'militar', None)
        funcoes_militar = []
        if militar:
            membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
            funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
        
        # Funções diretas do usuário
        funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
        
        usuarios_info.append({
            'usuario': usuario,
            'militar': militar,
            'funcoes_militar': funcoes_militar,
            'funcoes_usuario': funcoes_usuario,
        })
    
    # Estatísticas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    usuarios_inativos = User.objects.filter(is_active=False).count()
    
    # Grupos disponíveis para filtro
    grupos_disponiveis = Group.objects.all().order_by('name')
    
    context = {
        'usuarios_info': usuarios_info,
        'query': query,
        'status': status,
        'grupo': grupo,
        'ordenacao': ordenacao,
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'usuarios_inativos': usuarios_inativos,
        'grupos_disponiveis': grupos_disponiveis,
        'resultados_count': len(usuarios_info),
    }
    return render(request, 'militares/usuarios/custom_list.html', context)

@login_required
@permission_required('auth.view_user')
def usuario_detail(request, pk):
    """Detalhes de um usuário"""
    usuario = get_object_or_404(User, pk=pk)
    
    # Buscar militar vinculado
    militar = getattr(usuario, 'militar', None)
    funcoes_militar = []
    
    if militar:
        membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
        funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
    
    # Funções diretas do usuário
    funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
    
    # Permissões do usuário
    permissoes_usuario = usuario.user_permissions.all()
    permissoes_grupos = []
    for grupo in usuario.groups.all():
        permissoes_grupo = grupo.permissions.all()
        permissoes_grupos.extend(permissoes_grupo)
    permissoes_grupos = list(set(permissoes_grupos))
    
    context = {
        'usuario': usuario,
        'militar': militar,
        'funcoes_militar': funcoes_militar,
        'funcoes_usuario': funcoes_usuario,
        'permissoes_usuario': permissoes_usuario,
        'permissoes_grupos': permissoes_grupos,
    }
    return render(request, 'militares/usuarios/detail.html', context)

# Views para gerenciamento de permissões

@login_required
@permission_required('auth.change_user')
def usuario_update(request, pk):
    """Editar um usuário"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        # Formulário simples para editar dados básicos
        first_name = request.POST.get('first_name', '')
        last_name = request.POST.get('last_name', '')
        email = request.POST.get('email', '')
        is_active = request.POST.get('is_active') == 'on'
        
        usuario.first_name = first_name
        usuario.last_name = last_name
        usuario.email = email
        usuario.is_active = is_active
        usuario.save()
        
        messages.success(request, f'Usuário {usuario.get_full_name()} atualizado com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/update.html', context)

@login_required
@permission_required('auth.delete_user')
def usuario_delete(request, pk):
    """Excluir um usuário"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        nome_usuario = usuario.get_full_name()
        usuario.delete()
        messages.success(request, f'Usuário {nome_usuario} excluído com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/delete.html', context)

# Views para gerenciar funções dos usuários
@login_required
@permission_required('auth.view_user')
def usuario_funcoes_list(request, pk):
    """Lista todas as funções de um usuário"""
    usuario = get_object_or_404(User, pk=pk)
    funcoes = usuario.funcoes.all().order_by('-data_inicio')
    
    # Estatísticas
    funcoes_ativas = funcoes.filter(status='AT')
    funcoes_inativas = funcoes.filter(status='INATIVO')
    funcoes_suspensas = funcoes.filter(status='SUSPENSO')
    
    context = {
        'usuario': usuario,
        'funcoes': funcoes,
        'funcoes_ativas': funcoes_ativas,
        'funcoes_inativas': funcoes_inativas,
        'funcoes_suspensas': funcoes_suspensas,
    }
    return render(request, 'militares/usuarios/funcoes/list.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_add(request, pk):
    """Adiciona uma nova função ao usuário"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST)
        if form.is_valid():
            # Verificar se já existe uma função com a mesma combinação
            cargo_funcao = form.cleaned_data['cargo_funcao']
            data_inicio = form.cleaned_data['data_inicio']
            
            funcao_existente = UsuarioFuncao.objects.filter(
                usuario=usuario,
                cargo_funcao=cargo_funcao,
                data_inicio=data_inicio
            ).first()
            
            if funcao_existente:
                messages.error(request, f'Já existe uma função "{cargo_funcao.nome}" para este usuário com a data de início {data_inicio}.')
                context = {
                    'form': form,
                    'usuario': usuario,
                }
                return render(request, 'militares/usuarios/funcoes/form.html', context)
            
            funcao = form.save(commit=False)
            funcao.usuario = usuario
            funcao.save()
            messages.success(request, f'Função "{funcao.cargo_funcao.nome}" adicionada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(initial={'usuario': usuario})
    
    context = {
        'form': form,
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_edit(request, pk, funcao_pk):
    """Edita uma função do usuário"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST, instance=funcao)
        if form.is_valid():
            form.save()
            messages.success(request, f'Função "{funcao.cargo_funcao.nome}" atualizada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(instance=funcao)
    
    context = {
        'form': form,
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_delete(request, pk, funcao_pk):
    """Remove uma função do usuário"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        nome_funcao = funcao.cargo_funcao.nome
        
        # Verificar se a função excluída é a mesma que está na sessão do usuário
        funcao_na_sessao = request.session.get('funcao_atual_id')
        if funcao_na_sessao and int(funcao_na_sessao) == funcao_pk:
            # Se for a função da sessão, limpar a sessão antes de excluir
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
        
        cargo_id = funcao.cargo_funcao.id
        funcao.delete()
        messages.success(request, f'Função "{nome_funcao}" removida com sucesso!')
        return redirect('militares:cargo_funcao_detail', cargo_id=cargo_id)
    
    context = {
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/delete.html', context)

# Views para seleção de função após login
def selecionar_funcao(request):
    """
    View para selecionar função/cargo após login
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funções ativas do usuário
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    # Se só tem uma função, seleciona automaticamente
    if funcoes_usuario.count() == 1:
        funcao = funcoes_usuario.first()
        request.session['funcao_atual_id'] = funcao.id
        request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
        request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
        messages.success(request, f'Função selecionada automaticamente: {funcao.cargo_funcao.nome}')
        return redirect('militares:militar_dashboard')
    
    # Se não tem funções, redireciona para erro
    if funcoes_usuario.count() == 0:
        messages.error(request, 'Você não possui funções ativas no sistema.')
        return redirect('logout')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'Função selecionada: {funcao.cargo_funcao.nome}')
                return redirect('militares:militar_dashboard')
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'Função inválida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/selecionar_funcao.html', context)

def trocar_funcao(request):
    """
    View para trocar função durante a sessão
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funções ativas do usuário
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'Função alterada para: {funcao.cargo_funcao.nome}')
                return redirect(request.POST.get('next', 'militares:militar_dashboard'))
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'Função inválida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
        'funcao_atual_id': request.session.get('funcao_atual_id'),
        'next': request.GET.get('next', 'militares:militar_dashboard'),
    }
    return render(request, 'militares/usuarios/trocar_funcao.html', context)

def obter_funcao_atual(request):
    """
    Função helper para obter a função atual da sessão
    """
    if not request.user.is_authenticated:
        return None
    
    funcao_id = request.session.get('funcao_atual_id')
    if funcao_id:
        try:
            return UsuarioFuncao.objects.get(id=funcao_id, usuario=request.user)
        except UsuarioFuncao.DoesNotExist:
            # Se a função não existe mais, limpa a sessão
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
    
    return None

@login_required
@csrf_protect
def alterar_senha(request):
    """View para alterar senha do usuário logado"""
    if request.method == 'POST':
        form = AlterarSenhaForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            # Atualizar a sessão para não deslogar o usuário
            update_session_auth_hash(request, form.user)
            messages.success(request, '✅ Senha alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=request.user.pk)
    else:
        form = AlterarSenhaForm(request.user)
    
    context = {
        'form': form,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/alterar_senha.html', context)

@login_required
@permission_required('auth.change_user')
def alterar_senha_usuario(request, pk):
    """View para administradores alterarem senha de outros usuários"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = AlterarSenhaAdminForm(usuario, request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, f'✅ Senha do usuário {usuario.get_full_name()} alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=usuario.pk)
    else:
        form = AlterarSenhaAdminForm(usuario)
    
    context = {
        'form': form,
        'usuario': usuario,
        'usuario_alvo': usuario,
    }
    return render(request, 'militares/usuarios/alterar_senha_admin.html', context)

class AlterarSenhaForm(forms.Form):
    """Formulário para alterar senha"""
    senha_atual = forms.CharField(
        label='Senha Atual',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite sua senha atual'
        }),
        strip=False
    )
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean_senha_atual(self):
        senha_atual = self.cleaned_data.get('senha_atual')
        if not self.user.check_password(senha_atual):
            raise forms.ValidationError('Senha atual incorreta.')
        return senha_atual

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas não coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user

class AlterarSenhaAdminForm(forms.Form):
    """Formulário para administradores alterarem senha de outros usuários"""
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas não coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user

@login_required
def cargo_funcao_delete(request, cargo_id):
    """
    Exclui um cargo/função e todas as suas relações
    - Remove todas as funções de usuários vinculadas
    - Remove todas as permissões vinculadas
    - Exclui o cargo/função
    """
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    erro_protegido = False
    
    # Buscar todas as relações
    usuarios_com_funcao = UsuarioFuncao.objects.filter(cargo_funcao=cargo)
    permissoes_vinculadas = PermissaoFuncao.objects.filter(cargo_funcao=cargo)
    
    if request.method == 'POST':
        try:
            # Contadores para feedback
            usuarios_removidos = 0
            permissoes_removidas = 0
            
            # 1. Remover todas as funções de usuários vinculadas
            if usuarios_com_funcao.exists():
                usuarios_removidos = usuarios_com_funcao.count()
                usuarios_com_funcao.delete()
                messages.warning(request, f'{usuarios_removidos} função(ões) de usuário(s) removida(s) automaticamente.')
            
            # 2. Remover todas as permissões vinculadas
            if permissoes_vinculadas.exists():
                permissoes_removidas = permissoes_vinculadas.count()
                permissoes_vinculadas.delete()
                messages.warning(request, f'{permissoes_removidas} permissão(ões) removida(s) automaticamente.')
            
            # 3. Excluir o cargo/função
            nome_cargo = cargo.nome
            cargo.delete()
            
            # Mensagem de sucesso
            if usuarios_removidos > 0 or permissoes_removidas > 0:
                messages.success(request, f'Cargo/Função "{nome_cargo}" excluído com sucesso! {usuarios_removidos} função(ões) de usuário(s) e {permissoes_removidas} permissão(ões) foram removidas automaticamente.')
            else:
                messages.success(request, f'Cargo/Função "{nome_cargo}" excluído com sucesso!')
            
            return redirect('militares:cargo_funcao_list')
            
        except Exception as e:
            erro_protegido = True
            messages.error(request, f'Erro ao excluir cargo/função: {str(e)}')
    
    context = {
        'cargo': cargo,
        'erro_protegido': erro_protegido,
        'usuarios_com_funcao': usuarios_com_funcao,
        'permissoes_vinculadas': permissoes_vinculadas,
        'total_usuarios': usuarios_com_funcao.count(),
        'total_permissoes': permissoes_vinculadas.count(),
    }
    return render(request, 'militares/cargos/cargo_funcao_confirm_delete.html', context)

from django.contrib.auth.models import Group, Permission
from django.contrib.auth.decorators import login_required, permission_required
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages

@login_required
def buscar_funcao_militar(request):
    """Busca a função/cargo do militar para preenchimento automático"""
    militar_id = request.GET.get('militar_id')
    
    if not militar_id:
        return JsonResponse({'error': 'ID do militar não fornecido'}, status=400)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Buscar função do militar através do usuário vinculado
        funcao_militar = None
        if militar.user:
            # Buscar função ativa do usuário
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='ATIVO'
            ).select_related('cargo_funcao').first()
            
            if funcao_usuario:
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        # Se não encontrou função via usuário, buscar todas as funções do usuário
        if not funcao_militar and militar.user:
            # Buscar todas as funções ativas do usuário
            funcoes_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='AT'
            ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
            
            if funcoes_usuario.exists():
                # Se há múltiplas funções, retornar a primeira como padrão
                funcao_usuario = funcoes_usuario.first()
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        return JsonResponse({
            'success': True,
            'funcao': funcao_militar,
            'militar': {
                'id': militar.id,
                'nome': militar.nome_completo,
                'posto': militar.get_posto_graduacao_display(),
                'matricula': militar.matricula
            }
        })
        
    except Militar.DoesNotExist:
        return JsonResponse({'error': 'Militar não encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar função: {str(e)}'}, status=500)

@login_required
def buscar_funcoes_usuario(request):
    """Busca as funções/cargos do usuário para permitir escolha"""
    usuario_id = request.GET.get('usuario_id')
    
    if not usuario_id:
        return JsonResponse({'error': 'ID do usuário não fornecido'}, status=400)
    
    try:
        usuario = User.objects.get(pk=usuario_id)
        
        # Buscar todas as funções ativas do usuário
        funcoes_usuario = UsuarioFuncao.objects.filter(
            usuario=usuario,
            status='AT'
        ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
        
        funcoes = []
        for funcao in funcoes_usuario:
            funcoes.append({
                'id': funcao.cargo_funcao.id,
                'nome': funcao.cargo_funcao.nome,
                'tipo': funcao.get_tipo_funcao_display(),
                'descricao': funcao.cargo_funcao.descricao or '',
                'data_inicio': funcao.data_inicio.strftime('%d/%m/%Y'),
                'data_fim': funcao.data_fim.strftime('%d/%m/%Y') if funcao.data_fim else None
            })
        
        return JsonResponse({
            'success': True,
            'funcoes': funcoes,
            'usuario': {
                'id': usuario.id,
                'nome': usuario.get_full_name(),
                'username': usuario.username
            }
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'Usuário não encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar funções: {str(e)}'}, status=500)

@login_required
def voto_deliberacao_delete(request, voto_pk):
    """Excluir voto de uma deliberação"""
    try:
        voto = VotoDeliberacao.objects.get(pk=voto_pk)
        deliberacao = voto.deliberacao
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto não encontrado.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuário logado é o autor do voto ou tem permissão
    if voto.membro.usuario != request.user:
        messages.error(request, 'Você não tem permissão para excluir este voto.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha é obrigatória para confirmar a exclusão.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Validar senha do usuário
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberação
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, '✅ Voto excluído com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    context = {
        'voto': voto,
        'deliberacao': deliberacao,
        'sessao': sessao,
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_delete.html', context)

@login_required
def assinar_ata_eletronica(request, pk):
    """Processar assinatura eletrônica da ata"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'Método não permitido'})
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuário é membro da comissão
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'Você não é membro desta comissão.'
            })
        
        # Buscar a ata da sessão
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Ata não encontrada para esta sessão.'
            })
        
        # Verificar se a ata está para assinatura
        if ata.status != 'PARA_ASSINATURA':
            return JsonResponse({
                'success': False,
                'error': 'Ata não está disponível para assinatura.'
            })
        
        # Processar dados da assinatura
        import json
        dados = json.loads(request.body)
        
        hash_documento = dados.get('hash')
        timestamp = dados.get('timestamp')
        assinatura_digital = dados.get('assinatura')
        certificado = dados.get('certificado')
        assinante = dados.get('assinante')
        data_assinatura = dados.get('data_assinatura')
        
        # Validar dados obrigatórios (certificado pode ser 'ASSINATURA_SIMPLES_SEI' para assinatura simples)
        if not all([hash_documento, timestamp, assinatura_digital, assinante]):
            return JsonResponse({
                'success': False,
                'error': 'Dados de assinatura incompletos.'
            })
        
        # Criar registro de assinatura
        from .models import AssinaturaAta
        
        # Buscar o membro da comissão
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
        
        # Capturar a função atual do usuário na sessão
        funcao_atual = request.session.get('funcao_atual_nome', 'Usuário do Sistema')
        
        # Verificar se já existe uma assinatura para este membro nesta ata
        assinatura_criada = False
        try:
            assinatura = AssinaturaAta.objects.get(ata=ata, membro=membro)
            # Atualizar a assinatura existente com os novos dados eletrônicos
            assinatura.hash_documento = hash_documento
            assinatura.timestamp = timestamp
            assinatura.assinatura_digital = assinatura_digital
            assinatura.certificado = certificado or 'ASSINATURA_SIMPLES_SEI'
            assinatura.ip_assinatura = request.META.get('REMOTE_ADDR', '')
            assinatura.user_agent = request.META.get('HTTP_USER_AGENT', '')
            assinatura.assinado_por = request.user
            assinatura.funcao_assinatura = funcao_atual
            assinatura.save()
        except AssinaturaAta.DoesNotExist:
            # Criar nova assinatura
            assinatura = AssinaturaAta.objects.create(
                ata=ata,
                membro=membro,
                assinado_por=request.user,
                hash_documento=hash_documento,
                timestamp=timestamp,
                assinatura_digital=assinatura_digital,
                certificado=certificado or 'ASSINATURA_SIMPLES_SEI',
                ip_assinatura=request.META.get('REMOTE_ADDR', ''),
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                funcao_assinatura=funcao_atual
            )
            assinatura_criada = True
        
        # Verificar se todos os membros presentes assinaram
        membros_presentes = sessao.presencas.filter(presente=True)
        assinaturas_realizadas = AssinaturaAta.objects.filter(ata=ata)
        
        if assinaturas_realizadas.count() >= membros_presentes.count():
            # Todos assinaram, marcar ata como assinada
            ata.status = 'ASSINADA'
            ata.save()
            
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Ata marcada como assinada.',
                'ata_status': 'ASSINADA'
            })
        else:
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Aguardando outras assinaturas.',
                'ata_status': 'PARA_ASSINATURA',
                'assinaturas_restantes': membros_presentes.count() - assinaturas_realizadas.count()
            })
        
    except SessaoComissao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Sessão não encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao processar assinatura: {str(e)}'
        })

@login_required
def ata_assinaturas_eletronicas(request, pk):
    """Página para visualizar assinaturas eletrônicas da ata no formato SEI"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuário é membro da comissão
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'Você não é membro desta comissão.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar a ata da sessão
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            messages.error(request, 'Ata não encontrada para esta sessão.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar assinaturas eletrônicas
        assinaturas = AssinaturaAta.objects.filter(ata=ata).order_by('data_assinatura')
        
        context = {
            'sessao': sessao,
            'comissao': sessao.comissao,
            'ata': ata,
            'assinaturas': assinaturas,
            'membro_usuario': membro,
        }
        
        return render(request, 'militares/comissao/sessoes/ata_assinaturas_eletronicas.html', context)
        
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'Sessão não encontrada.')
        return redirect('militares:comissao_list')
    except Exception as e:
        messages.error(request, f'Erro ao carregar assinaturas: {str(e)}')
        return redirect('militares:sessao_comissao_detail', pk=pk)

@login_required
def quadro_fixacao_vagas_visualizar_html(request, pk):
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    
    # Verificar se o usuário é membro de alguma comissão e tem permissão para visualizar este quadro
    # Superusuários e staff têm acesso total, independente de serem membros de comissão
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'Você não tem permissão para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'Você não tem permissão para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    # Agrupar itens por quadro e ordenar por hierarquia
    itens_por_quadro = {}
    for item in quadro.itens.all().select_related('previsao_vaga'):
        quadro_nome = item.previsao_vaga.quadro
        if quadro_nome not in itens_por_quadro:
            itens_por_quadro[quadro_nome] = []
        itens_por_quadro[quadro_nome].append(item)
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # Capitão
        '1T': 5,   # 1º Tenente
        '2T': 6,   # 2º Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de Adaptação
        'ST': 9,   # Subtenente
        '1S': 10,  # 1º Sargento
        '2S': 11,  # 2º Sargento
        '3S': 12,  # 3º Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
    }
    
    # Ordenar itens por hierarquia (posto) dentro de cada quadro
    for quadro_nome in itens_por_quadro:
        itens_por_quadro[quadro_nome].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequência hierárquica: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    itens_por_quadro_ordenado = {}
    
    # Primeiro, adicionar os quadros na ordem hierárquica
    for cod_quadro in ordem_quadros:
        if cod_quadro in itens_por_quadro:
            itens_por_quadro_ordenado[cod_quadro] = itens_por_quadro[cod_quadro]
    
    # Depois, adicionar outros quadros que possam existir
    for cod_quadro, itens in itens_por_quadro.items():
        if cod_quadro not in itens_por_quadro_ordenado:
            itens_por_quadro_ordenado[cod_quadro] = itens
    
    itens_por_quadro = itens_por_quadro_ordenado
    
    # Obter funções do usuário para o modal de assinatura
    funcoes_usuario = request.user.funcoes.all() if hasattr(request.user, 'funcoes') else []
    
    context = {
        'quadro': quadro,
        'assinaturas': assinaturas,
        'funcoes_usuario': funcoes_usuario,
        'itens_por_quadro': itens_por_quadro,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/visualizar.html', context)

@login_required
def ata_assinar_melhorada(request, pk):
    """Assinar ata seguindo o padrão dos quadros de acesso"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuário é membro da comissão
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'Você não é membro desta comissão.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        # Processar assinatura
        membro_id = request.POST.get('membro_id')
        observacoes = request.POST.get('observacoes', '').strip()
        senha = request.POST.get('senha')
        
        if not membro_id:
            messages.error(request, 'Selecione um membro para assinar.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        if not senha:
            messages.error(request, 'Digite sua senha para confirmar a assinatura.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        try:
            membro_para_assinar = MembroComissao.objects.get(id=membro_id)
            # Verificar se o membro estava presente
            if not ata.sessao.presencas.filter(membro=membro_para_assinar, presente=True).exists():
                messages.error(request, 'Apenas membros presentes podem assinar a ata.')
                return redirect('militares:ata_assinar_melhorada', pk=pk)
            
            # Verificar se já não assinou
            if ata.assinaturas.filter(membro=membro_para_assinar).exists():
                messages.error(request, 'Este membro já assinou a ata.')
                return redirect('militares:ata_assinar_melhorada', pk=pk)
            
            # Capturar a função atual do usuário na sessão
            funcao_atual = request.session.get('funcao_atual_nome', 'Usuário do Sistema')
            
            # Criar assinatura
            assinatura = AssinaturaAta.objects.create(
                ata=ata,
                membro=membro_para_assinar,
                assinado_por=request.user,
                observacoes=observacoes,
                funcao_assinatura=funcao_atual
            )
            
            messages.success(request, f'Assinatura de {membro_para_assinar.militar.nome_completo} registrada com sucesso!')
            
            # Verificar se todos assinaram
            membros_presentes = ata.sessao.presencas.filter(presente=True).count()
            assinaturas_count = ata.assinaturas.count()
            
            if assinaturas_count >= membros_presentes:
                ata.status = 'ASSINADA'
                ata.save()
                messages.info(request, 'Todos os membros presentes assinaram a ata!')
            
            return redirect('militares:ata_assinar_melhorada', pk=pk)
            
        except MembroComissao.DoesNotExist:
            messages.error(request, 'Membro não encontrado.')
    
    # Obter membros presentes e suas assinaturas
    membros_presentes = ata.sessao.presencas.filter(presente=True).select_related('membro__militar', 'membro__cargo')
    assinaturas = ata.assinaturas.select_related('membro__militar', 'assinado_por')
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': membros_presentes,
        'assinaturas': assinaturas,
        'membro_usuario': membro,
    }
    return render(request, 'militares/comissao/sessoes/ata_assinaturas_melhorada.html', context)

@login_required
def assinar_ata_html(request, pk):
    """Assinar ata via modal"""
    from .models import AtaSessao, AssinaturaAta
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        ata = AtaSessao.objects.get(sessao=sessao)
    except (SessaoComissao.DoesNotExist, AtaSessao.DoesNotExist):
        messages.error(request, 'Sessão ou ata não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        observacoes = request.POST.get('observacoes', '')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Verificar se o usuário é membro da comissão
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'Você não é membro desta comissão.')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Verificar se já existe uma assinatura deste membro nesta ata
        assinatura_existente = AssinaturaAta.objects.filter(
            ata=ata,
            membro=membro
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'Você já assinou esta ata como "{assinatura_existente.get_tipo_assinatura_display()}".')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Usar a função selecionada pelo usuário ou função padrão
        if not funcao_assinatura:
            funcao_assinatura = request.session.get('funcao_atual_nome', 'Usuário do Sistema')
        
        # Criar assinatura
        assinatura = AssinaturaAta.objects.create(
            ata=ata,
            membro=membro,
            assinado_por=request.user,
            funcao_assinatura=funcao_assinatura,
            tipo_assinatura=tipo_assinatura,
            observacoes=observacoes,
            ip_assinatura=request.META.get('REMOTE_ADDR', ''),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        messages.success(request, 'Ata assinada com sucesso!')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    messages.error(request, 'Método não permitido.')
    return redirect('militares:sessao_gerar_ata', pk=sessao.pk)

@login_required
def retirar_assinatura_ata(request, pk, assinatura_pk):
    """Retirar assinatura da ata - apenas antes da finalização"""
    from .models import AtaSessao, AssinaturaAta
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        ata = AtaSessao.objects.get(sessao=sessao)
        assinatura = AssinaturaAta.objects.get(pk=assinatura_pk, ata=ata)
    except (SessaoComissao.DoesNotExist, AtaSessao.DoesNotExist, AssinaturaAta.DoesNotExist):
        messages.error(request, 'Sessão, ata ou assinatura não encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se a ata já foi finalizada
    if ata.status == 'FINALIZADA':
        messages.error(request, 'Não é possível retirar assinaturas de uma ata já finalizada.')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    # Verificar se o usuário é o autor da assinatura ou tem permissão administrativa
    if assinatura.assinado_por != request.user and not request.user.is_staff:
        messages.error(request, 'Você só pode retirar suas próprias assinaturas.')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'sessao': sessao,
                'ata': ata,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_ata.html', context)
        
        # Verificar se a assinatura é de aprovação e se há outras assinaturas de aprovação
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = ata.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se não há outras aprovações, voltar o status da ata para PARA_ASSINATURA
                ata.status = 'PARA_ASSINATURA'
                ata.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a página de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    context = {
        'sessao': sessao,
        'ata': ata,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_ata.html', context)
from django.http import FileResponse
from reportlab.platypus import SimpleDocTemplate, Image, Spacer, Paragraph, Table, TableStyle, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm
from reportlab.lib import colors
from io import BytesIO
import os
from django.contrib.auth.decorators import login_required
from django.shortcuts import redirect
from django.contrib import messages

@login_required
def voto_deliberacao_pdf(request, pk):
    """Gera PDF do voto individual, incluindo assinatura eletrônica no padrão dos quadros"""
    from .models import VotoDeliberacao
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para português brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrão se não conseguir configurar

    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar',
            'membro__usuario'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto não encontrado.')
        return redirect('militares:meus_votos_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        f"{voto.deliberacao.sessao.comissao.nome.upper()} - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Título centralizado e sublinhado
    titulo = '<u>VOTO PROFERIDO EM DELIBERAÇÃO DE COMISSÃO</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Informações do voto (alinhadas à esquerda)
    info_data = [
        [Paragraph('<b>Deliberação:</b>', style_bold), Paragraph(f"{voto.deliberacao.numero} - {voto.deliberacao.assunto}", styles['Normal'])],
        [Paragraph('<b>Comissão:</b>', style_bold), Paragraph(voto.deliberacao.sessao.comissao.nome, styles['Normal'])],
        [Paragraph('<b>Data da Sessão:</b>', style_bold), Paragraph(voto.deliberacao.sessao.data_sessao.strftime('%d/%m/%Y'), styles['Normal'])],
        [Paragraph('<b>Membro:</b>', style_bold), Paragraph(voto.membro.militar.nome_completo, styles['Normal'])],
        [Paragraph('<b>Função:</b>', style_bold), Paragraph(voto.membro.cargo.nome if hasattr(voto.membro, 'cargo') and voto.membro.cargo else 'Membro da Comissão', styles['Normal'])],
        [Paragraph('<b>Opção de Voto:</b>', style_bold), Paragraph(voto.get_voto_display(), styles['Normal'])],
    ]
    info_table = Table(info_data, colWidths=[4*cm, 11*cm], hAlign='LEFT')
    info_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('ALIGN', (0, 0), (0, -1), 'LEFT'),
        ('ALIGN', (1, 0), (1, -1), 'LEFT'),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('LEFTPADDING', (0, 0), (-1, -1), 0),
        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))

    # Voto proferido (espaçamento 1,15 e justificado)
    if voto.voto_proferido:
        story.append(Paragraph('<b>Voto Proferido:</b>', style_bold))
        story.append(Spacer(1, 4))
        # Criar estilo com espaçamento 1,15 e justificado
        style_voto = ParagraphStyle('voto', parent=styles['Normal'], leading=15, alignment=4)
        story.append(Paragraph(voto.voto_proferido, style_voto))
        story.append(Spacer(1, 20))

    # Assinatura Eletrônica (padrão dos quadros)
    if voto.assinado and voto.data_assinatura:
        # Informações de assinatura eletrônica
        nome_assinante = voto.membro.militar.nome_completo
        
        # Se o usuário tem militar associado, incluir posto com BM
        if hasattr(voto.membro.militar, 'get_posto_graduacao_display'):
            posto = voto.membro.militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_assinante = f"{posto} {voto.membro.militar.nome_completo}"
        
        # Função da assinatura
        funcao = voto.funcao_assinatura or voto.membro.cargo.nome if hasattr(voto.membro, 'cargo') and voto.membro.cargo else "Membro da Comissão"
        
        # Data e hora da assinatura
        from django.utils import timezone
        agora = timezone.localtime(voto.data_assinatura)
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        
        texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao}, em {data_formatada}, às {hora_formatada}, conforme horário oficial de Brasília, conforme portaria comando geral nº59/2020 publicada em boletim geral nº26/2020"
        
        # Adicionar logo do CBMEPI
        logo_path = os.path.join(settings.STATIC_ROOT, 'logo_cbmepi.png')
        if not os.path.exists(logo_path):
            logo_path = os.path.join(settings.STATICFILES_DIRS[0], 'logo_cbmepi.png') if settings.STATICFILES_DIRS else os.path.join(settings.BASE_DIR, 'static', 'logo_cbmepi.png')
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        story.append(Spacer(1, 20))

    # Rodapé com QR Code (padrão dos quadros)
    # Gerar URL de autenticação
    from django.urls import reverse
    from django.contrib.sites.shortcuts import get_current_site
    
    current_site = get_current_site(request)
    protocol = 'https' if request.is_secure() else 'http'
    url_autenticacao = f"{protocol}://{current_site.domain}{reverse('militares:voto_visualizar_assinar', kwargs={'pk': voto.pk})}"
    
    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a função utilitária para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(voto, request, tipo_documento='voto')
    
    # Tabela do rodapé: QR + Texto de autenticação
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)

    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualização em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'voto_deliberacao_{voto.pk}.pdf')
from django.shortcuts import get_object_or_404, render, redirect
from django.utils import timezone
from django.contrib.auth.decorators import login_required

@login_required
def voto_visualizar_assinar(request, pk):
    from .models import VotoDeliberacao, UsuarioFuncao
    voto = get_object_or_404(VotoDeliberacao, pk=pk, membro__usuario=request.user)
    
    # Buscar funções ativas do usuário
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
    
    # Função atual selecionada (da sessão ou primeira disponível)
    funcao_atual = request.session.get('funcao_atual_nome', )
    if not funcao_atual and funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    context = {
        'voto': voto,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
    }
    
    return render(request, 'militares/comissao/deliberacoes/voto_visualizar_assinar.html', context)

@login_required
def assinar_voto(request, pk):
    from .models import VotoDeliberacao
    from django.contrib.auth import authenticate
    from django.contrib import messages
    
    voto = get_object_or_404(VotoDeliberacao, pk=pk, membro__usuario=request.user)
    
    if request.method == "POST" and not voto.assinado:
        # Validar senha
        senha = request.POST.get('senha')
        if not authenticate(username=request.user.username, password=senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:voto_visualizar_assinar', pk=pk)
        
        # Capturar função da assinatura
        funcao_assinatura = request.POST.get('funcao_assinatura')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'VOTO')
        observacoes = request.POST.get('observacoes', '')
        
        # Salvar assinatura
        voto.assinado = True
        voto.data_assinatura = timezone.now()
        voto.funcao_assinatura = funcao_assinatura
        voto.tipo_assinatura = tipo_assinatura
        voto.observacoes_assinatura = observacoes
        voto.save()
        
        messages.success(request, 'Voto assinado eletronicamente com sucesso!')
    
    return redirect('militares:voto_visualizar_assinar', pk=pk)

@login_required
def verificar_autenticidade(request):
    """
    View para verificar a autenticidade de documentos
    """
    resultado = None
    documento = None
    erro = None
    
    if request.method == 'POST':
        codigo_verificador = request.POST.get('codigo_verificador', '').strip()
        codigo_crc = request.POST.get('codigo_crc', '').strip()
        tipo_documento = request.POST.get('tipo_documento', '')
        
        if codigo_verificador and codigo_crc:
            try:
                # Extrair o ID do código verificador (primeiros 8 dígitos)
                if len(codigo_verificador) >= 8:
                    documento_id = int(codigo_verificador[:8])
                    
                    # Verificar o código CRC
                    codigo_crc_esperado = f"{hash(str(documento_id)) % 0xFFFFFFF:07X}"
                    
                    if codigo_crc.upper() == codigo_crc_esperado:
                        # Buscar o documento baseado no tipo
                        if tipo_documento == 'quadro':
                            documento = get_object_or_404(QuadroAcesso, pk=documento_id)
                            resultado = {
                                'tipo': 'Quadro de Acesso',
                                'titulo': f'Quadro de Acesso - {documento.get_tipo_display()}',
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'ata':
                            documento = get_object_or_404(AtaSessao, pk=documento_id)
                            resultado = {
                                'tipo': 'Ata de Sessão',
                                'titulo': f'Ata da Sessão {documento.sessao.numero}',
                                'data_criacao': documento.sessao.data_sessao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'voto':
                            documento = get_object_or_404(VotoDeliberacao, pk=documento_id)
                            resultado = {
                                'tipo': 'Voto de Deliberação',
                                'titulo': f'Voto de {documento.membro.militar.nome_completo}',
                                'data_criacao': documento.data_registro,
                                'assinaturas': 1 if documento.assinado else 0
                            }
                        elif tipo_documento == 'quadro_fixacao':
                            documento = get_object_or_404(QuadroFixacaoVagas, pk=documento_id)
                            resultado = {
                                'tipo': 'Quadro de Fixação de Vagas',
                                'titulo': f'Quadro de Fixação - {documento.get_tipo_display()}',
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'calendario_promocao':
                            documento = get_object_or_404(CalendarioPromocao, pk=documento_id)
                            resultado = {
                                'tipo': 'Calendário de Promoção',
                                'titulo': documento.get_titulo_completo(),
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        else:
                            erro = "Tipo de documento não reconhecido."
                    else:
                        erro = "Código CRC inválido. Verifique os códigos informados."
                else:
                    erro = "Código verificador inválido. Deve ter pelo menos 8 dígitos."
                    
            except (ValueError, TypeError):
                erro = "Código verificador inválido. Deve conter apenas números."
            except QuadroAcesso.DoesNotExist:
                erro = "Quadro de Acesso não encontrado com o código informado."
            except AtaSessao.DoesNotExist:
                erro = "Ata de Sessão não encontrada com o código informado."
            except VotoDeliberacao.DoesNotExist:
                erro = "Voto de Deliberação não encontrado com o código informado."
            except QuadroFixacaoVagas.DoesNotExist:
                erro = "Quadro de Fixação de Vagas não encontrado com o código informado."
            except CalendarioPromocao.DoesNotExist:
                erro = "Calendário de Promoção não encontrado com o código informado."
            except Exception as e:
                erro = f"Erro interno do sistema. Tente novamente ou entre em contato com o suporte."
        else:
            erro = "Por favor, informe ambos os códigos."
    
    context = {
        'resultado': resultado,
        'documento': documento,
        'erro': erro,
        'tipos_documento': [
            ('quadro', 'Quadro de Acesso'),
            ('ata', 'Ata de Sessão'),
            ('voto', 'Voto de Deliberação'),
            ('quadro_fixacao', 'Quadro de Fixação de Vagas'),
            ('calendario_promocao', 'Calendário de Promoção'),
        ]
    }
    
    return render(request, 'militares/verificar_autenticidade.html', context)

# Views para Calendários de Promoções
@login_required
def calendario_promocao_list(request):
    """Lista todos os calendários de promoções"""
    # Verificar se usuário tem permissão para CRUD completo
    from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito
    from functools import wraps
    
    def has_crud_permission(user):
        cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções']
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=cargos_especiais
        )
        return user.is_superuser or user.is_staff or funcoes_especiais.exists()
    
    calendarios = CalendarioPromocao.objects.all().order_by('-ano', '-semestre')
    
    context = {
        'calendarios': calendarios,
        'title': 'Calendários de Promoções',
        'can_edit': has_crud_permission(request.user),
    }
    return render(request, 'militares/calendario_promocao/list.html', context)

@login_required
def calendario_promocao_detail(request, pk):
    """Exibe detalhes de um calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Verificar se usuário tem permissão para CRUD completo
    def has_crud_permission(user):
        cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções']
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=cargos_especiais
        )
        return user.is_superuser or user.is_staff or funcoes_especiais.exists()
    
    itens = calendario.itens.all().order_by('ordem')
    
    context = {
        'calendario': calendario,
        'itens': itens,
        'title': f'Calendário {calendario.periodo_completo}',
        'can_edit': has_crud_permission(request.user),
        'active_menu': 'calendario_promocao',
    }
    return render(request, 'militares/calendario_promocao/detail.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_create(request):
    """Cria um novo calendário de promoção"""
    if request.method == 'POST':
        ano = request.POST.get('ano')
        semestre = request.POST.get('semestre')
        tipo = request.POST.get('tipo')
        observacoes = request.POST.get('observacoes', '')
        
        if ano and semestre and tipo:
            # Verificar se já existe um calendário para este ano/semestre/tipo
            if CalendarioPromocao.objects.filter(ano=ano, semestre=semestre, tipo=tipo).exists():
                messages.error(request, f'Já existe um calendário para {semestre}º semestre de {ano} - {dict(CalendarioPromocao.TIPO_CHOICES)[tipo]}.')
                return redirect('militares:calendario_promocao_create')
            
            calendario = CalendarioPromocao.objects.create(
                ano=ano,
                semestre=semestre,
                tipo=tipo,
                observacoes=observacoes
            )
            
            messages.success(request, f'Calendário {calendario.periodo_completo} criado com sucesso!')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        else:
            messages.error(request, 'Ano, semestre e tipo são obrigatórios.')
    
    context = {
        'title': 'Criar Calendário de Promoção',
        'anos': [(str(year), str(year)) for year in range(2020, 2031)],
        'semestres': [('1', '1º Semestre'), ('2', '2º Semestre')],
        'tipos': CalendarioPromocao.TIPO_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/create.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_update(request, pk):
    """Atualiza um calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        ano = request.POST.get('ano')
        semestre = request.POST.get('semestre')
        tipo = request.POST.get('tipo')
        observacoes = request.POST.get('observacoes', '')
        ativo = request.POST.get('ativo') == 'on'
        
        if ano and semestre and tipo:
            # Verificar se já existe outro calendário para este ano/semestre/tipo
            if CalendarioPromocao.objects.filter(ano=ano, semestre=semestre, tipo=tipo).exclude(pk=calendario.pk).exists():
                messages.error(request, f'Já existe um calendário para {semestre}º semestre de {ano} - {dict(CalendarioPromocao.TIPO_CHOICES)[tipo]}.')
                return redirect('militares:calendario_promocao_update', pk=pk)
            
            calendario.ano = ano
            calendario.semestre = semestre
            calendario.tipo = tipo
            calendario.observacoes = observacoes
            calendario.ativo = ativo
            calendario.save()
            
            messages.success(request, f'Calendário {calendario.periodo_completo} atualizado com sucesso!')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        else:
            messages.error(request, 'Ano, semestre e tipo são obrigatórios.')
    
    context = {
        'calendario': calendario,
        'title': f'Editar Calendário {calendario.periodo_completo}',
        'anos': [(str(year), str(year)) for year in range(2020, 2031)],
        'semestres': [('1', '1º Semestre'), ('2', '2º Semestre')],
        'tipos': CalendarioPromocao.TIPO_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/update.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_delete(request, pk):
    """Exclui um calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if not calendario.pode_ser_excluido():
            messages.error(request, f'Calendário {calendario.numero} não pode ser excluído pois está {calendario.get_status_display()}.')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        
        nome_calendario = calendario.numero or calendario.periodo_completo
        calendario.delete()
        messages.success(request, f'Calendário {nome_calendario} excluído com sucesso!')
        return redirect('militares:calendario_promocao_list')
    
    context = {
        'calendario': calendario,
        'title': f'Excluir Calendário {calendario.numero or calendario.periodo_completo}',
        'pode_excluir': calendario.pode_ser_excluido(),
    }
    return render(request, 'militares/calendario_promocao/delete.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_aprovar(request, pk):
    """Aprova um calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if calendario.status in ['RASCUNHO', 'EM_ELABORACAO']:
            calendario.aprovar(request.user)
            messages.success(request, f'Calendário {calendario.numero} aprovado com sucesso!')
        else:
            messages.error(request, f'Calendário {calendario.numero} não pode ser aprovado no status atual.')
        
        return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'title': f'Aprovar Calendário {calendario.numero or calendario.periodo_completo}',
        'pode_aprovar': calendario.status in ['RASCUNHO', 'EM_ELABORACAO'],
    }
    return render(request, 'militares/calendario_promocao/aprovar.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_homologar(request, pk):
    """Homologa um calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if calendario.status == 'APROVADO':
            calendario.homologar(request.user)
            messages.success(request, f'Calendário {calendario.numero} homologado com sucesso!')
        else:
            messages.error(request, f'Calendário {calendario.numero} não pode ser homologado no status atual.')
        
        return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'title': f'Homologar Calendário {calendario.numero or calendario.periodo_completo}',
        'pode_homologar': calendario.status == 'APROVADO',
    }
    return render(request, 'militares/calendario_promocao/homologar.html', context)

@login_required
@cargos_especiais_required
def item_calendario_create(request, calendario_pk):
    """Adiciona um item ao calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=calendario_pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        tipo_atividade = request.POST.get('tipo_atividade')
        data_inicio = request.POST.get('data_inicio')
        data_fim = request.POST.get('data_fim')
        ordem = request.POST.get('ordem', 0)
        observacoes = request.POST.get('observacoes', '')
        
        if tipo_atividade and data_inicio and data_fim:
            try:
                data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
                data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
                
                # Verificar se já existe um item deste tipo no calendário
                if ItemCalendarioPromocao.objects.filter(calendario=calendario, tipo_atividade=tipo_atividade).exists():
                    messages.error(request, 'Já existe um item deste tipo no calendário.')
                    return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
                
                # Criar o item sem ordem (será definida automaticamente no save)
                item = ItemCalendarioPromocao.objects.create(
                    calendario=calendario,
                    tipo_atividade=tipo_atividade,
                    data_inicio=data_inicio,
                    data_fim=data_fim,
                    ordem=0,  # Será definida automaticamente no save
                    observacoes=observacoes
                )
                
                # Reordenar todos os itens do calendário
                ItemCalendarioPromocao.reordenar_itens_calendario(calendario)
                
                messages.success(request, f'Item "{item.get_tipo_atividade_display()}" adicionado com sucesso!')
                return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
                
            except ValueError:
                messages.error(request, 'Data inválida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Tipo de atividade e datas são obrigatórios.')
    
    # Determinar o próximo item a ser adicionado
    itens_existentes = calendario.itens.values_list('tipo_atividade', flat=True)
    proximo_item = None
    
    # Buscar o próximo item na ordem padrão que ainda não foi adicionado
    for tipo_atividade, ordem in sorted(ItemCalendarioPromocao.ORDEM_PADRAO.items(), key=lambda x: x[1]):
        if tipo_atividade not in itens_existentes:
            proximo_item = tipo_atividade
            break
    
    # Se não há próximo item, usar o primeiro da lista
    if not proximo_item:
        proximo_item = ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES[0][0]
    
    # Criar lista de tipos de atividade com ordem
    tipos_com_ordem = []
    for tipo_valor, tipo_label in ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES:
        ordem = ItemCalendarioPromocao.ORDEM_PADRAO.get(tipo_valor, 999)
        tipos_com_ordem.append({
            'valor': tipo_valor,
            'label': tipo_label,
            'ordem': ordem,
            'display': f"{ordem}. {tipo_label}"
        })
    
    # Ordenar por ordem
    tipos_com_ordem.sort(key=lambda x: x['ordem'])
    
    context = {
        'calendario': calendario,
        'title': f'Adicionar Item ao Calendário {calendario.periodo_completo}',
        'tipos_atividade': tipos_com_ordem,
        'proximo_item': proximo_item,
        'ordem_proximo_item': ItemCalendarioPromocao.ORDEM_PADRAO.get(proximo_item, 999),
    }
    return render(request, 'militares/calendario_promocao/item_create.html', context)

@login_required
@cargos_especiais_required
def item_calendario_update(request, pk):
    """Atualiza um item do calendário de promoção"""
    try:
        item = ItemCalendarioPromocao.objects.get(pk=pk)
    except ItemCalendarioPromocao.DoesNotExist:
        messages.error(request, 'Item do calendário não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        tipo_atividade = request.POST.get('tipo_atividade')
        data_inicio = request.POST.get('data_inicio')
        data_fim = request.POST.get('data_fim')
        ordem = request.POST.get('ordem', 0)
        observacoes = request.POST.get('observacoes', '')
        
        if tipo_atividade and data_inicio and data_fim:
            try:
                data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
                data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
                
                # Verificar se já existe outro item deste tipo no calendário
                if ItemCalendarioPromocao.objects.filter(
                    calendario=item.calendario, 
                    tipo_atividade=tipo_atividade
                ).exclude(pk=item.pk).exists():
                    messages.error(request, 'Já existe um item deste tipo no calendário.')
                    return redirect('militares:calendario_promocao_detail', pk=item.calendario.pk)
                
                item.tipo_atividade = tipo_atividade
                item.data_inicio = data_inicio
                item.data_fim = data_fim
                item.ordem = 0  # Será definida automaticamente no save
                item.observacoes = observacoes
                item.save()
                
                # Reordenar todos os itens do calendário
                ItemCalendarioPromocao.reordenar_itens_calendario(item.calendario)
                
                messages.success(request, f'Item "{item.get_tipo_atividade_display()}" atualizado com sucesso!')
                return redirect('militares:calendario_promocao_detail', pk=item.calendario.pk)
                
            except ValueError:
                messages.error(request, 'Data inválida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Tipo de atividade e datas são obrigatórios.')
    
    context = {
        'item': item,
        'calendario': item.calendario,
        'title': f'Editar Item do Calendário {item.calendario.periodo_completo}',
        'tipos_atividade': ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/item_update.html', context)

@login_required
def calendario_promocao_visualizar_assinatura(request, pk):
    """Visualização do calendário de promoção com opções de assinatura"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Buscar itens do calendário ordenados por ordem
    itens = calendario.itens.all().order_by('ordem')
    
    # Buscar assinaturas eletrônicas
    assinaturas = calendario.assinaturas.all().order_by('data_assinatura')
    
    # Verificar permissões de assinatura
    can_sign = False
    
    # Verificar se não é o usuário "usuario"
    if request.user.username == 'usuario':
        can_sign = False
    else:
        # Verificar se o usuário tem funções específicas
        funcoes_especificas = [
            'Presidente', 'Diretor', 'Chefe', 'Comandante', 'Secretário', 
            'Coordenador', 'Supervisor', 'Gerente', 'Assessor', 'Consultor',
            'Membro de Comissão', 'Membro Efetivo', 'Membro Nato'
        ]
        
        # Verificar se tem funções ativas
        funcoes_ativas = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO',
            data_fim__isnull=True
        )
        
        # Verificar se é membro de comissão ativa
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            data_termino__isnull=True
        ).exists()
        
        # Verificar se tem funções específicas ou é membro de comissão
        tem_funcao_especifica = False
        for funcao in funcoes_ativas:
            if any(nome in funcao.cargo_funcao.nome for nome in funcoes_especificas):
                tem_funcao_especifica = True
                break
        
        if tem_funcao_especifica or membro_comissao or request.user.is_superuser or request.user.is_staff:
            can_sign = True
    
    # Buscar funções do usuário para assinatura
    funcoes_usuario = []
    funcao_atual = None
    funcoes_adicionadas = set()  # Para evitar duplicatas
    
    if request.user.is_authenticated and request.user.username != 'usuario':
        print(f"DEBUG: Verificando funções para usuário: {request.user.username}")
        
        # Buscar TODAS as comissões ativas (não apenas do tipo do calendário)
        comissoes_ativas = ComissaoPromocao.objects.filter(status='ATIVA')
        
        # Adicionar funções de comissão
        for comissao in comissoes_ativas:
            membros_comissao = comissao.membros.filter(usuario=request.user)
            for membro in membros_comissao:
                nome_funcao = membro.cargo.nome
                if nome_funcao not in funcoes_adicionadas:
                    funcoes_usuario.append({
                        'tipo': 'comissao',
                        'objeto': membro,
                        'nome': nome_funcao,
                        'descricao': f"{nome_funcao} ({comissao.get_tipo_display()})"
                    })
                    funcoes_adicionadas.add(nome_funcao)
        
        # Buscar TODAS as funções específicas do usuário (sem filtrar)
        funcoes_especificas = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO',
            data_fim__isnull=True
        )
        
        print(f"DEBUG: Funções específicas encontradas: {funcoes_especificas.count()}")
        
        # Adicionar TODAS as funções específicas do usuário (sem filtrar)
        for funcao in funcoes_especificas:
            nome_funcao = funcao.cargo_funcao.nome
            if nome_funcao not in funcoes_adicionadas:
                print(f"DEBUG: Adicionando função específica: {nome_funcao}")
                funcoes_usuario.append({
                    'tipo': 'especifica',
                    'objeto': funcao,
                    'nome': nome_funcao,
                    'descricao': f"{nome_funcao} (Função Específica)"
                })
                funcoes_adicionadas.add(nome_funcao)
        
        # Definir função atual (primeira da lista)
        if funcoes_usuario:
            funcao_atual = funcoes_usuario[0]['nome']
        
        # Debug: Log das funções encontradas
        print(f"DEBUG: Total de funções encontradas: {len(funcoes_usuario)}")
        for i, funcao in enumerate(funcoes_usuario):
            print(f"DEBUG: Função {i+1}: {funcao['nome']} - {funcao['descricao']}")
        
        # Se não encontrou nenhuma função, permitir assinatura como usuário genérico
        if not funcoes_usuario and can_sign:
            funcoes_usuario.append({
                'tipo': 'generico',
                'objeto': None,
                'nome': 'Usuário Autorizado',
                'descricao': 'Usuário Autorizado (Função Genérica)'
            })
            funcao_atual = 'Usuário Autorizado'
    
    context = {
        'calendario': calendario,
        'itens': itens,
        'assinaturas': assinaturas,
        'can_sign': can_sign,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
        'title': f'Visualizar Calendário {calendario.numero}',
    }
    return render(request, 'militares/calendario_promocao/visualizar_assinatura.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_assinar(request, pk):
    """Assinar calendário de promoção"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'Calendário de promoção não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Verificar permissões de assinatura
    if request.user.username == 'usuario':
        messages.error(request, 'O usuário "usuario" não tem permissão para assinar calendários.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    # Verificar se o usuário tem funções específicas
    funcoes_especificas = [
        'Presidente', 'Diretor', 'Chefe', 'Comandante', 'Secretário', 
        'Coordenador', 'Supervisor', 'Gerente', 'Assessor', 'Consultor',
        'Membro de Comissão', 'Membro Efetivo', 'Membro Nato'
    ]
    
    # Verificar se tem funções ativas
    funcoes_ativas = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO',
        data_fim__isnull=True
    )
    
    # Verificar se é membro de comissão ativa
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        data_termino__isnull=True
    ).exists()
    
    # Verificar se tem funções específicas ou é membro de comissão
    tem_funcao_especifica = False
    for funcao in funcoes_ativas:
        if any(nome in funcao.cargo_funcao.nome for nome in funcoes_especificas):
            tem_funcao_especifica = True
            break
    
    if not (tem_funcao_especifica or membro_comissao or request.user.is_superuser or request.user.is_staff):
        messages.error(request, 'Você não tem permissão para assinar calendários. É necessário ter funções específicas ou ser membro de comissão.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    if request.method == 'POST':
        tipo_assinatura = request.POST.get('tipo_assinatura')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        observacoes = request.POST.get('observacoes', '')
        senha = request.POST.get('senha')
        
        if not senha:
            messages.error(request, 'Senha é obrigatória para confirmar a assinatura.')
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta.')
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
        
        # Criar assinatura
        try:
            assinatura = AssinaturaCalendarioPromocao.objects.create(
                calendario=calendario,
                tipo_assinatura=tipo_assinatura,
                funcao_assinatura=funcao_assinatura,
                assinado_por=request.user,
                observacoes=observacoes
            )
            messages.success(request, f'Calendário {calendario.numero} assinado com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao assinar calendário: {str(e)}')
        
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    context = {
        'calendario': calendario,
        'title': f'Assinar Calendário {calendario.numero}',
    }
    return render(request, 'militares/calendario_promocao/assinar.html', context)

@login_required
def retirar_assinatura_calendario(request, pk, assinatura_pk):
    """Retirar assinatura do calendário de promoção - apenas antes da homologação"""
    calendario = get_object_or_404(CalendarioPromocao, pk=pk)
    assinatura = get_object_or_404(AssinaturaCalendarioPromocao, pk=assinatura_pk, calendario=calendario)
    
    # Verificar se o calendário já foi homologado
    if calendario.status == 'HOMOLOGADO':
        messages.error(request, 'Não é possível retirar assinaturas de um calendário já homologado.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    # Verificar se o usuário é o autor da assinatura ou tem permissão administrativa
    if assinatura.assinado_por != request.user and not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'Você só pode retirar suas próprias assinaturas.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuário
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'calendario': calendario,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_calendario.html', context)
        
        # Verificar se a assinatura é de aprovação e se há outras assinaturas de aprovação
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = calendario.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se não há outras aprovações, voltar o status do calendário para EM_ELABORACAO
                calendario.status = 'EM_ELABORACAO'
                calendario.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a página de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_calendario.html', context)

@login_required
def calendario_promocao_gerar_pdf(request, pk):
    """Gera PDF do calendário de promoção no modelo institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para português brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrão se não conseguir configurar

    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, f'Calendário de promoção com ID {pk} não encontrado.')
        return redirect('militares:calendario_promocao_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        "DIRETORIA DE GESTÃO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Título centralizado e sublinhado
    titulo_completo = calendario.get_titulo_completo()
    titulo = f'<u>{titulo_completo}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Informações do calendário
    info_data = [
        ['Período:', f"{calendario.get_semestre_display()} {calendario.ano}"],
        ['Tipo:', calendario.get_tipo_display()],
        ['Status:', calendario.get_status_display()],
        ['Data de Criação:', calendario.data_criacao.strftime('%d/%m/%Y %H:%M')],
    ]
    
    if calendario.data_aprovacao:
        info_data.append(['Aprovado em:', calendario.data_aprovacao.strftime('%d/%m/%Y %H:%M')])
        info_data.append(['Aprovado por:', calendario.aprovado_por.get_full_name()])
    
    if calendario.data_homologacao:
        info_data.append(['Homologado em:', calendario.data_homologacao.strftime('%d/%m/%Y %H:%M')])
        info_data.append(['Homologado por:', calendario.homologado_por.get_full_name()])

    info_table = Table(info_data, colWidths=[4*cm, 10*cm])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f8f9fa')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))

    # Itens do calendário
    if calendario.itens.exists():
        story.append(Paragraph("ITENS DO CALENDÁRIO", style_subtitle))
        story.append(Spacer(1, 10))
        
        # Cabeçalho da tabela
        header_data = [['Ordem', 'Atividade', 'Período']]
        
        # Dados dos itens
        for item in calendario.itens.all().order_by('ordem'):
            header_data.append([
                str(item.ordem),
                item.get_tipo_atividade_display(),
                item.periodo_formatado
            ])
        
        items_table = Table(header_data, colWidths=[1.5*cm, 10*cm, 4*cm])
        items_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(items_table)
        story.append(Spacer(1, 20))

    # Data e local
    data_atual = datetime.now()
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    data_formatada = f"{data_atual.day} de {meses_pt[data_atual.month]} de {data_atual.year}"
    data_extenso = f"Teresina, {data_formatada}"
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # Seção de Assinaturas Físicas (sem título)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas válidas do calendário (da mais recente para a mais antiga)
    assinaturas = calendario.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        # Exibir no formato físico: Nome - Posto BM (negrito), Função (normal)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Spacer(1, 13))

    # Se não houver assinaturas, mostrar mensagem
    if not assinaturas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))

    # Seção de Assinaturas Eletrônicas (sem título)
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
    story.append(Spacer(1, 13))
    
    # Buscar todas as assinaturas para exibir na seção eletrônica
    assinaturas_eletronicas = calendario.assinaturas.filter(
        assinado_por__isnull=False
    ).order_by('-data_assinatura')
    
    for i, assinatura in enumerate(assinaturas_eletronicas):
        # Nome e posto - seguir o mesmo padrão dos quadros de acesso
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM após o posto se não já estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{posto} {militar.nome_completo}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # Função
        funcao = assinatura.funcao_assinatura or "Função não registrada"
        
        # Data da assinatura
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        data_assinatura = f"{data_formatada} às {hora_formatada}"
        
        # Texto da assinatura eletrônica no padrão solicitado
        texto_assinatura = f"Documento assinado eletronicamente por {nome_completo} - {funcao}, em {data_assinatura}, conforme horário oficial de Brasília, conforme portaria comando geral nº59/2020 publicada em boletim geral nº26/2020"
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na última)
        if i < len(assinaturas_eletronicas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a função utilitária para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(calendario, request, tipo_documento='calendario_promocao')
    
    # Tabela do rodapé: QR + Texto de autenticação
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado à esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualização em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'calendario_promocao_{calendario.pk}.pdf')

@login_required
@cargos_especiais_required
def item_calendario_delete(request, pk):
    """Exclui um item do calendário de promoção"""
    try:
        item = ItemCalendarioPromocao.objects.get(pk=pk)
    except ItemCalendarioPromocao.DoesNotExist:
        messages.error(request, 'Item do calendário não encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        nome_item = item.get_tipo_atividade_display()
        calendario_pk = item.calendario.pk
        item.delete()
        messages.success(request, f'Item "{nome_item}" excluído com sucesso!')
        return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
    
    context = {
        'item': item,
        'calendario': item.calendario,
        'title': f'Excluir Item do Calendário {item.calendario.periodo_completo}',
    }
    return render(request, 'militares/calendario_promocao/item_delete.html', context)

@login_required
def calendario_promocao_visualizar(request):
    """Visualização pública dos calendários de promoções ativos"""
    calendarios_ativos = CalendarioPromocao.objects.filter(ativo=True).order_by('-ano', '-semestre')
    
    context = {
        'calendarios': calendarios_ativos,
        'title': 'Calendários de Promoções',
    }
    return render(request, 'militares/calendario_promocao/visualizar.html', context)
# Views para Almanaque
from django.core.files.base import ContentFile
from django.http import HttpResponse
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm, inch
from reportlab.lib import colors
from io import BytesIO

@login_required
def almanaque_militares(request):
    """Almanaque dos militares organizado por hierarquia"""
    
    # Definir ordem hierárquica dos postos (do mais graduado ao menos graduado)
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos
    militares_ativos = Militar.objects.filter(situacao='AT').order_by('posto_graduacao', 'numeracao_antiguidade', 'nome_completo')
    
    # Separar oficiais, praças e NVRR
    oficiais = []
    pracas = []
    nvrr = []
    
    for militar in militares_ativos:
        if militar.is_nvrr():
            nvrr.append(militar)
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar oficiais por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por número de antiguidade (menor primeiro) e depois por data de promoção
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    # Organizar praças por hierarquia
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por número de antiguidade (menor primeiro) e depois por data de promoção
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Organizar NVRR separadamente
    nvrr_organizados = {}
    if nvrr:
        # Ordenar por data de promoção (mais antiga primeiro) e depois por nome
        nvrr.sort(key=lambda x: (x.data_promocao_atual, x.nome_completo))
        nvrr_organizados['NVRR'] = nvrr
    
    # Organizar todos os militares por hierarquia geral (incluindo NVRR)
    todos_organizados = {}
    ordem_geral = ordem_postos_oficiais + ordem_postos_pracas
    
    for posto in ordem_geral:
        militares_posto = [m for m in militares_ativos if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por número de antiguidade (menor primeiro) e depois por data de promoção
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            todos_organizados[posto] = militares_posto
    
    # Adicionar NVRR ao todos_organizados
    if nvrr:
        todos_organizados['NVRR'] = nvrr
        ordem_geral = ['NVRR'] + ordem_geral
    
    context = {
        'title': 'Almanaque dos Militares',
        'oficiais_organizados': oficiais_organizados,
        'pracas_organizadas': pracas_organizadas,
        'nvrr_organizados': nvrr_organizados,
        'todos_organizados': todos_organizados,
        'ordem_postos_oficiais': ordem_postos_oficiais,
        'ordem_postos_pracas': ordem_postos_pracas,
        'ordem_geral': ordem_geral,
        'total_oficiais': len(oficiais),
        'total_pracas': len(pracas),
        'total_nvrr': len(nvrr),
        'total_geral': len(militares_ativos),
        'POSTO_GRADUACAO_CHOICES': POSTO_GRADUACAO_CHOICES,
    }
    
    return render(request, 'militares/almanaque.html', context)

@login_required
def almanaque_list(request):
    """Lista todos os almanaques seguindo o padrão dos quadros de fixação de vagas"""
    # Permissão especial para superusuários, staff e funções administrativas
    cargos_especiais = ['Diretor de Gestão de Pessoas', 'Chefe da Seção de Promoções', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    
    # Superusuários e staff podem ver todos os almanaques
    if request.user.is_superuser or request.user.is_staff or funcoes_ativas.exists():
        almanaques = AlmanaqueMilitar.objects.filter(ativo=True).order_by('-data_geracao')
    else:
        # Verificar se o usuário é membro de alguma comissão e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                almanaques = AlmanaqueMilitar.objects.filter(ativo=True).order_by('-data_geracao')
            elif tem_cpo:
                almanaques = AlmanaqueMilitar.objects.filter(tipo='OFICIAIS', ativo=True).order_by('-data_geracao')
            elif tem_cpp:
                almanaques = AlmanaqueMilitar.objects.filter(tipo='PRACAS', ativo=True).order_by('-data_geracao')
            else:
                almanaques = AlmanaqueMilitar.objects.none()
        else:
            almanaques = AlmanaqueMilitar.objects.none()
    
    # Filtros
    data_inicio = request.GET.get('data_inicio')
    if data_inicio:
        try:
            from datetime import datetime
            data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            almanaques = almanaques.filter(data_geracao__date__gte=data_inicio)
        except ValueError:
            pass
    
    data_fim = request.GET.get('data_fim')
    if data_fim:
        try:
            from datetime import datetime
            data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
            almanaques = almanaques.filter(data_geracao__date__lte=data_fim)
        except ValueError:
            pass
    
    # Paginação
    paginator = Paginator(almanaques, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # Estatísticas
    total_almanaques = almanaques.count()
    
    # Verificar se o usuário é membro de alguma comissão
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    context = {
        'almanaques': page_obj,
        'total_almanaques': total_almanaques,
        'filtros': {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
        },
        'membro_comissao': membro_comissao,
    }
    
    return render(request, 'militares/almanaque/list.html', context)

@login_required
def almanaque_create(request):
    """Cria um novo almanaque"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo', 'GERAL')
        titulo = request.POST.get('titulo', f'Almanaque {tipo.lower().title()} - {timezone.now().strftime("%d/%m/%Y")}')
        observacoes = request.POST.get('observacoes', '')
        status = request.POST.get('status', 'RASCUNHO')
        
        try:
            # 1. Obter dados dos militares
            militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR')
            
            # 2. Separar oficiais e praças
            oficiais = [m for m in militares_ativos if m.is_oficial()]
            pracas = [m for m in militares_ativos if not m.is_oficial()]
            
            # 3. Filtrar por tipo
            if tipo == 'OFICIAIS':
                militares_filtrados = oficiais
                titulo_final = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
            elif tipo == 'PRACAS':
                militares_filtrados = pracas
                titulo_final = "ALMANAQUE DAS PRAÇAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
            else:  # GERAL
                militares_filtrados = list(militares_ativos)
                titulo_final = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
            
            # 4. Organizar dados para HTML
            dados_organizados = {}
            ordem_postos = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA', 'ST', '1S', '2S', '3S', 'CAB', 'SD']
            
            for posto in ordem_postos:
                militares_posto = [m for m in militares_filtrados if m.posto_graduacao == posto]
                if militares_posto:
                    militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
                    dados_organizados[posto] = militares_posto
            
            # 5. Gerar HTML primeiro
            html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
            
            # 6.1. Definir data da última promoção baseada na data de criação
            from datetime import date
            data_atual = date.today()
            
            # Datas de promoção conhecidas
            data_promocao_1 = date(2025, 7, 18)   # 18/07/2025
            data_promocao_2_oficiais = date(2025, 12, 23)  # 23/12/2025
            data_promocao_2_pracas = date(2025, 12, 25)    # 25/12/2025
            
            # Determinar qual data de promoção usar baseada na data atual
            if tipo == 'OFICIAIS':
                if data_atual <= data_promocao_2_oficiais:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_oficiais  # 23/12/2025
            elif tipo == 'PRACAS':
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            else:  # GERAL
                # Para geral, usar a data mais recente entre todas as promoções
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            
            # 7. Criar almanaque no banco (apenas com HTML)
            almanaque = AlmanaqueMilitar.objects.create(
                titulo=titulo,
                tipo=tipo,
                status=status,
                observacoes=observacoes,
                criado_por=request.user,
                conteudo_html=html_content,
                total_oficiais=len(oficiais),
                total_pracas=len(pracas),
                total_geral=len(militares_ativos),
                data_ultima_promocao=data_ultima_promocao,
                ativo=True
            )
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" gerado com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao gerar almanaque: {str(e)}')
            return redirect('militares:almanaque_create')
    
    context = {
        'title': 'Gerar Novo Almanaque',
    }
    return render(request, 'militares/almanaque_create.html', context)

@login_required
def almanaque_detail(request, pk):
    """Detalhes de um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    context = {
        'almanaque': almanaque,
        'title': f'Detalhes do Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_detail.html', context)

@login_required
def almanaque_delete(request, pk):
    """Exclui um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_excluido():
        messages.error(request, 'Este almanaque não pode ser excluído.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        titulo = almanaque.titulo
        almanaque.delete()
        messages.success(request, f'Almanaque "{titulo}" excluído com sucesso!')
        return redirect('militares:almanaque_list')
    
    context = {
        'almanaque': almanaque,
        'title': f'Excluir Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_delete.html', context)

@login_required
def almanaque_edit(request, pk):
    """Edita um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_editado():
        messages.error(request, 'Este almanaque não pode ser editado.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        titulo = request.POST.get('titulo', almanaque.titulo)
        observacoes = request.POST.get('observacoes', almanaque.observacoes)
        status = request.POST.get('status', almanaque.status)
        
        try:
            almanaque.titulo = titulo
            almanaque.observacoes = observacoes
            almanaque.status = status
            almanaque.save()
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" atualizado com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao atualizar almanaque: {str(e)}')
    
    context = {
        'almanaque': almanaque,
        'title': f'Editar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_edit.html', context)

@login_required
def almanaque_visualizar_html(request, pk):
    """Visualiza o almanaque em HTML"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    # Buscar assinaturas do almanaque
    assinaturas = almanaque.get_assinaturas_ordenadas()
    
    # Buscar funções do usuário para o modal de assinatura
    from .models import UsuarioFuncao
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).order_by('cargo_funcao__nome')
    
    # Função atual do usuário (se houver)
    funcao_atual = None
    if funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    context = {
        'almanaque': almanaque,
        'assinaturas': assinaturas,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
        'title': f'Visualizar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_visualizar_html.html', context)

@login_required
def almanaque_gerar_pdf(request, pk):
    """Gera PDF do almanaque dinamicamente (mesmo padrão dos outros documentos)"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    try:
        # Gerar PDF a partir do almanaque específico (que inclui assinaturas)
        from .pdf_utils import gerar_pdf_almanaque_direct
        pdf_content = gerar_pdf_almanaque_direct(almanaque, request)
        
        # Retornar o PDF para visualização em nova guia (mesmo padrão dos quadros)
        from io import BytesIO
        from django.http import FileResponse
        
        buffer = BytesIO(pdf_content)
        buffer.seek(0)
        
        return FileResponse(
            buffer, 
            content_type='application/pdf', 
            filename=f'almanaque_{almanaque.tipo}_{almanaque.pk}.pdf'
        )
        
    except Exception as e:
        messages.error(request, f'Erro ao gerar PDF: {str(e)}')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)

@login_required
def almanaque_assinatura_create(request, pk):
    """Cria uma assinatura para o almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_assinado():
        messages.error(request, 'Este almanaque não pode ser assinado.')
        return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
    
    if request.method == 'POST':
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        cargo_funcao = request.POST.get('cargo_funcao', '')
        observacoes = request.POST.get('observacoes', '')
        senha = request.POST.get('senha', '')
        
        # Verificar senha
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Por favor, tente novamente.')
            return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
        
        try:
            # Verificar se já existe assinatura deste tipo
            if AssinaturaAlmanaque.objects.filter(
                almanaque=almanaque,
                assinado_por=request.user,
                tipo_assinatura=tipo_assinatura
            ).exists():
                messages.error(request, 'Você já assinou este almanaque com este tipo de assinatura.')
                return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
            
            # Criar assinatura
            assinatura = AssinaturaAlmanaque.objects.create(
                almanaque=almanaque,
                assinado_por=request.user,
                tipo_assinatura=tipo_assinatura,
                cargo_funcao=cargo_funcao,
                observacoes=observacoes
            )
            
            messages.success(request, f'Assinatura adicionada com sucesso ao almanaque "{almanaque.titulo}"!')
            return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao criar assinatura: {str(e)}')
    
    # Buscar assinaturas existentes do usuário
    assinaturas_existentes = AssinaturaAlmanaque.objects.filter(
        almanaque=almanaque,
        assinado_por=request.user
    ).order_by('data_assinatura')
    
    context = {
        'almanaque': almanaque,
        'assinaturas_existentes': assinaturas_existentes,
        'title': f'Assinar Almanaque - {almanaque.titulo}',
        'now': timezone.now(),
    }
    return render(request, 'militares/almanaque_assinatura_create.html', context)

@login_required
def almanaque_assinatura_delete(request, pk, assinatura_pk):
    """Remove uma assinatura do almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    assinatura = get_object_or_404(AssinaturaAlmanaque, pk=assinatura_pk, almanaque=almanaque)
    
    # Verificar permissão
    if assinatura.assinado_por != request.user and not request.user.is_superuser:
        messages.error(request, 'Você não tem permissão para remover esta assinatura.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        assinatura.delete()
        messages.success(request, 'Assinatura removida com sucesso!')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    context = {
        'almanaque': almanaque,
        'assinatura': assinatura,
        'title': f'Remover Assinatura - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_assinatura_delete.html', context)

def gerar_pdf_almanaque(tipo):
    """Função auxiliar para gerar o conteúdo PDF do almanaque no padrão institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime
    from django.utils import timezone

    # Configurar locale para português brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrão se não conseguir configurar

    # Definir ordem hierárquica dos postos
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos (excluindo NVRR)
    militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR').order_by('posto_graduacao', 'numeracao_antiguidade', 'data_promocao_atual')
    
    # Separar oficiais e praças (excluindo NVRR)
    oficiais = []
    pracas = []
    
    for militar in militares_ativos:
        # Verificação adicional para excluir NVRR pelo quadro
        if militar.quadro == 'NVRR':
            continue
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Determinar título e dados baseado no tipo
    if tipo == 'OFICIAIS':
        titulo = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = oficiais_organizados
        ordem_postos = ordem_postos_oficiais
        total = len(oficiais)
    elif tipo == 'PRACAS':
        titulo = "ALMANAQUE DAS PRAÇAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = pracas_organizadas
        ordem_postos = ordem_postos_pracas
        total = len(pracas)
    else:  # GERAL
        titulo = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = {**oficiais_organizados, **pracas_organizadas}
        ordem_postos = ordem_postos_oficiais + ordem_postos_pracas
        total = len(militares_ativos)

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/Brasão centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # Cabeçalho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÍ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ",
        "DIRETORIA DE GESTÃO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro Piçarra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # Título centralizado e sublinhado
    titulo_formatado = f'<u>{titulo}</u>'
    story.append(Paragraph(titulo_formatado, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutório
    story.append(Paragraph("O DIRETOR DE GESTÃO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ, no uso de suas atribuições que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1° da lei 7.772, de 04 de abril de 2022;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("CONSIDERANDO o Anexo Único, da lei nº 5.949, de 17 de dezembro de 2009 (Lei de Organização Básica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("CONSIDERANDO a necessidade de manter atualizado o almanaque dos militares do CBMEPI;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("RESOLVE:", style_just))
    story.append(Spacer(1, 16))
    
    # Artigo 1º
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'março', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    # Definir datas de promoção conforme o tipo e data de geração
    data_atual = datetime.now()
    
    if tipo == 'OFICIAIS':
        tipo_militar = '<b><u>OFICIAIS</u></b>'
        # Se gerado entre 18/07 e 23/12: usar 18/07/2025
        # Se gerado entre 23/12 e 18/07: usar 23/12/2025
        if (data_atual.month == 7 and data_atual.day >= 18) or (data_atual.month > 7 and data_atual.month < 12) or (data_atual.month == 12 and data_atual.day < 23):
            data_formatada = "18/07/2025"
        else:
            data_formatada = "23/12/2025"
    elif tipo == 'PRACAS':
        tipo_militar = '<b><u>PRAÇAS</u></b>'
        # Se gerado entre 18/07 e 25/12: usar 18/07/2025
        # Se gerado entre 25/12 e 18/07: usar 25/12/2025
        if (data_atual.month == 7 and data_atual.day >= 18) or (data_atual.month > 7 and data_atual.month < 12) or (data_atual.month == 12 and data_atual.day < 25):
            data_formatada = "18/07/2025"
        else:
            data_formatada = "25/12/2025"
    else:
        tipo_militar = "Militares"
        data_formatada = "18/07/2025"
    
    artigo_1 = f"""
    <b>Art. 1º</b> Fica fixada a antiguidade dos {tipo_militar} do Corpo de Bombeiros Militar do Estado do Piauí, após as promoções ocorridas em {data_formatada}, conforme segue:
    """
    
    story.append(Paragraph(artigo_1, style_bold))
    story.append(Spacer(1, 16))

    # Tabela principal com dados dos militares
    for posto in ordem_postos:
        if posto in dados_organizados and dados_organizados[posto]:
            militares = dados_organizados[posto]
            
            # Nome completo do posto
            nomes_postos = {
                'CB': 'CORONEL',
                'TC': 'TENENTE-CORONEL',
                'MJ': 'MAJOR',
                'CP': 'CAPITÃO',
                '1T': '1º TENENTE',
                '2T': '2º TENENTE',
                'AS': 'ASPIRANTE',
                'AA': 'ALUNO-ASTO',
                'ST': 'SUBTENENTE',
                '1S': '1º SARGENTO',
                '2S': '2º SARGENTO',
                '3S': '3º SARGENTO',
                'CAB': 'CABO',
                'SD': 'SOLDADO'
            }
            
            nome_posto = nomes_postos.get(posto, posto)
            story.append(Paragraph(f"<b>{nome_posto} ({len(militares)})</b>", style_subtitle))
            story.append(Spacer(1, 8))
            
            # Cabeçalho da tabela
            header_data = [['ORD', 'CPF', 'POSTO/GRADUAÇÃO', 'NOME', 'ANTIGUIDADE', 'DATA PROMOÇÃO']]
            
            # Dados dos militares
            for i, militar in enumerate(militares, 1):
                # Criptografar CPF
                cpf_criptografado = criptografar_cpf(militar.cpf)
                
                header_data.append([
                    str(i),
                    cpf_criptografado,
                    militar.get_posto_graduacao_display(),
                    militar.nome_completo,
                    str(militar.numeracao_antiguidade or '-'),
                    militar.data_promocao_atual.strftime('%d/%m/%Y') if militar.data_promocao_atual else '-'
                ])
            
            # Criar tabela com larguras específicas
            table = Table(header_data, colWidths=[1.5*cm, 3*cm, 4*cm, 6*cm, 2*cm, 3*cm])
            table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),  # Cabeçalho centralizado
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('ALIGN', (0, 1), (0, -1), 'CENTER'),  # ORD centralizada
                ('ALIGN', (1, 1), (1, -1), 'CENTER'),  # CPF centralizado
                ('ALIGN', (2, 1), (2, -1), 'CENTER'),  # POSTO centralizado
                ('ALIGN', (3, 1), (3, -1), 'LEFT'),    # NOME alinhado à esquerda
                ('ALIGN', (4, 1), (4, -1), 'CENTER'),  # ANTIGUIDADE centralizada
                ('ALIGN', (5, 1), (5, -1), 'CENTER'),  # DATA centralizada
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'), # Alinhamento vertical centralizado
                ('LEFTPADDING', (0, 0), (-1, -1), 4),
                ('RIGHTPADDING', (0, 0), (-1, -1), 4),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
            ]))
            
            story.append(table)
            story.append(Spacer(1, 15))

    # Estatísticas
    story.append(Spacer(1, 20))
    stats_data = [
        ['ESTATÍSTICAS', ''],
        ['Total de Militares', str(total)],
    ]
    
    if tipo == 'GERAL':
        stats_data.extend([
            ['Oficiais', str(len(oficiais))],
            ['Praças', str(len(pracas))],
        ])
    
    stats_table = Table(stats_data, colWidths=[8*cm, 4*cm])
    stats_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 30))
    
    # Data e local
    story.append(Paragraph(f"Teresina, {data_formatada}", style_center))
    
    # Rodapé com QR Code para conferência de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Gerar QR Code com informações do documento
    qr_data = f"ALMANAQUE {tipo} - CBMEPI - {data_atual.strftime('%d/%m/%Y %H:%M')}"
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(qr_data)
    qr.make(fit=True)
    
    # Criar imagem do QR Code
    qr_img = qr.make_image(fill_color="black", back_color="white")
    qr_buffer = BytesIO()
    qr_img.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    
    # Adicionar QR Code ao PDF
    story.append(Image(qr_buffer, width=2*cm, height=2*cm, hAlign='CENTER'))
    story.append(Spacer(1, 6))
    
    # Texto de autenticação
    texto_autenticacao = f"""
    <b>DOCUMENTO OFICIAL</b><br/>
    Almanaque {tipo} do Corpo de Bombeiros Militar do Estado do Piauí<br/>
    Gerado em {data_atual.strftime('%d/%m/%Y às %H:%M:%S')}<br/>
    Total de militares: {total}<br/>
    <i>Este documento pode ser verificado através do QR Code acima</i>
    """
    
    story.append(Paragraph(texto_autenticacao, style_small))
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o conteúdo do PDF
    pdf_content = buffer.getvalue()
    buffer.close()
    
    return pdf_content

@login_required
def almanaque_visualizar(request, pk):
    """Visualiza um almanaque - abre o PDF em nova aba"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if almanaque.arquivo_pdf:
        # Redirecionar para o PDF em nova aba
        return redirect(almanaque.arquivo_pdf.url)
    else:
        messages.error(request, 'PDF não encontrado para este almanaque.')
        return redirect('militares:almanaque_list')

@login_required
def almanaque_assinar(request, pk):
    """Assina um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if request.method == 'POST':
        # Verificar se já assinou
        if AssinaturaAlmanaque.objects.filter(almanaque=almanaque, assinado_por=request.user).exists():
            messages.warning(request, 'Você já assinou este almanaque.')
            return redirect('militares:almanaque_visualizar', pk=pk)
        
        # Criar assinatura
        assinatura = AssinaturaAlmanaque.objects.create(
            almanaque=almanaque,
            assinado_por=request.user,
            cargo_funcao=request.POST.get('cargo_funcao', ''),
            observacoes=request.POST.get('observacoes', '')
        )
        
        messages.success(request, 'Almanaque assinado com sucesso!')
        return redirect('militares:almanaque_visualizar', pk=pk)
    
    # Buscar cargos/funções do usuário
    cargos_funcoes = UsuarioFuncao.objects.filter(usuario=request.user, ativo=True)
    
    context = {
        'almanaque': almanaque,
        'cargos_funcoes': cargos_funcoes,
        'title': f'Assinar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_assinar.html', context)

@login_required
def almanaque_gerar_pdf_com_assinaturas(request, pk):
    """Gera PDF do almanaque com assinaturas"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    # Buscar assinaturas
    assinaturas = AssinaturaAlmanaque.objects.filter(almanaque=almanaque).order_by('data_assinatura')
    
    # Gerar PDF com assinaturas
    pdf_content = gerar_pdf_almanaque_com_assinaturas(almanaque, assinaturas)
    
    # Criar resposta HTTP
    response = HttpResponse(pdf_content, content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="almanaque_{almanaque.tipo}_{almanaque.data_geracao.strftime("%Y%m%d_%H%M%S")}_assinado.pdf"'
    
    return response

def gerar_pdf_almanaque_com_assinaturas(almanaque, assinaturas):
    """Gera PDF do almanaque com assinaturas"""
    # Criar buffer para o PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    story = []
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1,
        textColor=colors.darkblue
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        textColor=colors.darkblue
    )
    
    # Título principal
    story.append(Paragraph("ALMANAQUE DOS MILITARES", title_style))
    story.append(Paragraph(f"Título: {almanaque.titulo}", subtitle_style))
    story.append(Paragraph(f"Tipo: {almanaque.get_tipo_display()}", subtitle_style))
    story.append(Paragraph(f"Data de Geração: {almanaque.data_geracao.strftime('%d/%m/%Y às %H:%M')}", subtitle_style))
    story.append(Spacer(1, 20))
    
    # Estatísticas
    story.append(Paragraph("ESTATÍSTICAS", subtitle_style))
    stats_data = [
        ['Categoria', 'Quantidade'],
        ['Oficiais', str(almanaque.total_oficiais)],
        ['Praças', str(almanaque.total_pracas)],
        ['Total', str(almanaque.total_geral)]
    ]
    
    stats_table = Table(stats_data, colWidths=[2*inch, 1*inch])
    stats_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
    ]))
    
    story.append(stats_table)
    story.append(PageBreak())
    
    # Seção de assinaturas
    if assinaturas.exists():
        story.append(Paragraph("ASSINATURAS", subtitle_style))
        story.append(Spacer(1, 20))
        
        # Tabela de assinaturas
        assinaturas_data = [['Assinado por', 'Cargo/Função', 'Data', 'Observações']]
        
        for assinatura in assinaturas:
            assinaturas_data.append([
                assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username,
                assinatura.cargo_funcao,
                assinatura.data_assinatura.strftime('%d/%m/%Y às %H:%M'),
                assinatura.observacoes or '-'
            ])
        
        assinaturas_table = Table(assinaturas_data, colWidths=[2*inch, 2*inch, 1*inch, 2*inch])
        assinaturas_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
        ]))
        
        story.append(assinaturas_table)
    else:
        story.append(Paragraph("Nenhuma assinatura registrada.", subtitle_style))
    
    # Construir PDF
    doc.build(story)
    pdf_content = buffer.getvalue()
    buffer.close()
    
    return pdf_content

@admin_bypass
def criar_usuario_admin_web(request):
    """View para criar usuários admin via web"""
    
    if request.method == 'POST':
        username = request.POST.get('username')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        
        # Validações
        if not username or not password:
            messages.error(request, 'Username e senha são obrigatórios!')
            return redirect('militares:criar_usuario_admin')
        
        if password != confirm_password:
            messages.error(request, 'Senhas não coincidem!')
            return redirect('militares:criar_usuario_admin')
        
        if User.objects.filter(username=username).exists():
            messages.error(request, f'Usuário "{username}" já existe!')
            return redirect('militares:criar_usuario_admin')
        
        try:
            # Criar usuário
            user = User.objects.create_user(
                username=username,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                is_staff=True,
                is_superuser=True,
                is_active=True
            )
            
            # Configurar permissões
            todas_permissoes = Permission.objects.all()
            user.user_permissions.set(todas_permissoes)
            
            # Adicionar a todos os grupos
            todos_grupos = Group.objects.all()
            for grupo in todos_grupos:
                user.groups.add(grupo)
            
            # Configurar função de administrador
            cargo_admin = CargoFuncao.objects.get_or_create(
                nome='Administrador',
                defaults={
                    'descricao': 'Administrador do sistema com acesso total',
                    'ativo': True
                }
            )[0]
            
            UsuarioFuncao.objects.get_or_create(
                usuario=user,
                cargo_funcao=cargo_admin,
                defaults={
                    'tipo_funcao': 'EFETIVA',
                    'status': 'ATIVO',
                    'data_inicio': '2024-01-01'
                }
            )
            
            messages.success(request, f'Usuário admin "{username}" criado com sucesso!')
            return redirect('militares:listar_usuarios_admin')
            
        except Exception as e:
            messages.error(request, f'Erro ao criar usuário: {e}')
            return redirect('militares:criar_usuario_admin')
    
    return render(request, 'militares/usuarios/criar_usuario_admin.html')

@admin_bypass
def listar_usuarios_admin_web(request):
    """View para listar usuários admin via web"""
    
    admins = User.objects.filter(is_superuser=True).order_by('username')
    
    # Buscar funções de cada admin
    for admin in admins:
        admin.funcao_ativa = UsuarioFuncao.objects.filter(
            usuario=admin,
            status='ATIVO'
        ).first()
    
    context = {
        'admins': admins,
    }
    
    return render(request, 'militares/usuarios/listar_usuarios_admin.html', context)

@admin_bypass
def remover_usuario_admin_web(request, user_id):
    """View para remover usuário admin via web"""
    
    try:
        user = User.objects.get(id=user_id)
        
        if not user.is_superuser:
            messages.error(request, f'Usuário "{user.username}" não é admin!')
            return redirect('militares:listar_usuarios_admin')
        
        if user.username == 'admin':
            messages.error(request, 'Não é possível remover o usuário admin principal!')
            return redirect('militares:listar_usuarios_admin')
        
        username = user.username
        user.delete()
        
        messages.success(request, f'Usuário admin "{username}" removido com sucesso!')
        
    except User.DoesNotExist:
        messages.error(request, 'Usuário não encontrado!')
    
    return redirect('militares:listar_usuarios_admin')

@admin_bypass
def gerenciar_usuarios_admin(request):
    """View principal para gerenciar usuários admin"""
    
    total_admins = User.objects.filter(is_superuser=True).count()
    admins_ativos = User.objects.filter(is_superuser=True, is_active=True).count()
    
    context = {
        'total_admins': total_admins,
        'admins_ativos': admins_ativos,
    }
    
    return render(request, 'militares/usuarios/gerenciar_usuarios_admin.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_list_paginada(request):
    """Lista todos os militares ativos com paginação simples"""
    # Buscar todos os militares ativos
    militares = Militar.objects.filter(situacao='AT').order_by('nome_completo')
    
    # Paginação
    itens_por_pagina = request.GET.get('itens_por_pagina', 20)
    try:
        itens_por_pagina = int(itens_por_pagina)
        if itens_por_pagina not in [20, 50, 100]:
            itens_por_pagina = 20
    except (ValueError, TypeError):
        itens_por_pagina = 20
    
    paginator = Paginator(militares, itens_por_pagina)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': militares.count(),
    }
    
    return render(request, 'militares/militar_list.html', context) 

@login_required
def almanaque_preview(request):
    """Gera preview HTML do almanaque"""
    from django.http import JsonResponse
    
    tipo = request.GET.get('tipo', 'GERAL')
    titulo = request.GET.get('titulo', '')
    observacoes = request.GET.get('observacoes', '')
    
    try:
        # Obter dados organizados
        dados_organizados, titulo_final, total = obter_dados_almanaque(tipo)
        
        # Gerar HTML
        html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
        
        return JsonResponse({
            'success': True,
            'html': html_content,
            'total': total
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        })

@login_required
def almanaque_gerar_pdf_preview(request):
    """Gera PDF do almanaque baseado no preview"""
    tipo = request.GET.get('tipo', 'GERAL')
    titulo = request.GET.get('titulo', '')
    observacoes = request.GET.get('observacoes', '')
    
    # Gerar o PDF usando a função correta
    from .pdf_utils import gerar_pdf_almanaque_direct_old
    pdf_content = gerar_pdf_almanaque_direct_old(tipo)
    
    # Criar resposta HTTP
    response = HttpResponse(pdf_content, content_type='application/pdf')
    filename = f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response

def obter_dados_almanaque(tipo):
    """Função auxiliar para obter dados organizados do almanaque"""
    # Definir ordem hierárquica dos postos
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos (excluindo NVRR)
    militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR').order_by('posto_graduacao', 'numeracao_antiguidade', 'data_promocao_atual')
    
    # Separar oficiais e praças (excluindo NVRR)
    oficiais = []
    pracas = []
    
    for militar in militares_ativos:
        if militar.quadro == 'NVRR':
            continue
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Determinar título e dados baseado no tipo
    if tipo == 'OFICIAIS':
        titulo = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = oficiais_organizados
        total = len(oficiais)
    elif tipo == 'PRACAS':
        titulo = "ALMANAQUE DAS PRAÇAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = pracas_organizadas
        total = len(pracas)
    else:  # GERAL
        titulo = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÍ"
        dados_organizados = {**oficiais_organizados, **pracas_organizadas}
        total = len(militares_ativos)
    
    return dados_organizados, titulo, total

def criptografar_cpf(cpf):
    """
    Criptografa o CPF mostrando apenas os primeiros 3 dígitos e os últimos 2
    Exemplo: 123.456.789-00 -> 123.***.***-00
    """
    if not cpf:
        return cpf
    
    # Remover pontos e traços
    cpf_limpo = cpf.replace('.', '').replace('-', '')
    
    if len(cpf_limpo) != 11:
        return cpf
    
    # Retornar CPF criptografado
    return f"{cpf_limpo[:3]}.***.***-{cpf_limpo[-2:]}"

def gerar_html_almanaque(dados_organizados, titulo, observacoes, tipo):
    """Gera HTML do almanaque para preview"""
    from django.template.loader import render_to_string
    
    # Mapear postos para nomes completos
    nomes_postos = {
        'CB': 'CORONEL',
        'TC': 'TENENTE-CORONEL',
        'MJ': 'MAJOR',
        'CP': 'CAPITÃO',
        '1T': '1º TENENTE',
        '2T': '2º TENENTE',
        'AS': 'ASPIRANTE',
        'AA': 'ALUNO-ASTO',
        'ST': 'SUBTENENTE',
        '1S': '1º SARGENTO',
        '2S': '2º SARGENTO',
        '3S': '3º SARGENTO',
        'CAB': 'CABO',
        'SD': 'SOLDADO'
    }
    
    # Preparar dados para o template
    secoes = []
    ordem_total = 1
    
    for posto, militares in dados_organizados.items():
        if militares:
            secao = {
                'posto': posto,
                'nome_posto': nomes_postos.get(posto, posto),
                'militares': []
            }
            
            for militar in militares:
                # Criptografar CPF
                cpf_criptografado = criptografar_cpf(militar.cpf)
                
                secao['militares'].append({
                    'ordem': ordem_total,
                    'cpf': cpf_criptografado,
                    'posto': militar.get_posto_graduacao_display(),
                    'nome': militar.nome_completo,
                    'antiguidade': militar.numeracao_antiguidade or '-',
                    'data_promocao': militar.data_promocao_atual.strftime('%d/%m/%Y') if militar.data_promocao_atual else '-'
                })
                ordem_total += 1
            
            secoes.append(secao)
    
    # Renderizar template HTML
    context = {
        'titulo': titulo,
        'observacoes': observacoes,
        'secoes': secoes,
        'total': ordem_total - 1,
        'tipo': tipo,
        'data_geracao': timezone.now().strftime('%d/%m/%Y às %H:%M')
    }
    
    try:
        return render_to_string('militares/almanaque_preview_content.html', context)
    except Exception as e:
        # Fallback: gerar HTML simples se o template falhar
        html_simple = f"""
        <div class="almanaque-preview">
            <h1>{titulo}</h1>
            <p>Gerado em {timezone.now().strftime('%d/%m/%Y às %H:%M')}</p>
            <p>Total de militares: {ordem_total - 1}</p>
            <p>Tipo: {tipo}</p>
        </div>
        """
        return html_simple

@login_required
def almanaque_gerar_html_pdf(request):
    """Gera PDF do almanaque a partir do HTML e salva no banco"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo', 'GERAL')
        titulo = request.POST.get('titulo', '')
        observacoes = request.POST.get('observacoes', '')
    else:
        tipo = request.GET.get('tipo', 'GERAL')
        titulo = request.GET.get('titulo', '')
        observacoes = request.GET.get('observacoes', '')
    
    # Obter dados organizados do almanaque
    dados_organizados, titulo_padrao, total = obter_dados_almanaque(tipo)
    
    # Usar título personalizado se fornecido, senão usar o padrão
    titulo_final = titulo if titulo else titulo_padrao
    
    # Gerar HTML do almanaque
    html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
    
    # Gerar PDF a partir do HTML
    try:
        from .pdf_utils import gerar_pdf_almanaque_direct_old
        pdf_content = gerar_pdf_almanaque_direct_old(tipo)
    except Exception as e:
        # Fallback para o método original
        pdf_content = gerar_pdf_almanaque(tipo)
    
    # Se for POST, salvar no banco de dados
    if request.method == 'POST':
        try:
            # Definir data da última promoção baseada na data de criação
            from datetime import date
            data_atual = date.today()
            
            # Datas de promoção conhecidas
            data_promocao_1 = date(2025, 7, 18)   # 18/07/2025
            data_promocao_2_oficiais = date(2025, 12, 23)  # 23/12/2025
            data_promocao_2_pracas = date(2025, 12, 25)    # 25/12/2025
            
            # Determinar qual data de promoção usar baseada na data atual
            if tipo == 'OFICIAIS':
                if data_atual <= data_promocao_2_oficiais:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_oficiais  # 23/12/2025
            elif tipo == 'PRACAS':
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            else:  # GERAL
                # Para geral, usar a data mais recente entre todas as promoções
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            
            # Salvar no banco
            almanaque = AlmanaqueMilitar.objects.create(
                titulo=titulo_final,
                tipo=tipo,
                observacoes=observacoes,
                arquivo_pdf=ContentFile(pdf_content, name=f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'),
                conteudo_html=html_content,
                data_ultima_promocao=data_ultima_promocao
            )
            
            # Atualizar estatísticas
            militares_ativos = Militar.objects.filter(situacao='AT')
            oficiais = [m for m in militares_ativos if m.is_oficial()]
            pracas = [m for m in militares_ativos if not m.is_oficial()]
            
            almanaque.total_oficiais = len(oficiais)
            almanaque.total_pracas = len(pracas)
            almanaque.total_geral = len(militares_ativos)
            almanaque.save()
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" gerado e salvo com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao salvar almanaque: {str(e)}')
            return redirect('militares:almanaque_create')
    
    # Se for GET, apenas retornar o PDF para download
    response = HttpResponse(pdf_content, content_type='application/pdf')
    filename = f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response

@login_required
def exportar_militares_excel(request):
    """
    Exporta a lista de militares para Excel
    """
    from django.http import HttpResponse
    import csv
    from datetime import datetime
    
    # Obter militares ativos (mesma lógica da view de listagem)
    militares = Militar.objects.filter(situacao='AT')
    
    # Aplicar filtros se fornecidos
    query = request.GET.get('q')
    if query:
        militares = militares.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query) |
            Q(cpf__icontains=query) |
            Q(email__icontains=query)
        )
    
    posto = request.GET.get('posto')
    if posto:
        posto_mapping = {
            'cb': 'CB', 'tc': 'TC', 'mj': 'MJ', 'cp': 'CP',
            '1t': '1T', '2t': '2T', 'st': 'ST', '1s': '1S',
            '2s': '2S', '3s': '3S', 'cab': 'CAB', 'sd': 'SD', 'nvrr': 'NVRR'
        }
        posto_codigo = posto_mapping.get(posto.lower())
        if posto_codigo:
            militares = militares.filter(posto_graduacao=posto_codigo)
    
    situacao = request.GET.get('situacao')
    if situacao:
        situacao_mapping = {'at': 'AT', 'in': 'IN'}
        situacao_codigo = situacao_mapping.get(situacao.lower())
        if situacao_codigo:
            militares = militares.filter(situacao=situacao_codigo)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Ordenar por hierarquia e antiguidade
    hierarquia_postos = {
        'CB': 1, 'TC': 2, 'MJ': 3, 'CP': 4, '1T': 5, '2T': 6, 'AS': 7, 'AA': 8,
        'ST': 9, '1S': 10, '2S': 11, '3S': 12, 'CAB': 13, 'SD': 14, 'NVRR': 15
    }
    
    # OTIMIZAÇÃO: Usar ordenação no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
        hierarquia_postos.get(x.posto_graduacao, 999),
        0 if (x.posto_graduacao == 'NVRR' or x.quadro == 'NVRR') else (x.numeracao_antiguidade or 999999),
        x.nome_completo
    ))
    
    # Criar resposta HTTP
    response = HttpResponse(content_type='text/csv; charset=utf-8')
    response['Content-Disposition'] = f'attachment; filename="militares_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv"'
    
    # Adicionar BOM para UTF-8 (importante para Excel)
    response.write('\ufeff')
    
    # Criar writer CSV
    writer = csv.writer(response, delimiter=';')
    
    # Cabeçalhos
    headers = [
        'Matrícula',
        'Nome Completo',
        'Nome de Guerra',
        'CPF',
        'Posto/Graduação',
        'Quadro',
        'Numeração de Antiguidade',
        'Data de Nascimento',
        'Idade',
        'Data de Ingresso',
        'Tempo de Serviço',
        'Data da Última Promoção',
        'Tempo no Posto Atual',
        'E-mail',
        'Telefone',
        'Celular',
        'Situação',
        'Observações'
    ]
    writer.writerow(headers)
    
    # Dados dos militares
    for militar in militares:
        # Calcular idade
        from datetime import date
        hoje = date.today()
        idade = hoje.year - militar.data_nascimento.year - ((hoje.month, hoje.day) < (militar.data_nascimento.month, militar.data_nascimento.day))
        
        # Calcular tempo de serviço
        tempo_servico = hoje.year - militar.data_ingresso.year - ((hoje.month, hoje.day) < (militar.data_ingresso.month, militar.data_ingresso.day))
        
        # Calcular tempo no posto atual
        tempo_posto = hoje.year - militar.data_promocao_atual.year - ((hoje.month, hoje.day) < (militar.data_promocao_atual.month, militar.data_promocao_atual.day))
        
        row = [
            militar.matricula,
            militar.nome_completo,
            militar.nome_guerra or '',
            militar.cpf,
            militar.get_posto_graduacao_display(),
            militar.get_quadro_display(),
            militar.numeracao_antiguidade or 'NVRR' if (militar.posto_graduacao == 'NVRR' or militar.quadro == 'NVRR') else militar.numeracao_antiguidade or '',
            militar.data_nascimento.strftime('%d/%m/%Y'),
            idade,
            militar.data_ingresso.strftime('%d/%m/%Y'),
            tempo_servico,
            militar.data_promocao_atual.strftime('%d/%m/%Y'),
            tempo_posto,
            militar.email or '',
            militar.telefone or '',
            militar.celular or '',
            militar.get_situacao_display(),
            militar.observacoes or ''
        ]
        writer.writerow(row)
    
    return response
# ============================================================================
# VIEWS PARA GERENCIAMENTO DE CARGOS/FUN  ES
@login_required
def cargo_funcao_list(request):
    """Lista todos os cargos/funções do sistema"""
    cargos = CargoFuncao.objects.all().order_by('ordem', 'nome')
    
    # Adicionar contadores para cada cargo
    for cargo in cargos:
        cargo.permissoes_count = PermissaoFuncao.objects.filter(cargo_funcao=cargo, ativo=True).count()
        cargo.usuarios_count = UsuarioFuncao.objects.filter(cargo_funcao=cargo).count()
    
    # Estatísticas gerais
    total_cargos = cargos.count()
    cargos_ativos = cargos.filter(ativo=True).count()
    total_permissoes = PermissaoFuncao.objects.filter(ativo=True).count()
    total_usuarios = UsuarioFuncao.objects.count()
    
    context = {
        'cargos': cargos,
        'total_cargos': total_cargos,
        'cargos_ativos': cargos_ativos,
        'total_permissoes': total_permissoes,
        'total_usuarios': total_usuarios,
        'title': 'Cargos e Funções',
    }
    return render(request, 'militares/cargos/cargo_funcao_list.html', context) 
@login_required
def cargo_funcao_create(request):
    """Cria um novo cargo/função do sistema"""
    if request.method == 'POST':
        form = CargoFuncaoForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo/Função criado com sucesso!')
            return redirect('militares:cargo_funcao_list')
    else:
        form = CargoFuncaoForm()
    context = {
        'form': form,
        'action': 'Novo',
        'title': 'Novo Cargo/Função',
    }
    return render(request, 'militares/cargos/cargo_funcao_form.html', context)
@login_required
def cargo_funcao_detail(request, cargo_id):
    """Exibe os detalhes de um cargo/função do sistema"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    # Buscar permissões do cargo
    permissoes = PermissaoFuncao.objects.filter(cargo_funcao=cargo, ativo=True).order_by('modulo', 'acesso')
    
    # Agrupar permissões por módulo
    permissoes_por_modulo = {}
    for permissao in permissoes:
        if permissao.modulo not in permissoes_por_modulo:
            permissoes_por_modulo[permissao.modulo] = []
        permissoes_por_modulo[permissao.modulo].append(permissao)
    
    # Buscar usuários com esta função (total, sem filtros)
    usuarios_com_funcao_total = UsuarioFuncao.objects.filter(
        cargo_funcao=cargo
    ).select_related('usuario').order_by('usuario__first_name')
    
    # Contar usuários total (para decisão de mostrar botão delete)
    usuarios_count_total = usuarios_com_funcao_total.count()
    
    # Aplicar filtros para exibição
    usuarios_com_funcao = usuarios_com_funcao_total
    status_filtro = request.GET.get('status')
    if status_filtro:
        usuarios_com_funcao = usuarios_com_funcao.filter(status=status_filtro)
    
    tipo_filtro = request.GET.get('tipo')
    if tipo_filtro:
        usuarios_com_funcao = usuarios_com_funcao.filter(tipo_funcao=tipo_filtro)
    
    # Estatísticas dos usuários (após filtros)
    usuarios_ativos_count = usuarios_com_funcao.filter(status='ATIVO').count()
    usuarios_inativos_count = usuarios_com_funcao.filter(status='INATIVO').count()
    usuarios_suspensos_count = usuarios_com_funcao.filter(status='SUSPENSO').count()
    
    context = {
        'cargo': cargo,
        'permissoes_por_modulo': permissoes_por_modulo,
        'permissoes_count': permissoes.count(),
        'usuarios_com_funcao': usuarios_com_funcao,
        'usuarios_count': usuarios_count_total,  # Usar o total, não o filtrado
        'usuarios_ativos_count': usuarios_ativos_count,
        'usuarios_inativos_count': usuarios_inativos_count,
        'usuarios_suspensos_count': usuarios_suspensos_count,
        'title': f'Detalhes do Cargo/Função: {cargo.nome}',
        # Filtros aplicados
        'status_filtro': status_filtro,
        'tipo_filtro': tipo_filtro,
    }
    return render(request, 'militares/cargos/cargo_funcao_detail.html', context)

@login_required
def adicionar_usuario_cargo(request, cargo_id):
    """Adiciona um usuário a um cargo específico"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST)
        if form.is_valid():
            # Verificar se já existe uma função com a mesma combinação
            usuario = form.cleaned_data['usuario']
            data_inicio = form.cleaned_data['data_inicio']
            
            funcao_existente = UsuarioFuncao.objects.filter(
                usuario=usuario,
                cargo_funcao=cargo,
                data_inicio=data_inicio
            ).first()
            
            if funcao_existente:
                messages.error(request, f'Já existe uma função "{cargo.nome}" para este usuário com a data de início {data_inicio}.')
                context = {
                    'form': form,
                    'cargo': cargo,
                }
                return render(request, 'militares/cargos/adicionar_usuario_cargo.html', context)
            
            funcao = form.save(commit=False)
            funcao.cargo_funcao = cargo
            funcao.save()
            messages.success(request, f'Usuário "{funcao.usuario.get_full_name()}" adicionado ao cargo "{cargo.nome}" com sucesso!')
            return redirect('militares:cargo_funcao_detail', cargo_id=cargo.id)
    else:
        form = UsuarioFuncaoForm()
    
    context = {
        'form': form,
        'cargo': cargo,
        'title': f'Adicionar Usuário ao Cargo: {cargo.nome}',
    }
    return render(request, 'militares/cargos/adicionar_usuario_cargo.html', context)

@login_required
def cargo_funcao_update(request, cargo_id):
    """Edita um cargo/função do sistema"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    if request.method == 'POST':
        form = CargoFuncaoForm(request.POST, instance=cargo)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo/Função atualizado com sucesso!')
            return redirect('militares:cargo_funcao_detail', cargo_id=cargo.id)
    else:
        form = CargoFuncaoForm(instance=cargo)
    context = {
        'form': form,
        'action': 'Editar',
        'title': f'Editar Cargo/Função: {cargo.nome}',
        'cargo': cargo,
    }
    return render(request, 'militares/cargos/cargo_funcao_form.html', context)
