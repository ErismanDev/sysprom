from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test, permission_required
from django.contrib.auth import update_session_auth_hash
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password
from django.core.paginator import Paginator
from django.db.models import Q, Sum, Count
from django.db.models.deletion import ProtectedError
from django.http import JsonResponse, HttpResponse
from django.utils import timezone
from datetime import date, datetime
from django.contrib.auth.models import User, Group, Permission
from django.db import models, IntegrityError
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.http import JsonResponse
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import Promocao
from .models import Vaga
from django import forms
from django.http import FileResponse
from django.http import FileResponse
from .models import JustificativaEncerramento
from .models import AtaSessao
from .forms import AtaSessaoForm
from .models import AtaSessao
from .models import AtaSessao, AssinaturaAta
from .models import AtaSessao
from django.http import HttpResponse
from django.utils import timezone
from .models import AtaSessao
from django.utils import timezone
from .models import ModeloAta
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .models import ModeloAta
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .forms import ModeloAtaForm
from django import forms
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.db import models
from django.core.paginator import Paginator
from django.contrib.auth.models import User, Group, Permission
from django.contrib.contenttypes.models import ContentType
from django import forms
# from dal import autocomplete

# Importar views especÃ­ficas para praÃ§as
from .views_pracas_import import *
from .utils import calcular_proxima_data_promocao
from .models import (
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Promocao, Vaga, Curso, MedalhaCondecoracao, Documento, Intersticio,
    POSTO_GRADUACAO_CHOICES, SITUACAO_CHOICES, QUADRO_CHOICES,
    PrevisaoVaga, AssinaturaQuadroAcesso, ComissaoPromocao, MembroComissao, SessaoComissao, PresencaSessao, DeliberacaoComissao, VotoDeliberacao, DocumentoSessao, AtaSessao, ModeloAta, CargoComissao,
    VagaManual, QuadroFixacaoVagas, ItemQuadroFixacaoVagas, UsuarioFuncao,
    CargoFuncao, PermissaoFuncao, PerfilAcesso
)
from .forms import MilitarForm, DocumentoForm, UserRegistrationForm, ConfirmarSenhaForm, ComissaoPromocaoForm, MembroComissaoForm, SessaoComissaoForm, DeliberacaoComissaoForm, DocumentoSessaoForm, AtaSessaoForm, ModeloAtaForm, CargoComissaoForm, FichaConceitoPracasForm, FichaConceitoOficiaisForm, UsuarioFuncaoForm, UsuarioForm
from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required
from django import forms
from django.contrib.auth import authenticate
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from io import BytesIO
import qrcode
from reportlab.lib.utils import ImageReader
import os
from reportlab.lib.enums import TA_JUSTIFY
import re
from html import unescape
import logging


@login_required
def teste_modal(request):
    """View temporÃ¡ria para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporÃ¡ria para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporÃ¡ria para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporÃ¡ria para testar modal simples"""
    return render(request, 'teste_modal_simples.html')


@login_required
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    

    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        militares = sorted(militares, key=lambda x: (
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')
    

    
    # Sem paginaÃ§Ã£o - mostrar todos os militares
    context = {
        'militares': militares,
    }
    
    return render(request, 'militares/militar_list.html', context)


@login_required
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)


def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    logger.info(f'ğŸ” Busca AJAX recebida: {query}')
    logger.info(f'ğŸ“¡ MÃ©todo da requisiÃ§Ã£o: {request.method}')
    logger.info(f'ğŸ“¡ Headers: {dict(request.headers)}')
    
    if len(query) < 2:
        logger.info('âš ï¸ Query muito curta, retornando vazio')
        return JsonResponse({'results': []})
    
    try:
        # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
        militares = Militar.objects.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query)
        ).exclude(
            posto_graduacao='CB'  # Excluir coronÃ©is
        )[:10]
        
        logger.info(f'âœ… Encontrados {militares.count()} militares')
        
        results = []
        for militar in militares:
            result = {
                'id': militar.id,
                'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
                'nome': militar.nome_completo,
                'matricula': militar.matricula,
                'posto': militar.get_posto_graduacao_display(),
            }
            results.append(result)
            logger.info(f'ğŸ‘¤ Militar encontrado: {result["nome"]} ({result["posto"]})')
        
        logger.info(f'ğŸ“¦ Retornando {len(results)} resultados')
        return JsonResponse({'results': results})
        
    except Exception as e:
        logger.error(f'âŒ Erro na busca AJAX: {str(e)}')
        logger.error(f'âŒ Stack trace: {e.__traceback__}')
        return JsonResponse({'results': [], 'error': str(e)}, status=500)


def buscar_usuarios_ajax(request):
    """Busca usuÃ¡rios via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    comissao_tipo = request.GET.get('comissao_tipo', '')  # CPO ou CPP
    logger.info(f'ğŸ” Busca de usuÃ¡rios AJAX recebida: {query} (comissÃ£o: {comissao_tipo})')
    
    if len(query) < 2:
        logger.info('âš ï¸ Query muito curta, retornando vazio')
        return JsonResponse({'usuarios': []})
    
    try:
        # Buscar usuÃ¡rios que tÃªm militares vinculados e estÃ£o ativos
        usuarios = User.objects.filter(
            militar__isnull=False,  # Apenas usuÃ¡rios com militar vinculado
            militar__situacao='AT',  # Apenas militares ativos
            is_active=True  # Apenas usuÃ¡rios ativos
        ).filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query)
        )
        
        # Filtrar por tipo de comissÃ£o se especificado
        if comissao_tipo == 'CPO':
            # Para CPO: apenas usuÃ¡rios com funÃ§Ãµes CPO
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPO',  # Com funÃ§Ã£o CPO
                funcoes__status='ATIVO'  # FunÃ§Ã£o ativa
            ).distinct()
            
        elif comissao_tipo == 'CPP':
            # Para CPP: apenas usuÃ¡rios com funÃ§Ãµes CPP
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPP',  # Com funÃ§Ã£o CPP
                funcoes__status='ATIVO'  # FunÃ§Ã£o ativa
            ).distinct()
        
        usuarios = usuarios.order_by('militar__nome_completo')[:10]
        
        logger.info(f'ğŸ“Š Encontrados {usuarios.count()} usuÃ¡rios')
        
        results = []
        for usuario in usuarios:
            militar = usuario.militar
            
            # Buscar a funÃ§Ã£o especÃ­fica do usuÃ¡rio
            funcao_cpo_cpp = usuario.funcoes.filter(
                status='ATIVO',
                cargo_funcao__nome__icontains=comissao_tipo if comissao_tipo else ''
            ).first()
            
            results.append({
                'id': usuario.id,
                'username': usuario.username,
                'first_name': usuario.first_name,
                'last_name': usuario.last_name,
                'militar': {
                    'id': militar.id,
                    'nome': militar.nome_completo,
                    'posto': militar.get_posto_graduacao_display(),
                    'matricula': militar.matricula,
                },
                'funcao': funcao_cpo_cpp.cargo_funcao.nome if funcao_cpo_cpp else None
            })
        
        logger.info(f'âœ… Retornando {len(results)} resultados')
        return JsonResponse({'usuarios': results})
        
    except Exception as e:
        logger.error(f'âŒ Erro na busca de usuÃ¡rios: {e}')
        return JsonResponse({'usuarios': [], 'error': str(e)})


@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)


# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)


@login_required


@login_required
def teste_modal(request):
    """View temporÃ¡ria para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporÃ¡ria para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporÃ¡ria para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporÃ¡ria para testar modal simples"""
    return render(request, 'teste_modal_simples.html')


@login_required
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    

    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        militares = sorted(militares, key=lambda x: (
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')
    

    
    # Sem paginaÃ§Ã£o - mostrar todos os militares
    context = {
        'militares': militares,
    }
    
    return render(request, 'militares/militar_list.html', context)


@login_required
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)


def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})


@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)


# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)


@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)


# Views para Quadros de Acesso
@login_required
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    quadros = QuadroAcesso.objects.all()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)


@login_required
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    

    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        militares = sorted(militares, key=lambda x: (
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')
    

    
    # Sem paginaÃ§Ã£o - mostrar todos os militares
    context = {
        'militares': militares,
    }
    
    return render(request, 'militares/militar_list.html', context)


@login_required
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)


def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})


@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)


# Views para Ficha de Conceito


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)


@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)


# Views para Quadros de Acesso
@login_required
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    quadros = QuadroAcesso.objects.all()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)


@login_required
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # LÃ³gica especial para o quadro ID 312 - forÃ§ar exibiÃ§Ã£o da transiÃ§Ã£o Major â†’ Tenente-Coronel
    if quadro.id == 312:
        # Criar transiÃ§Ã£o especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transiÃ§Ã£o especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)


@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        categoria = request.POST.get('categoria', 'OFICIAIS')
        
        # Log para debug
        print(f"DEBUG - Tipo: {tipo}")
        print(f"DEBUG - Categoria: {categoria}")
        print(f"DEBUG - Data: {data_promocao}")
        print(f"DEBUG - Todos os POST data: {request.POST}")
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validaÃ§Ã£o que bloqueava quadros para a mesma data/tipo
        # (permitir mÃºltiplos quadros na mesma data)
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            print(f"DEBUG - Criando quadro com categoria: {categoria}")
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            print(f"DEBUG - Quadro criado com ID: {novo_quadro.pk}, categoria: {novo_quadro.categoria}")
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                
                # Redirecionar para a view correta baseada na categoria
                print(f"DEBUG - Redirecionando para categoria: {novo_quadro.categoria}")
                if novo_quadro.categoria == 'PRACAS':
                    print(f"DEBUG - Redirecionando para praÃ§as: quadro_acesso_pracas_detail")
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    print(f"DEBUG - Redirecionando para oficiais: quadro_acesso_detail")
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)


@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)


@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)


@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')


@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)


@login_required
def quadro_acesso_pdf(request, pk):
    """Gera PDF do quadro de acesso no modelo institucional solicitado"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    tipo_quadro = quadro.get_tipo_display().upper()
    # O get_tipo_display() jÃ¡ retorna "QUADRO DE ACESSO POR ANTIGUIDADE" ou "QUADRO DE ACESSO POR MERECIMENTO"
    # EntÃ£o usamos diretamente o valor retornado
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio com data em portuguÃªs
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Definir tipo e sigla do quadro
    if quadro.tipo == 'ANTIGUIDADE':
        tipo_quadro = 'por Antiguidade'
        sigla_quadro = 'QAA'
    elif quadro.tipo == 'MERECIMENTO':
        tipo_quadro = 'por Merecimento'
        sigla_quadro = 'QAM'
    else:
        tipo_quadro = 'Manual'
        sigla_quadro = 'QAM'
    
    texto_intro = (
        f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
        f"que visa Ã s promoÃ§Ãµes do dia {data_formatada}, com fulcro nos artigos 12, 13, c/c Â§ 3Âº do Art. 20, da Lei nÂº 5.461, de 30 de junho de 2005, "
        "alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
    )
    story.append(Paragraph(texto_intro, style_just))
    story.append(Spacer(1, 12))

    # Definir todos os quadros
    quadros_info = [
        {
            'numero': 1,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMBATENTES (QOBM/Comb.)',
            'codigo': 'COMB'
        },
        {
            'numero': 2,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES DE SAÃšDE (QOBM/S)',
            'codigo': 'SAUDE'
        },
        {
            'numero': 3,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES ENGENHEIROS (QOBM/E)',
            'codigo': 'ENG'
        },
        {
            'numero': 4,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMPLEMENTARES (QOBM/C)',
            'codigo': 'COMP'
        }
    ]

    # Definir transiÃ§Ãµes especÃ­ficas por quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Processar cada quadro
    for quadro_info in quadros_info:
        story.append(Spacer(1, 16))
        story.append(Paragraph(f'<b>{quadro_info["numero"]}. {quadro_info["nome"]}</b>', style_center))
        story.append(Spacer(1, 10))

        # Processar cada transiÃ§Ã£o de posto especÃ­fica do quadro
        transicoes_do_quadro = transicoes_por_quadro.get(quadro_info['codigo'], [])
        for transicao in transicoes_do_quadro:
            story.append(Spacer(1, 12))
            story.append(Paragraph(f'<b>{transicao["numero"]} â€“ {transicao["titulo"]}</b>', style_bold))
            story.append(Spacer(1, 6))
            
            # Buscar militares aptos para esta transiÃ§Ã£o neste quadro
            if quadro_info['codigo'] == 'COMP' and transicao['origem'] == 'ST' and transicao['destino'] == '2T':
                # Para transiÃ§Ã£o ST->2T do COMP, incluir subtenentes do quadro PRACAS
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='PRACAS'
                ).order_by('posicao')
            else:
                # Para outras transiÃ§Ãµes, usar filtro normal
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro=quadro_info['codigo']
                ).order_by('posicao')
            
            if aptos.exists():
                # Preparar dados da tabela
                header_data = [['ORD', 'IDENT.', 'POSTO', 'NOME']]
                for idx, item in enumerate(aptos, 1):
                    header_data.append([
                        str(idx),
                        item.militar.matricula,
                        item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                        item.militar.nome_completo
                    ])
                
                # Calcular larguras das colunas baseado no conteÃºdo
                max_ord = max([len(str(row[0])) for row in header_data])
                max_ident = max([len(row[1]) for row in header_data])
                max_posto = max([len(row[2]) for row in header_data])
                
                # Definir larguras mÃ­nimas e ajustÃ¡veis
                col_widths = [
                    max(1.2*cm, max_ord * 0.3*cm),  # ORD
                    max(3*cm, max_ident * 0.3*cm),  # IDENT
                    max(3*cm, max_posto * 0.3*cm),  # POSTO
                    8*cm  # NOME (fixo)
                ]
                
                table = Table(header_data, colWidths=col_widths)
                table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                    ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                    ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ]))
                story.append(table)
            else:
                story.append(Paragraph(transicao['texto'], style_just))
            
            story.append(Spacer(1, 8))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas
    story.append(PageBreak())  # Quebra de pÃ¡gina antes das assinaturas
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas vÃ¡lidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas.exists():
        # TÃ­tulo da seÃ§Ã£o
        story.append(Paragraph('<b>ASSINATURAS ELETRÃ”NICAS</b>', style_bold))
        story.append(Spacer(1, 10))
        
        for i, assinatura in enumerate(assinaturas):
            # InformaÃ§Ãµes de assinatura eletrÃ´nica
            nome_assinante = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrÃ£o
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "UsuÃ¡rio do Sistema"
            
            data_assinatura = assinatura.data_assinatura
            data_formatada = f"{data_assinatura.day:02d}/{data_assinatura.month:02d}/{data_assinatura.year}"
            hora_formatada = f"{data_assinatura.hour:02d}:{data_assinatura.minute:02d}"
            
            # Obter a funÃ§Ã£o atual do usuÃ¡rio
            from .utils import obter_funcao_atual_usuario
            funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema') if request and hasattr(request, 'session') else 'UsuÃ¡rio do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao_atual}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
            
            # Adicionar assinatura visual
            tipo_assinatura = assinatura.get_tipo_assinatura_display()
            assinatura_visual = f"{nome_assinante}\n{funcao_atual}\n{tipo_assinatura}"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
            if i < len(assinaturas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se nÃ£o houver assinaturas, mostrar apenas documento gerado pelo usuÃ¡rio logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "UsuÃ¡rio do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuÃ¡rio {nome_usuario} em {data_formatada}, Ã s {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Dados para autenticaÃ§Ã£o
    url_autenticacao = "https://sei.pi.gov.br/sei/controlador_externo.php?acao=documento_conferir&id_orgao_acesso_externo=0"
    codigo_verificador = f"{quadro.pk:08d}"
    codigo_crc = f"{hash(str(quadro.pk)) % 0xFFFFFFF:07X}"
    
    texto_autenticacao = f"A autenticidade deste documento pode ser conferida no site <a href='{url_autenticacao}' color='blue'>{url_autenticacao}</a>, informando o cÃ³digo verificador <b>{codigo_verificador}</b> e o cÃ³digo CRC <b>{codigo_crc}</b>."
    
    # Gerar QR Code
    qr = qrcode.make(url_autenticacao)
    qr_buffer = BytesIO()
    qr.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    qr_img = Image(qr_buffer, width=2*cm, height=2*cm)
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib import messages
from django.contrib.auth.decorators import login_required, user_passes_test, permission_required
from django.core.paginator import Paginator
from django.db.models import Q, Sum, Count
from django.db.models.deletion import ProtectedError
from django.http import JsonResponse, HttpResponse
from django.utils import timezone
from datetime import date, datetime
from django.contrib.auth.models import User, Group, Permission
from django.db import models
# from dal import autocomplete

# Importar views especÃ­ficas para praÃ§as
from .views_pracas_import import *
from .utils import calcular_proxima_data_promocao
from .models import (
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Promocao, Vaga, Curso, MedalhaCondecoracao, Documento, Intersticio,
    POSTO_GRADUACAO_CHOICES, SITUACAO_CHOICES, QUADRO_CHOICES,
    PrevisaoVaga, AssinaturaQuadroAcesso, ComissaoPromocao, MembroComissao, SessaoComissao, PresencaSessao, DeliberacaoComissao, VotoDeliberacao, DocumentoSessao, AtaSessao, ModeloAta, CargoComissao,
    VagaManual, QuadroFixacaoVagas, ItemQuadroFixacaoVagas
)
from .forms import MilitarForm, DocumentoForm, UserRegistrationForm, ConfirmarSenhaForm, ComissaoPromocaoForm, MembroComissaoForm, SessaoComissaoForm, DeliberacaoComissaoForm, DocumentoSessaoForm, AtaSessaoForm, ModeloAtaForm, CargoComissaoForm, FichaConceitoPracasForm, FichaConceitoOficiaisForm
from django import forms
from django.contrib.auth import authenticate
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from io import BytesIO
import qrcode
from reportlab.lib.utils import ImageReader
import os
from reportlab.lib.enums import TA_JUSTIFY
import re
from html import unescape
import logging


@login_required
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    

    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        militares = sorted(militares, key=lambda x: (
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')
    

    
    # Sem paginaÃ§Ã£o - mostrar todos os militares
    context = {
        'militares': militares,
    }
    
    return render(request, 'militares/militar_list.html', context)


@login_required
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)


def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})


@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)


# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    oficiais_sem_ficha = total_oficiais_ativos - total_fichas_oficiais
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)


@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)


# Views para Quadros de Acesso
@login_required
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    quadros = QuadroAcesso.objects.all()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)


@login_required
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # LÃ³gica especial para o quadro ID 312 - forÃ§ar exibiÃ§Ã£o da transiÃ§Ã£o Major â†’ Tenente-Coronel
    if quadro.id == 312:
        # Criar transiÃ§Ã£o especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transiÃ§Ã£o especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)


@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validaÃ§Ã£o que bloqueava quadros para a mesma data/tipo
        # (permitir mÃºltiplos quadros na mesma data)
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)


@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)


@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)


@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')


@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)


@login_required
def quadro_acesso_pdf(request, pk):
    """Gera PDF do quadro de acesso no modelo institucional solicitado"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    tipo_quadro = quadro.get_tipo_display().upper()
    # O get_tipo_display() jÃ¡ retorna "QUADRO DE ACESSO POR ANTIGUIDADE" ou "QUADRO DE ACESSO POR MERECIMENTO"
    # EntÃ£o usamos diretamente o valor retornado
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio com data em portuguÃªs
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Definir tipo e sigla do quadro
    if quadro.tipo == 'ANTIGUIDADE':
        tipo_quadro = 'por Antiguidade'
        sigla_quadro = 'QAA'
    elif quadro.tipo == 'MERECIMENTO':
        tipo_quadro = 'por Merecimento'
        sigla_quadro = 'QAM'
    else:
        tipo_quadro = 'Manual'
        sigla_quadro = 'QAM'
    
    texto_intro = (
        f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
        f"que visa Ã s promoÃ§Ãµes do dia {data_formatada}, com fulcro nos artigos 12, 13, c/c Â§ 3Âº do Art. 20, da Lei nÂº 5.461, de 30 de junho de 2005, "
        "alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
    )
    story.append(Paragraph(texto_intro, style_just))
    story.append(Spacer(1, 12))

    # Definir todos os quadros
    quadros_info = [
        {
            'numero': 1,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMBATENTES (QOBM/Comb.)',
            'codigo': 'COMB'
        },
        {
            'numero': 2,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES DE SAÃšDE (QOBM/S)',
            'codigo': 'SAUDE'
        },
        {
            'numero': 3,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES ENGENHEIROS (QOBM/E)',
            'codigo': 'ENG'
        },
        {
            'numero': 4,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMPLEMENTARES (QOBM/C)',
            'codigo': 'COMP'
        }
    ]

    # Definir transiÃ§Ãµes especÃ­ficas por quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Processar cada quadro
    for quadro_info in quadros_info:
        story.append(Spacer(1, 16))
        story.append(Paragraph(f'<b>{quadro_info["numero"]}. {quadro_info["nome"]}</b>', style_center))
        story.append(Spacer(1, 10))

        # Processar cada transiÃ§Ã£o de posto especÃ­fica do quadro
        transicoes_do_quadro = transicoes_por_quadro.get(quadro_info['codigo'], [])
        for transicao in transicoes_do_quadro:
            story.append(Spacer(1, 12))
            story.append(Paragraph(f'<b>{transicao["numero"]} â€“ {transicao["titulo"]}</b>', style_bold))
            story.append(Spacer(1, 6))
            
            # Buscar militares aptos para esta transiÃ§Ã£o neste quadro
            if quadro_info['codigo'] == 'COMP' and transicao['origem'] == 'ST' and transicao['destino'] == '2T':
                # Para transiÃ§Ã£o ST->2T do COMP, incluir subtenentes do quadro PRACAS
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='PRACAS'
                ).order_by('posicao')
            else:
                # Para outras transiÃ§Ãµes, usar filtro normal
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro=quadro_info['codigo']
                ).order_by('posicao')
            
            if aptos.exists():
                # Preparar dados da tabela
                header_data = [['ORD', 'IDENT.', 'POSTO', 'NOME']]
                for idx, item in enumerate(aptos, 1):
                    header_data.append([
                        str(idx),
                        item.militar.matricula,
                        item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                        item.militar.nome_completo
                    ])
                
                # Calcular larguras das colunas baseado no conteÃºdo
                max_ord = max([len(str(row[0])) for row in header_data])
                max_ident = max([len(row[1]) for row in header_data])
                max_posto = max([len(row[2]) for row in header_data])
                
                # Definir larguras mÃ­nimas e ajustÃ¡veis
                col_widths = [
                    max(1.2*cm, max_ord * 0.3*cm),  # ORD
                    max(3*cm, max_ident * 0.3*cm),  # IDENT
                    max(3*cm, max_posto * 0.3*cm),  # POSTO
                    8*cm  # NOME (fixo)
                ]
                
                table = Table(header_data, colWidths=col_widths)
                table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                    ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                    ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ]))
                story.append(table)
            else:
                story.append(Paragraph(transicao['texto'], style_just))
            
            story.append(Spacer(1, 8))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas
    story.append(PageBreak())  # Quebra de pÃ¡gina antes das assinaturas
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas vÃ¡lidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas.exists():
        # TÃ­tulo da seÃ§Ã£o
        story.append(Paragraph('<b>ASSINATURAS ELETRÃ”NICAS</b>', style_bold))
        story.append(Spacer(1, 10))
        
        for i, assinatura in enumerate(assinaturas):
            # InformaÃ§Ãµes de assinatura eletrÃ´nica
            nome_assinante = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrÃ£o
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "UsuÃ¡rio do Sistema"
            
            data_assinatura = assinatura.data_assinatura
            data_formatada = f"{data_assinatura.day:02d}/{data_assinatura.month:02d}/{data_assinatura.year}"
            hora_formatada = f"{data_assinatura.hour:02d}:{data_assinatura.minute:02d}"
            
            # Obter a funÃ§Ã£o atual do usuÃ¡rio
            from .utils import obter_funcao_atual_usuario
            funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema') if request and hasattr(request, 'session') else 'UsuÃ¡rio do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao_atual}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
            
            # Adicionar assinatura visual
            tipo_assinatura = assinatura.get_tipo_assinatura_display()
            assinatura_visual = f"{nome_assinante}\n{funcao_atual}\n{tipo_assinatura}"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
            if i < len(assinaturas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se nÃ£o houver assinaturas, mostrar apenas documento gerado pelo usuÃ¡rio logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "UsuÃ¡rio do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuÃ¡rio {nome_usuario} em {data_formatada}, Ã s {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Dados para autenticaÃ§Ã£o
    url_autenticacao = "https://sei.pi.gov.br/sei/controlador_externo.php?acao=documento_conferir&id_orgao_acesso_externo=0"
    codigo_verificador = f"{quadro.pk:08d}"
    codigo_crc = f"{hash(str(quadro.pk)) % 0xFFFFFFF:07X}"
    
    texto_autenticacao = f"A autenticidade deste documento pode ser conferida no site <a href='{url_autenticacao}' color='blue'>{url_autenticacao}</a>, informando o cÃ³digo verificador <b>{codigo_verificador}</b> e o cÃ³digo CRC <b>{codigo_crc}</b>."
    
    # Gerar QR Code
    qr = qrcode.make(url_autenticacao)
    qr_buffer = BytesIO()
    qr.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    qr_img = Image(qr_buffer, width=2*cm, height=2*cm)
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [qr_img, Paragraph(texto_autenticacao, style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    doc.build(story)
    
    buffer.seek(0)
    return FileResponse(buffer, as_attachment=True, filename=f'quadro_acesso_{quadro.pk}.pdf')


@login_required
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    
    # Busca
    query = request.GET.get('q')
    if query:
        militares = militares.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query) |
            Q(cpf__icontains=query) |
            Q(email__icontains=query)
        )
    
    # Filtros
    posto = request.GET.get('posto')
    if posto:
        # Mapear os valores do frontend para os cÃ³digos do banco
        posto_mapping = {
            'cb': 'CB',
            'tc': 'TC', 
            'mj': 'MJ',
            'cp': 'CP',
            '1t': '1T',
            '2t': '2T',
            'st': 'ST',
            '1s': '1S',
            '2s': '2S',
            '3s': '3S',
            'cab': 'CAB',
            'sd': 'SD'
        }
        posto_codigo = posto_mapping.get(posto.lower())
        if posto_codigo:
            militares = militares.filter(posto_graduacao=posto_codigo)
    
    situacao = request.GET.get('situacao')
    if situacao:
        situacao_mapping = {
            'at': 'AT',
            'in': 'IN'
        }
        situacao_codigo = situacao_mapping.get(situacao.lower())
        if situacao_codigo:
            militares = militares.filter(situacao=situacao_codigo)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = request.GET.get('ordenacao', 'hierarquia_antiguidade')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        militares = sorted(militares, key=lambda x: (
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')
    

    
    # Sem paginaÃ§Ã£o - mostrar todos os militares
    context = {
        'militares': militares,
    }
    
    return render(request, 'militares/militar_list.html', context)


@login_required
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)


@login_required
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)


def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
            'cpf': militar.cpf,
        })
    
    return JsonResponse({'results': results})


@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)


# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    
    # Buscar oficiais sem ficha
    oficiais_sem_ficha = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).exclude(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    )
    
    # Ordenar oficiais sem ficha por hierarquia
    hierarquia_oficiais = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
    }
    
    oficiais_sem_ficha_list = list(oficiais_sem_ficha)
    oficiais_sem_ficha_list.sort(key=lambda x: (
        hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
        x.nome_completo                                    # Depois por nome
    ))
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)


@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)


# Views para Quadros de Acesso
@login_required
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    quadros = QuadroAcesso.objects.all()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)


@login_required
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)


@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validaÃ§Ã£o que bloqueava quadros para a mesma data/tipo
        # (permitir mÃºltiplos quadros na mesma data)
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)


@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)


@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)


@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')


@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)


@login_required
def quadro_acesso_pdf(request, pk):
    """Gera PDF do quadro de acesso no modelo institucional solicitado"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    tipo_quadro = quadro.get_tipo_display().upper()
    # O get_tipo_display() jÃ¡ retorna "QUADRO DE ACESSO POR ANTIGUIDADE" ou "QUADRO DE ACESSO POR MERECIMENTO"
    # EntÃ£o usamos diretamente o valor retornado
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio com data em portuguÃªs
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Definir tipo e sigla do quadro
    if quadro.tipo == 'ANTIGUIDADE':
        tipo_quadro = 'por Antiguidade'
        sigla_quadro = 'QAA'
    elif quadro.tipo == 'MERECIMENTO':
        tipo_quadro = 'por Merecimento'
        sigla_quadro = 'QAM'
    else:
        tipo_quadro = 'Manual'
        sigla_quadro = 'QAM'
    
    texto_intro = (
        f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
        f"que visa Ã s promoÃ§Ãµes do dia {data_formatada}, com fulcro nos artigos 12, 13, c/c Â§ 3Âº do Art. 20, da Lei nÂº 5.461, de 30 de junho de 2005, "
        "alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
    )
    story.append(Paragraph(texto_intro, style_just))
    story.append(Spacer(1, 12))

    # Definir todos os quadros
    quadros_info = [
        {
            'numero': 1,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMBATENTES (QOBM/Comb.)',
            'codigo': 'COMB'
        },
        {
            'numero': 2,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES DE SAÃšDE (QOBM/S)',
            'codigo': 'SAUDE'
        },
        {
            'numero': 3,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES ENGENHEIROS (QOBM/E)',
            'codigo': 'ENG'
        },
        {
            'numero': 4,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMPLEMENTARES (QOBM/C)',
            'codigo': 'COMP'
        }
    ]

    # Definir transiÃ§Ãµes especÃ­ficas por quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Processar cada quadro
    for quadro_info in quadros_info:
        story.append(Spacer(1, 16))
        story.append(Paragraph(f'<b>{quadro_info["numero"]}. {quadro_info["nome"]}</b>', style_center))
        story.append(Spacer(1, 10))

        # Processar cada transiÃ§Ã£o de posto especÃ­fica do quadro
        transicoes_do_quadro = transicoes_por_quadro.get(quadro_info['codigo'], [])
        for transicao in transicoes_do_quadro:
            story.append(Spacer(1, 12))
            story.append(Paragraph(f'<b>{transicao["numero"]} â€“ {transicao["titulo"]}</b>', style_bold))
            story.append(Spacer(1, 6))
            
            # Buscar militares aptos para esta transiÃ§Ã£o neste quadro
            if quadro_info['codigo'] == 'COMP' and transicao['origem'] == 'ST' and transicao['destino'] == '2T':
                # Para transiÃ§Ã£o ST->2T do COMP, incluir subtenentes do quadro PRACAS
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='PRACAS'
                ).order_by('posicao')
            else:
                # Para outras transiÃ§Ãµes, usar filtro normal
                aptos = quadro.itemquadroacesso_set.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro=quadro_info['codigo']
                ).order_by('posicao')
            
            if aptos.exists():
                # Preparar dados da tabela
                header_data = [['ORD', 'IDENT.', 'POSTO', 'NOME']]
                for idx, item in enumerate(aptos, 1):
                    header_data.append([
                        str(idx),
                        item.militar.matricula,
                        item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                        item.militar.nome_completo
                    ])
                
                # Calcular larguras das colunas baseado no conteÃºdo
                max_ord = max([len(str(row[0])) for row in header_data])
                max_ident = max([len(row[1]) for row in header_data])
                max_posto = max([len(row[2]) for row in header_data])
                
                # Definir larguras mÃ­nimas e ajustÃ¡veis
                col_widths = [
                    max(1.2*cm, max_ord * 0.3*cm),  # ORD
                    max(3*cm, max_ident * 0.3*cm),  # IDENT
                    max(3*cm, max_posto * 0.3*cm),  # POSTO
                    8*cm  # NOME (fixo)
                ]
                
                table = Table(header_data, colWidths=col_widths)
                table.setStyle(TableStyle([
                    ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                    ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                    ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                    ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                    ('FONTSIZE', (0, 0), (-1, -1), 9),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                    ('GRID', (0, 0), (-1, -1), 1, colors.black),
                    ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ]))
                story.append(table)
            else:
                story.append(Paragraph(transicao['texto'], style_just))
            
            story.append(Spacer(1, 8))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas
    story.append(PageBreak())  # Quebra de pÃ¡gina antes das assinaturas
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas vÃ¡lidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas.exists():
        # TÃ­tulo da seÃ§Ã£o
        story.append(Paragraph('<b>ASSINATURAS ELETRÃ”NICAS</b>', style_bold))
        story.append(Spacer(1, 10))
        
        for i, assinatura in enumerate(assinaturas):
            # InformaÃ§Ãµes de assinatura eletrÃ´nica
            nome_assinante = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrÃ£o
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "UsuÃ¡rio do Sistema"
            
            data_assinatura = assinatura.data_assinatura
            data_formatada = f"{data_assinatura.day:02d}/{data_assinatura.month:02d}/{data_assinatura.year}"
            hora_formatada = f"{data_assinatura.hour:02d}:{data_assinatura.minute:02d}"
            
            # Obter a funÃ§Ã£o atual do usuÃ¡rio
            from .utils import obter_funcao_atual_usuario
            funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema') if request and hasattr(request, 'session') else 'UsuÃ¡rio do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao_atual}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
            
            # Adicionar assinatura visual
            assinatura_visual = f"{nome_assinante}\n{funcao_atual}"
            
            # Adicionar assinatura visual
            assinatura_visual = f"{nome_assinante}\n{funcao_atual}"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
            if i < len(assinaturas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se nÃ£o houver assinaturas, mostrar apenas documento gerado pelo usuÃ¡rio logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "UsuÃ¡rio do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuÃ¡rio {nome_usuario} em {data_formatada}, Ã s {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Dados para autenticaÃ§Ã£o
    url_autenticacao = "https://sei.pi.gov.br/sei/controlador_externo.php?acao=documento_conferir&id_orgao_acesso_externo=0"
    codigo_verificador = f"{quadro.pk:08d}"
    codigo_crc = f"{hash(str(quadro.pk)) % 0xFFFFFFF:07X}"
    
    texto_autenticacao = f"A autenticidade deste documento pode ser conferida no site <a href='{url_autenticacao}' color='blue'>{url_autenticacao}</a>, informando o cÃ³digo verificador <b>{codigo_verificador}</b> e o cÃ³digo CRC <b>{codigo_crc}</b>."
    
    # Gerar QR Code
    qr = qrcode.make(url_autenticacao)
    qr_buffer = BytesIO()
    qr.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    qr_img = Image(qr_buffer, width=2*cm, height=2*cm)
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [qr_img, Paragraph(texto_autenticacao, style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Gerar PDF
    doc.build(story)
    
    # Configurar resposta para visualizaÃ§Ã£o no navegador
    buffer.seek(0)
    response = HttpResponse(buffer, content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="quadro_acesso_{quadro.pk}_{quadro.get_tipo_display()}.pdf"'
    
    return response


@login_required
def quadro_acesso_print(request, pk):
    """VersÃ£o para impressÃ£o do quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
        'itens': quadro.itemquadroacesso_set.all().order_by('posicao'),
    }
    
    return render(request, 'militares/quadro_acesso_print.html', context)


@login_required
def marcar_nao_elaborado(request, pk):
    """Marca um quadro como nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        observacoes = request.POST.get('observacoes', '')
        
        quadro.status = 'NAO_ELABORADO'
        quadro.motivo_nao_elaboracao = motivo
        quadro.observacoes = observacoes
        quadro.save()
        
        # Limpar itens existentes
        quadro.itemquadroacesso_set.all().delete()
        
        messages.success(request, 'Quadro marcado como nÃ£o elaborado.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


# Views para PromoÃ§Ãµes
@login_required
def promocao_list(request):
    """Lista promoÃ§Ãµes"""
    # Filtros
    query = request.GET.get('q', '')
    criterio = request.GET.get('criterio', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    promocoes = Promocao.objects.all()
    
    # Aplicar filtros
    if query:
        promocoes = promocoes.filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(numero_ato__icontains=query)
        )
    
    if criterio:
        promocoes = promocoes.filter(criterio=criterio)
    
    if data_inicio:
        promocoes = promocoes.filter(data_promocao__gte=data_inicio)
    
    if data_fim:
        promocoes = promocoes.filter(data_promocao__lte=data_fim)
    
    promocoes = promocoes.order_by('-data_promocao')
    
    # EstatÃ­sticas
    total_promocoes = Promocao.objects.count()
    promocoes_este_ano = Promocao.objects.filter(data_promocao__year=timezone.now().year).count()
    militares_promovidos = Promocao.objects.values('militar').distinct().count()
    promocoes_merecimento = Promocao.objects.filter(criterio='MERECIMENTO').count()
    
    # PaginaÃ§Ã£o
    paginator = Paginator(promocoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'promocoes': page_obj,
        'total_promocoes': total_promocoes,
        'promocoes_este_ano': promocoes_este_ano,
        'militares_promovidos': militares_promovidos,
        'promocoes_merecimento': promocoes_merecimento,
    }
    
    return render(request, 'militares/promocao_list.html', context)


@login_required
def promocao_create(request):
    """Registra nova promoÃ§Ã£o"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')  # Novo campo
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        is_historica = request.POST.get('is_historica') == 'on'  # Novo campo
        
        if all([militar_id, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Se nÃ£o foi informado posto anterior, usar o atual do militar
            if not posto_anterior:
                posto_anterior = militar.posto_graduacao
            
            # Cria promoÃ§Ã£o
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            # SÃ³ atualiza o militar se nÃ£o for promoÃ§Ã£o histÃ³rica
            if not is_historica:
                # Capturar dados anteriores antes da promoÃ§Ã£o
                posto_anterior = militar.posto_graduacao
                quadro_anterior = militar.quadro
                
                # Atualizar posto e data de promoÃ§Ã£o
                militar.posto_graduacao = posto_novo
                militar.data_promocao_atual = data_promocao
                
                # Atribuir a prÃ³xima numeraÃ§Ã£o disponÃ­vel no novo posto
                nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
                
                # Reordenar os militares do posto anterior (preencher gap)
                militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
                
                militar.save()
                
                messages.success(
                    request, 
                    f'PromoÃ§Ã£o registrada com sucesso! {militar.nome_completo} recebeu a {nova_numeracao}Âª numeraÃ§Ã£o de antiguidade no posto de {militar.get_posto_graduacao_display()}. {militares_reordenados} militares foram reordenados no posto anterior.'
                )
            
            messages.success(request, f'PromoÃ§Ã£o registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    # Verificar se hÃ¡ um militar prÃ©-selecionado na URL
    militar_pre_selecionado = None
    militar_id = request.GET.get('militar')
    if militar_id:
        try:
            militar_pre_selecionado = Militar.objects.get(pk=militar_id)
        except Militar.DoesNotExist:
            pass
    
    context = {
        'militares': Militar.objects.filter(situacao='AT').order_by('nome_completo'),
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'militar_pre_selecionado': militar_pre_selecionado,
    }
    
    return render(request, 'militares/promocao_form.html', context)


@login_required
def promocao_historica_create(request):
    """Registra promoÃ§Ã£o histÃ³rica (nÃ£o atualiza o militar)"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        
        if all([militar_id, posto_anterior, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Cria promoÃ§Ã£o histÃ³rica (nÃ£o atualiza o militar)
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-HIST-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            messages.success(request, f'PromoÃ§Ã£o histÃ³rica registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    context = {
        'militares': Militar.objects.all().order_by('nome_completo'),  # Todos os militares, nÃ£o sÃ³ ativos
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'is_historica': True,
    }
    
    return render(request, 'militares/promocao_form.html', context)


@login_required
def promocao_delete(request, pk):
    promocao = get_object_or_404(Promocao, pk=pk)
    if request.method == 'POST':
        promocao.delete()
        messages.success(request, 'PromoÃ§Ã£o excluÃ­da com sucesso!')
        return redirect('militares:promocao_list')
    return render(request, 'militares/promocao_confirm_delete.html', {'promocao': promocao})


# Views para Vagas
@login_required
def vaga_list(request):
    """Quadro de FixaÃ§Ã£o de Vagas: mostra vagas do sistema separadas por quadro e permite inserir vagas manuais"""
    # Processa o formulÃ¡rio de vaga manual
    if request.method == 'POST':
        if 'vaga_manual' in request.POST:
            posto = request.POST.get('posto')
            quadro = request.POST.get('quadro')
            quantidade = request.POST.get('quantidade')
            justificativa = request.POST.get('justificativa')
            observacoes = request.POST.get('observacoes')
            if posto and quadro and quantidade and justificativa:
                try:
                    quantidade = int(quantidade)
                    if quantidade < 1:
                        quantidade = 1
                except ValueError:
                    quantidade = 1
                VagaManual.objects.create(
                    posto=posto,
                    quadro=quadro,
                    quantidade=quantidade,
                    justificativa=justificativa,
                    observacoes=observacoes or ''
                )
                messages.success(request, 'Vaga manual inserida com sucesso!')
                return redirect('vaga_list')
        
        # Processa atualizaÃ§Ã£o de vagas fixadas
        elif 'atualizar_vagas_fixadas' in request.POST:
            for key, value in request.POST.items():
                if key.startswith('vagas_fixadas_'):
                    # Extrai o ID da previsÃ£o de vaga
                    previsao_id = key.replace('vagas_fixadas_', '')
                    try:
                        previsao = PrevisaoVaga.objects.get(id=previsao_id)
                        vagas_fixadas = int(value) if value else 0
                        previsao.vagas_fixadas = vagas_fixadas
                        
                        # Busca observaÃ§Ãµes correspondentes
                        obs_key = f'observacoes_vagas_fixadas_{previsao_id}'
                        observacoes = request.POST.get(obs_key, '')
                        previsao.observacoes_vagas_fixadas = observacoes
                        
                        previsao.save()
                    except (PrevisaoVaga.DoesNotExist, ValueError):
                        continue
            
            messages.success(request, 'Vagas fixadas atualizadas com sucesso!')
            return redirect('vaga_list')
    
    # Busca previsÃµes de vagas por quadro (oficiais)
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        posto__in=['2T', '1T', 'CP', 'MJ', 'TC', 'CB'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Busca previsÃµes de vagas por quadro (praÃ§as)
    previsoes_pracas = PrevisaoVaga.objects.filter(
        posto__in=['ST', 'SGT', 'CB', 'SD'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Organiza por quadro
    vagas_oficiais_por_quadro = {}
    vagas_pracas_por_quadro = {}
    
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_oficiais_por_quadro:
            vagas_oficiais_por_quadro[previsao.quadro] = []
        vagas_oficiais_por_quadro[previsao.quadro].append(previsao)
    
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_pracas_por_quadro:
            vagas_pracas_por_quadro[previsao.quadro] = []
        vagas_pracas_por_quadro[previsao.quadro].append(previsao)
    
    # Busca vagas manuais
    vagas_manuais = VagaManual.objects.all().order_by('-data_solicitacao')
    
    context = {
        'vagas_oficiais_por_quadro': vagas_oficiais_por_quadro,
        'vagas_pracas_por_quadro': vagas_pracas_por_quadro,
        'vagas_manuais': vagas_manuais,
        'quadros': [
            ('COMB', 'Quadro de Oficiais Bombeiros Militares Combatentes - QOBM/Comb.'),
            ('SAUDE', 'Quadro de Oficiais Bombeiros Militares de SaÃºde - QOBM/SaÃºde'),
            ('ENG', 'Quadro de Oficiais Bombeiros Militares Engenheiros - QOBM/Eng.'),
            ('COMP', 'Quadro de Oficiais Bombeiros Militares Complementar - QOBM/Comp.'),
        ]
    }
    
    return render(request, 'militares/vaga_list.html', context)


@login_required
def vaga_update(request, pk):
    """Atualiza vaga"""
    vaga = get_object_or_404(Vaga, pk=pk)
    
    if request.method == 'POST':
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        
        if efetivo_atual and efetivo_maximo:
            vaga.efetivo_atual = int(efetivo_atual)
            vaga.efetivo_maximo = int(efetivo_maximo)
            vaga.save()
            
            messages.success(request, f'Vaga atualizada com sucesso!')
            return redirect('militares:vaga_list')
    
    context = {
        'vaga': vaga,
    }
    
    return render(request, 'militares/vaga_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form(request, militar_pk):
    """FormulÃ¡rio de ficha de conceito com upload de documentos - redireciona para view especÃ­fica"""
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se Ã© oficial ou praÃ§a
    postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    is_oficial = militar.posto_graduacao in postos_oficiais
    
    if is_oficial:
        # Se Ã© oficial, usar a view genÃ©rica (que jÃ¡ funciona para oficiais)
        return ficha_conceito_form_oficiais(request, militar_pk)
    else:
        # Se Ã© praÃ§a, redirecionar para a view especÃ­fica de praÃ§as
        from .views_pracas import ficha_conceito_pracas_form
        return ficha_conceito_pracas_form(request, militar_pk)


from .decorators import can_edit_ficha_conceito, can_edit_militar

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form_oficiais(request, militar_pk):
    """FormulÃ¡rio de ficha de conceito para oficiais com upload de documentos"""
    # Verificar permissÃ£o
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar fichas de conceito. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se jÃ¡ existe uma ficha para este militar
    ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
    ficha_existente_pracas = militar.fichaconceitopracas_set.first()
    
    if request.method == 'POST':
        if ficha_existente_oficiais:
            # Se jÃ¡ existe ficha de oficiais, atualizar
            form = FichaConceitoOficiaisForm(request.POST, request.FILES, instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se jÃ¡ existe ficha de praÃ§as, atualizar
            form = FichaConceitoPracasForm(request.POST, request.FILES, instance=ficha_existente_pracas, militar=militar)
        else:
            # Se nÃ£o existe, criar nova ficha baseada no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(request.POST, request.FILES, militar=militar)
            else:
                form = FichaConceitoPracasForm(request.POST, request.FILES, militar=militar)
        
        if form.is_valid():
            ficha = form.save(commit=False)
            ficha.militar = militar
            ficha.save()
            
            # Processar documentos se fornecidos
            documentos = request.FILES.getlist('documentos')
            for doc_file in documentos:
                Documento.objects.create(
                    militar=militar,
                    ficha_conceito=ficha,
                    tipo='OUTROS',
                    titulo=f"Documento: {doc_file.name}",
                    arquivo=doc_file
                )
            
            messages.success(request, 'Ficha de conceito salva com sucesso!')
            return redirect('militares:ficha_conceito_list')
        else:
            # Debug: mostrar erros do formulÃ¡rio
            print("Erros do formulÃ¡rio:", form.errors)
            messages.error(request, f'Erro ao salvar ficha de conceito: {form.errors}')
    else:
        if ficha_existente_oficiais:
            # Se jÃ¡ existe ficha de oficiais, carregar dados
            form = FichaConceitoOficiaisForm(instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se jÃ¡ existe ficha de praÃ§as, carregar dados
            form = FichaConceitoPracasForm(instance=ficha_existente_pracas, militar=militar)
        else:
            # Se nÃ£o existe, criar formulÃ¡rio vazio baseado no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(militar=militar)
            else:
                form = FichaConceitoPracasForm(militar=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'ficha': ficha_existente_oficiais or ficha_existente_pracas,
        'documento_form': DocumentoForm(),
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_edit(request, pk):
    """Editar ficha de conceito"""
    # Verificar permissÃ£o
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar fichas de conceito. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        form_class = FichaConceitoOficiaisForm
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            form_class = FichaConceitoPracasForm
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = form_class(request.POST, instance=ficha, militar=ficha.militar)
        if form.is_valid():
            form.save()
            messages.success(request, 'Ficha de conceito atualizada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        form = form_class(instance=ficha, militar=ficha.militar)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)


@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    tipo_ficha = None
    
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        tipo_ficha = 'oficiais'
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            tipo_ficha = 'pracas'
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    # Calcular pontos detalhados para exibiÃ§Ã£o
    if tipo_ficha == 'oficiais':
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': min(ficha.tempo_posto * 1.0, 5.0),
                'limite': 5.0,
                'descricao': 'Tempo de ServiÃ§o no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao + ficha.cursos_csbm,
                'pontos': min((ficha.cursos_especializacao * 2.5 + ficha.cursos_csbm * 4.0), 5.0),
                'limite': 5.0,
                'descricao': 'ConclusÃ£o de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho + ficha.cursos_cfo +
                         ficha.cursos_cao + ficha.cursos_instrutor_csbm),
                'pontos': min((ficha.cursos_cfsd * 0.5 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.0 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.5 + ficha.cursos_cfo * 1.75 +
                              ficha.cursos_cao * 3.0 + ficha.cursos_instrutor_csbm * 2.5), 10.0),
                'limite': 10.0,
                'descricao': 'Instrutor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_superior + ficha.cursos_civis_especializacao +
                         ficha.cursos_civis_mestrado + ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_superior * 1.5 + ficha.cursos_civis_especializacao * 2.0 +
                          ficha.cursos_civis_mestrado * 3.0 + ficha.cursos_civis_doutorado * 4.0),
                'limite': None,
                'descricao': 'ConclusÃ£o em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.5 + ficha.medalha_estadual * 0.25 +
                              ficha.medalha_cbmepi * 0.25), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e CondecoraÃ§Ãµes'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.25 + ficha.elogio_coletivo * 0.125), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 0.25 + ficha.punicao_detencao * 0.5 +
                           ficha.punicao_prisao * 1.0),
                'limite': None,
                'descricao': 'PuniÃ§Ãµes'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 0.5),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    else:  # praÃ§as
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': ficha.tempo_posto * 1.0,
                'limite': None,
                'descricao': 'Tempo de ServiÃ§o no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao,
                'pontos': min((ficha.cursos_especializacao * 2.0), 4.0),
                'limite': 4.0,
                'descricao': 'ConclusÃ£o de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho),
                'pontos': min((ficha.cursos_cfsd * 0.50 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.00 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.50), 5.0),
                'limite': 5.0,
                'descricao': 'Monitor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_tecnico + ficha.cursos_civis_superior + 
                         ficha.cursos_civis_especializacao + ficha.cursos_civis_mestrado + 
                         ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_tecnico * 1.75 + ficha.cursos_civis_superior * 3.00 +
                          ficha.cursos_civis_especializacao * 4.00 + ficha.cursos_civis_mestrado * 9.00 +
                          ficha.cursos_civis_doutorado * 15.00),
                'limite': None,
                'descricao': 'ConclusÃ£o em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.50 + ficha.medalha_estadual * 0.30 +
                              ficha.medalha_cbmepi * 0.20), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e CondecoraÃ§Ãµes'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.15 + ficha.elogio_coletivo * 0.10), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 1.0 + ficha.punicao_detencao * 2.0 +
                           ficha.punicao_prisao * 5.0),
                'limite': None,
                'descricao': 'PuniÃ§Ãµes'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 10.0),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
        'pontos_detalhados': pontos_detalhados,
        'total_pontos': ficha.calcular_pontos(),
        'tipo_ficha': tipo_ficha,
    }
    
    response = render(request, 'militares/ficha_conceito_detail.html', context)
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    return response


@login_required
def documento_upload(request, ficha_pk):
    """Upload de documentos para ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=ficha_pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.militar = ficha.militar
            
            # Atribuir ao campo correto baseado no tipo de ficha
            if hasattr(ficha, 'fichaconceitooficiais_set'):
                # Ã‰ uma ficha de oficiais
                documento.ficha_conceito_oficiais = ficha
            else:
                # Ã‰ uma ficha de praÃ§as
                documento.ficha_conceito_pracas = ficha
            
            documento.save()
            
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    else:
        form = DocumentoForm()
    
    # Buscar documentos relacionados Ã  ficha
    if hasattr(ficha, 'fichaconceitooficiais_set'):
        # Ã‰ uma ficha de oficiais
        documentos = Documento.objects.filter(ficha_conceito_oficiais=ficha)
    else:
        # Ã‰ uma ficha de praÃ§as
        documentos = Documento.objects.filter(ficha_conceito_pracas=ficha)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
        'documentos': documentos,
    }
    
    return render(request, 'militares/documento_upload.html', context)


@login_required
def conferir_ficha(request, pk):
    """Conferir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar']:
            # Atualiza apenas as observaÃ§Ãµes, jÃ¡ que nÃ£o hÃ¡ campo status
            ficha.observacoes = observacoes
            ficha.save()
            
            messages.success(request, f'Ficha {acao}da com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/conferir_ficha.html', context)


@login_required
def conferir_documento(request, pk):
    """Conferir documento"""
    documento = get_object_or_404(Documento, pk=pk)
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar', 'arquivar']:
            documento.status = acao.upper()
            documento.conferido_por = request.user
            documento.data_conferencia = timezone.now()
            documento.observacoes = observacoes
            documento.save()
            
            messages.success(request, f'Documento {acao}do com sucesso!')
            return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/conferir_documento.html', context)


@login_required
def promocao_detail(request, pk):
    """Detalhes da promoÃ§Ã£o"""
    promocao = get_object_or_404(Promocao, pk=pk)
    
    context = {
        'promocao': promocao,
    }
    
    return render(request, 'militares/promocao_detail.html', context)


@login_required
def estatisticas(request):
    """EstatÃ­sticas do sistema"""
    # EstatÃ­sticas gerais
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    
    # Por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Por posto
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    ).order_by('posto_graduacao')
    
    # Fichas de conceito
    total_fichas = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    fichas_aprovadas = 0  # Removido filtro por status que nÃ£o existe
    fichas_pendentes = 0  # Removido filtro por status que nÃ£o existe
    
    # Documentos
    total_documentos = Documento.objects.count()
    documentos_aprovados = Documento.objects.filter(status='APROVADO').count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas dos quadros de acesso
    total_quadros_acesso = QuadroAcesso.objects.count()
    if total_quadros_acesso > 0:
        estatisticas_quadros_acesso = {
            'total': total_quadros_acesso,
            'elaborados': QuadroAcesso.objects.filter(status='ELABORADO').count(),
            'homologados': QuadroAcesso.objects.filter(status='HOMOLOGADO').count(),
            'nao_elaborados': QuadroAcesso.objects.filter(status='NAO_ELABORADO').count(),
            'em_elaboracao': QuadroAcesso.objects.filter(status='EM_ELABORACAO').count(),
            'militares_aptos': sum([q.itemquadroacesso_set.count() for q in QuadroAcesso.objects.filter(status='ELABORADO')]),
            'status': list(QuadroAcesso.objects.values('status').annotate(total=Count('id'))),
            'quadro': list(QuadroAcesso.objects.values('quadro').annotate(total=Count('id'))),
            'tipo': list(QuadroAcesso.objects.values('tipo').annotate(total=Count('id'))),
            'posto': list(QuadroAcesso.objects.values('posto').annotate(total=Count('id'))),
        }
    else:
        estatisticas_quadros_acesso = None
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto,
        'total_fichas': total_fichas,
        'fichas_aprovadas': fichas_aprovadas,
        'fichas_pendentes': fichas_pendentes,
        'total_documentos': total_documentos,
        'documentos_aprovados': documentos_aprovados,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadros_acesso': estatisticas_quadros_acesso,
    }
    
    return render(request, 'militares/estatisticas.html', context)


def register(request):
    """Registro de usuÃ¡rio"""
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Conta criada com sucesso! FaÃ§a login para continuar.')
            return redirect('login')
    else:
        form = UserRegistrationForm()
    
    return render(request, 'registration/register.html', {'form': form})


def intersticio_list(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar interstÃ­cios ativos
    intersticios = list(Intersticio.objects.filter(ativo=True))
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    return render(request, 'militares/intersticio_list.html', {'intersticios': intersticios_ordenados})


@user_passes_test(lambda u: u.is_staff)
def intersticio_manage(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar todos os interstÃ­cios
    intersticios = list(Intersticio.objects.all())
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for inter in intersticios_ordenados:
            anos = request.POST.get(f'anos_{inter.id}', '').strip()
            meses = request.POST.get(f'meses_{inter.id}', '').strip()
            try:
                inter.tempo_minimo_anos = int(anos) if anos.isdigit() else 0
                inter.tempo_minimo_meses = int(meses) if meses.isdigit() else 0
                inter.save()
            except Exception as e:
                messages.error(request, f'Erro ao salvar {inter}: {e}')
        messages.success(request, 'InterstÃ­cios atualizados com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticios': intersticios_ordenados,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/intersticio_manage.html', context)


@user_passes_test(lambda u: u.is_staff)
def intersticio_create(request):
    """Criar novo interstÃ­cio"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        anos = request.POST.get('novo_anos', '0')
        meses = request.POST.get('novo_meses', '0')
        
        try:
            # Verificar se jÃ¡ existe um interstÃ­cio para este quadro/posto
            if Intersticio.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'JÃ¡ existe um interstÃ­cio para este quadro e posto!')
            else:
                Intersticio.objects.create(
                    quadro=quadro,
                    posto=posto,
                    tempo_minimo_anos=int(anos),
                    tempo_minimo_meses=int(meses),
                    ativo=True
                )
                messages.success(request, 'InterstÃ­cio criado com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar interstÃ­cio: {e}')
    
    return redirect('militares:intersticio_manage')


@user_passes_test(lambda u: u.is_staff)
def intersticio_delete(request, pk):
    """Excluir interstÃ­cio"""
    intersticio = get_object_or_404(Intersticio, pk=pk)
    
    if request.method == 'POST':
        intersticio.delete()
        messages.success(request, 'InterstÃ­cio excluÃ­do com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticio': intersticio,
    }
    
    return render(request, 'militares/intersticio_confirm_delete.html', context)


@login_required
def marcar_cursos_inerentes(request, militar_pk):
    """Marca automaticamente os cursos inerentes ao quadro do militar"""
    if request.method == 'POST':
        militar = get_object_or_404(Militar, pk=militar_pk)
        militar.marcar_cursos_inerentes()
        return JsonResponse({'success': True, 'message': 'Cursos inerentes marcados com sucesso!'})
    return JsonResponse({'success': False, 'message': 'MÃ©todo nÃ£o permitido'}, status=405)


@login_required
def relatorio_requisitos_quadro(request, pk):
    """RelatÃ³rio detalhado dos requisitos dos militares para um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    # Buscar militares candidatos para o quadro especÃ­fico
    # Definir postos baseado no tipo de quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadro de merecimento: incluir TC apenas para COMB (TCâ†’CB), excluir subtenentes (ST)
        postos = ['2T', '1T', 'CP', 'MJ', 'TC']
    else:
        # Para quadro de antiguidade: incluir todos os postos
        postos = ['ST', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    
    # Buscar militares candidatos baseado no tipo de quadro
    militares_candidatos = []
    
    # Para quadros de merecimento, buscar apenas militares com ficha de conceito
    if quadro.tipo == 'MERECIMENTO':
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        ).filter(
            posto_graduacao__in=postos
        )
    else:
        # Para quadros de antiguidade, buscar todos os militares ativos
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            posto_graduacao__in=postos
        )
    
    # Debug: imprimir quantidade de candidatos encontrados
    print(f"DEBUG: Encontrados {len(militares_candidatos)} militares candidatos para o quadro {quadro.tipo}")
    
    relatorio = []
    for militar in militares_candidatos:
        # Validar cada requisito individualmente
        tem_ficha = militar.fichaconceitooficiais_set.exists() or militar.fichaconceitopracas_set.exists()
        
        apto_intersticio = quadro._validar_intersticio_minimo(militar, quadro.data_promocao)
        motivo_intersticio = ""
        if not apto_intersticio:
            motivo_intersticio = "InterstÃ­cio insuficiente atÃ© a data da promoÃ§Ã£o"
        
        apto_saude = quadro._validar_inspecao_saude(militar)
        motivo_saude = ""
        if not apto_saude:
            motivo_saude = "InspeÃ§Ã£o de saÃºde vencida ou nÃ£o realizada"
        
        apto_cursos = quadro._validar_cursos_inerentes(militar)
        motivo_cursos = ""
        if not apto_cursos:
            motivo_cursos = "Cursos inerentes insuficientes para o posto subsequente"
        
        # Status geral
        apto_geral = tem_ficha and apto_intersticio and apto_saude and apto_cursos
        
        relatorio.append({
            'militar': militar,
            'tem_ficha': tem_ficha,
            'apto_intersticio': apto_intersticio,
            'motivo_intersticio': motivo_intersticio,
            'apto_saude': apto_saude,
            'motivo_saude': motivo_saude,
            'apto_cursos': apto_cursos,
            'motivo_cursos': motivo_cursos,
            'apto_geral': apto_geral,
            'tempo_no_posto': militar.tempo_posto_atual(),
            'data_inspecao': militar.data_inspecao_saude,
            'validade_inspecao': militar.data_validade_inspecao_saude,
        })
    
    # Ordenar por status (aptos primeiro) e depois por nome
    relatorio.sort(key=lambda x: (not x['apto_geral'], x['militar'].nome_completo))
    
    context = {
        'quadro': quadro,
        'relatorio': relatorio,
        'total_candidatos': len(relatorio),
        'total_aptos': sum(1 for r in relatorio if r['apto_geral']),
        'total_inaptos': sum(1 for r in relatorio if not r['apto_geral']),
    }
    
    return render(request, 'militares/relatorio_requisitos_quadro.html', context)


@login_required
def test_template(request):
    """View de teste para verificar se o problema persiste"""
    quadros = QuadroAcesso.objects.all()
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/simple_test.html', context)


class RelatorioAptosPromocaoForm(forms.Form):
    tipo = forms.ChoiceField(choices=[('ANTIGUIDADE', 'Antiguidade'), ('MERECIMENTO', 'Merecimento')], label="Tipo de Quadro de Acesso")
    data_promocao = forms.DateField(label="Data prevista para promoÃ§Ã£o", widget=forms.DateInput(attrs={'type': 'date'}))

@login_required
def relatorio_aptos_promocao(request):
    QUADROS = [
        ('COMB', 'Combatente'),
        ('SAUDE', 'SaÃºde'),
        ('ENG', 'Engenharia'),
        ('COMP', 'Complementar'),
    ]
    POSTOS = [
        ('2T', '2Âº Tenente'),
        ('1T', '1Âº Tenente'),
        ('CP', 'CapitÃ£o'),
        ('MJ', 'Major'),
        ('TC', 'Tenente-Coronel'),
        ('CB', 'Coronel'),
    ]
    relatorio = []
    form = RelatorioAptosPromocaoForm(request.GET or None)
    if form.is_valid():
        tipo = form.cleaned_data['tipo']
        data_promocao = form.cleaned_data['data_promocao']
        for cod_quadro, nome_quadro in QUADROS:
            quadro_data = {'nome': nome_quadro, 'postos': []}
            for cod_posto, nome_posto in POSTOS:
                militares = Militar.objects.filter(
                    quadro=cod_quadro,
                    posto_graduacao=cod_posto,
                    situacao='AT'
                ).filter(
                    Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
                ).distinct()
                aptos = []
                for militar in militares:
                    # Usa as regras jÃ¡ implementadas no modelo QuadroAcesso
                    dummy_quadro = QuadroAcesso(tipo=tipo, quadro=cod_quadro, posto=cod_posto, data_promocao=data_promocao)
                    apto, _ = dummy_quadro.validar_requisitos_quadro_acesso(militar, data_promocao)
                    if apto:
                        aptos.append(militar)
                quadro_data['postos'].append({
                    'nome': nome_posto,
                    'aptos': aptos,
                })
            relatorio.append(quadro_data)
    context = {
        'form': form,
        'relatorio': relatorio,
        'form_submitted': form.is_valid(),
        'tipo': form.cleaned_data['tipo'] if form.is_valid() else None,
        'data_promocao': form.cleaned_data['data_promocao'] if form.is_valid() else None,
    }
    return render(request, 'militares/relatorio_aptos_promocao.html', context)


@login_required
def test_quadro_simple(request):
    """View de teste muito simples para verificar se o problema Ã© especÃ­fico da pÃ¡gina de quadros"""
    return render(request, 'militares/simple_test.html', {
        'estatisticas': {
            'total': 0,
            'elaborados': 0,
            'nao_elaborados': 0,
            'em_elaboracao': 0,
        }
    })


@login_required
def criar_quadro_manual(request):
    """Cria um quadro de acesso manual"""
    if request.method == 'POST':
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not data_promocao:
            messages.error(request, 'A data de promoÃ§Ã£o Ã© obrigatÃ³ria.')
            return redirect('militares:criar_quadro_manual')
        
        try:
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
            return redirect('militares:criar_quadro_manual')
        
        # Verificar se jÃ¡ existe um quadro manual para esta data (permitir mÃºltiplos quadros)
        # quadro_existente = QuadroAcesso.objects.filter(
        #     tipo='MANUAL',
        #     data_promocao=data_promocao
        # ).first()
        
        # if quadro_existente:
        #     messages.warning(request, f'JÃ¡ existe um quadro manual para a data {data_promocao.strftime("%d/%m/%Y")}.')
        #     return redirect('militares:quadro_acesso_detail', pk=quadro_existente.pk)
        
        # Criar o quadro manual
        try:
            novo_quadro = QuadroAcesso.objects.create(
                tipo='MANUAL',
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                is_manual=True,
                criterio_ordenacao_manual=request.POST.get('criterio_ordenacao', 'MANUAL'),
                observacoes=observacoes or f"Quadro manual para {data_promocao.strftime('%d/%m/%Y')}"
            )
            
            messages.success(request, f'Quadro manual criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            # Redirecionar para a view correta baseada na categoria
            if novo_quadro.categoria == 'PRACAS':
                return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
            else:
                return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro manual: {str(e)}')
        
        return redirect('militares:criar_quadro_manual')
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
    }
    
    return render(request, 'militares/criar_quadro_manual.html', context)


@login_required
def adicionar_militar_quadro_manual(request, pk):
    """Adiciona um militar ao quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares adicionados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao', 0)
        
        if not militar_id:
            messages.error(request, 'Selecione um militar.')
            return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Converter posiÃ§Ã£o para inteiro se fornecida
            posicao_int = None
            if posicao:
                try:
                    posicao_int = int(posicao)
                except ValueError:
                    messages.error(request, 'PosiÃ§Ã£o deve ser um nÃºmero inteiro.')
                    return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
            
            # Converter pontuaÃ§Ã£o para decimal
            try:
                pontuacao_decimal = float(pontuacao)
            except ValueError:
                pontuacao_decimal = 0
            
            # Adicionar militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao_int, pontuacao_decimal)
            
            messages.success(request, f'Militar {militar.nome_completo} adicionado ao quadro com sucesso!')
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def remover_militar_quadro_manual(request, pk, militar_id):
    """Remove um militar do quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares removidos.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        try:
            militar = Militar.objects.get(pk=militar_id)
            quadro.remover_militar_manual(militar)
            messages.success(request, f'Militar {militar.nome_completo} removido do quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)


@login_required
def buscar_militares_ajax(request):
    """Busca militares para adicionar ao quadro manual via AJAX"""
    if request.method == 'GET':
        termo = request.GET.get('termo', '')
        if len(termo) < 2:
            return JsonResponse({'militares': []})
        
        militares = Militar.objects.filter(
            situacao='AT',
            nome_completo__icontains=termo
        ).values('id', 'nome_completo', 'posto_graduacao', 'quadro', 'matricula')[:10]
        
        return JsonResponse({'militares': list(militares)})
    
    return JsonResponse({'militares': []})


@login_required
def buscar_pontuacao_militar(request, militar_id):
    """Retorna a pontuaÃ§Ã£o da ficha de conceito do militar"""
    from militares.models import Militar
    try:
        militar = Militar.objects.get(pk=militar_id)
        ficha = militar.fichaconceitooficiais_set.first() or militar.fichaconceitopracas_set.first()
        pontuacao = ficha.pontos if ficha else 0
        return JsonResponse({'pontuacao': float(pontuacao)})
    except Militar.DoesNotExist:
        return JsonResponse({'pontuacao': 0})


@login_required
def gerar_fichas_conceito_todos(request):
    """Gera fichas de conceito para todos os militares cadastrados que ainda nÃ£o possuem"""
    if request.method == 'POST':
        # Verificar se estÃ¡ sendo chamado da pÃ¡gina de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas oficiais ativos
            militares_ativos = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            tipo_militar = "oficiais"
        else:
            # Buscar todos os militares ativos
            militares_ativos = Militar.objects.filter(situacao='AT')
            tipo_militar = "militares"
        
        # Buscar militares que nÃ£o possuem ficha de conceito
        militares_sem_ficha = militares_ativos.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        fichas_criadas = 0
        militares_processados = 0
        
        for militar in militares_sem_ficha:
            # Verificar se jÃ¡ existe ficha para este militar (dupla verificaÃ§Ã£o)
            ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
            ficha_existente_pracas = militar.fichaconceitopracas_set.first()
            
            if not ficha_existente_oficiais and not ficha_existente_pracas:
                # Determinar qual tipo de ficha criar baseado no posto
                if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                    # Criar ficha de oficiais
                    ficha = FichaConceitoOficiais.objects.create(
                        militar=militar,
                    )
                else:
                    # Criar ficha de praÃ§as
                    ficha = FichaConceitoPracas.objects.create(
                        militar=militar,
                    )
                fichas_criadas += 1
            
            militares_processados += 1
        
        # Mensagens informativas
        if fichas_criadas > 0:
            messages.success(request, f'âœ… Foram criadas {fichas_criadas} fichas de conceito com tempo de serviÃ§o no posto para {tipo_militar} que nÃ£o possuÃ­am.')
        else:
            messages.info(request, f'â„¹ï¸ Todos os {tipo_militar} ativos jÃ¡ possuem fichas de conceito.')
        
        if militares_processados > 0:
            messages.info(request, f'ğŸ“Š Processados {militares_processados} {tipo_militar} ativos.')
        
        # InformaÃ§Ã£o adicional sobre militares que jÃ¡ tinham fichas
        militares_com_ficha = militares_ativos.count() - militares_sem_ficha.count()
        if militares_com_ficha > 0:
            messages.info(request, f'ğŸ”’ {militares_com_ficha} {tipo_militar} jÃ¡ possuÃ­am fichas de conceito e nÃ£o foram alterados.')
    
    return redirect('militares:ficha_conceito_list')


@login_required
@user_passes_test(lambda u: u.is_staff)
def limpar_pontos_fichas_conceito(request):
    """Limpa os pontos das fichas de conceito, mantendo apenas o tempo no posto"""
    if request.method == 'POST':
        # Verificar se estÃ¡ sendo chamado da pÃ¡gina de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas fichas de oficiais
            oficiais = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
            tipo_militar = "oficiais"
        else:
            # Buscar todas as fichas de conceito
            fichas_oficiais = FichaConceitoOficiais.objects.all()
            fichas_pracas = FichaConceitoPracas.objects.all()
            fichas = list(fichas_oficiais) + list(fichas_pracas)
            tipo_militar = "militares"
        
        fichas_limpas = 0
        
        for ficha in fichas:
            # Salvar o tempo no posto atual
            tempo_posto_atual = ficha.militar.tempo_posto_atual()
            
            # Atualizar diretamente no banco para evitar chamar o mÃ©todo save()
            if isinstance(ficha, FichaConceitoOficiais):
                FichaConceitoOficiais.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            else:
                FichaConceitoPracas.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            fichas_limpas += 1
        
        if fichas_limpas > 0:
            messages.success(request, f'âœ… Foram limpas {fichas_limpas} fichas de conceito de {tipo_militar}. Apenas o tempo no posto foi mantido.')
        else:
            messages.info(request, f'â„¹ï¸ Nenhuma ficha de conceito de {tipo_militar} encontrada para limpeza.')
    
    return redirect('militares:ficha_conceito_list')


@login_required
def vaga_create(request):
    """Cria uma nova vaga"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        if posto and quadro and efetivo_maximo:
            vaga = Vaga(
                posto=posto,
                quadro=quadro,
                efetivo_atual=efetivo_atual or 0,
                efetivo_maximo=efetivo_maximo
            )
            vaga.save()
            messages.success(request, 'Vaga criada com sucesso!')
            return redirect('militares:vaga_list')
        else:
            messages.error(request, 'Preencha todos os campos obrigatÃ³rios.')
    # Para GET, exibe o mesmo modal, mas normalmente sÃ³ Ã© chamado via POST
    return redirect('militares:vaga_list')


# Views para PrevisÃ£o de Vagas
def previsao_vaga_list(request):
    """Lista todas as previsÃµes de vagas organizadas por quadro"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar previsÃµes de vagas ativas
    previsoes = list(PrevisaoVaga.objects.filter(ativo=True))
    
    # Calcular efetivo atual baseado nos militares cadastrados
    for previsao in previsoes:
        # Subtenentes estÃ£o cadastrados como COMP mas contam para PRACAS
        if previsao.posto == 'ST' and previsao.quadro == 'PRACAS':
            # Contar ST cadastrados como COMP (quadro de origem)
            efetivo_atual = Militar.objects.filter(
                posto_graduacao='ST',
                quadro='COMP',  # ST estÃ£o cadastrados como COMP
                situacao='AT'   # Apenas militares ativos
            ).count()
        else:
            # Para outros postos, contar normalmente
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'  # Apenas militares ativos
            ).count()
        
        previsao.efetivo_atual = efetivo_atual
        previsao.save()  # Isso vai recalcular vagas_disponiveis automaticamente
    
    # Remover previsÃµes de vaga de ST em quadros que nÃ£o sejam PRACAS
    previsoes = [p for p in previsoes if not (p.posto == 'ST' and p.quadro != 'PRACAS')]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    # Calcular estatÃ­sticas gerais
    total_efetivo_atual = sum(p.efetivo_atual for p in previsoes_ordenadas)
    total_efetivo_previsto = sum(p.efetivo_previsto for p in previsoes_ordenadas)
    total_vagas_disponiveis = sum(p.vagas_disponiveis for p in previsoes_ordenadas)
    
    context = {
        'previsoes': previsoes_ordenadas,
        'total_efetivo_atual': total_efetivo_atual,
        'total_efetivo_previsto': total_efetivo_previsto,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/previsao_vaga_list.html', context)


@user_passes_test(lambda u: u.is_staff)
def previsao_vaga_manage(request):
    """Gerenciar previsÃµes de vagas"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar todas as previsÃµes de vagas
    previsoes = list(PrevisaoVaga.objects.all())
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    previsoes = [p for p in previsoes if p.quadro != 'PRACAS' or p.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for previsao in previsoes_ordenadas:
            efetivo_atual = request.POST.get(f'efetivo_atual_{previsao.id}', '').strip()
            efetivo_previsto = request.POST.get(f'efetivo_previsto_{previsao.id}', '').strip()
            try:
                previsao.efetivo_atual = int(efetivo_atual) if efetivo_atual.isdigit() else 0
                previsao.efetivo_previsto = int(efetivo_previsto) if efetivo_previsto.isdigit() else 0
                previsao.save()
                # Recarregar o objeto do banco para verificar se o cÃ¡lculo foi aplicado
                previsao.refresh_from_db()
                print(f"[DEBUG] PrevisaoVaga ID {previsao.id} | Atual: {previsao.efetivo_atual} | Previsto: {previsao.efetivo_previsto} | Vagas DisponÃ­veis: {previsao.vagas_disponiveis}")
            except Exception as e:
                messages.error(request, f'Erro ao salvar {previsao}: {e}')
        messages.success(request, 'PrevisÃµes de vagas atualizadas com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsoes': previsoes_ordenadas,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/previsao_vaga_manage.html', context)


@user_passes_test(lambda u: u.is_staff)
def previsao_vaga_create(request):
    """Criar nova previsÃ£o de vaga"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        efetivo_atual = request.POST.get('novo_efetivo_atual', '0')
        efetivo_previsto = request.POST.get('novo_efetivo_previsto', '0')
        
        try:
            # Verificar se jÃ¡ existe uma previsÃ£o para este quadro/posto
            if PrevisaoVaga.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'JÃ¡ existe uma previsÃ£o de vaga para este quadro e posto!')
            else:
                PrevisaoVaga.objects.create(
                    quadro=quadro,
                    posto=posto,
                    efetivo_atual=int(efetivo_atual),
                    efetivo_previsto=int(efetivo_previsto),
                    ativo=True
                )
                messages.success(request, 'PrevisÃ£o de vaga criada com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar previsÃ£o de vaga: {e}')
    
    return redirect('militares:previsao_vaga_manage')


@user_passes_test(lambda u: u.is_staff)
def previsao_vaga_delete(request, pk):
    """Excluir previsÃ£o de vaga"""
    previsao = get_object_or_404(PrevisaoVaga, pk=pk)
    
    if request.method == 'POST':
        previsao.delete()
        messages.success(request, 'PrevisÃ£o de vaga excluÃ­da com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsao': previsao,
    }
    
    return render(request, 'militares/previsao_vaga_confirm_delete.html', context)


@user_passes_test(lambda u: u.is_staff)
def previsao_vaga_delete_ajax(request, pk):
    """Excluir previsÃ£o de vaga via AJAX"""
    if request.method == 'POST':
        try:
            previsao = PrevisaoVaga.objects.get(pk=pk)
            previsao.delete()
            return JsonResponse({'success': True})
        except PrevisaoVaga.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'PrevisÃ£o de vaga nÃ£o encontrada'})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'MÃ©todo nÃ£o permitido'})


@login_required
def documento_delete(request, pk):
    """Excluir documento"""
    try:
        documento = Documento.objects.get(pk=pk)
    except Documento.DoesNotExist:
        messages.error(request, f'Documento com ID {pk} nÃ£o encontrado. O documento pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        # Redirecionar para a lista de militares se nÃ£o conseguir identificar o militar
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        nome_arquivo = documento.filename()
        militar_pk = documento.militar.pk
        documento.delete()
        messages.success(request, f'Documento "{nome_arquivo}" excluÃ­do com sucesso!')
        return redirect('militares:militar_detail', pk=militar_pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/documento_confirm_delete.html', context)


@login_required
def assinar_documentos_quadro(request, pk):
    """PÃ¡gina para assinar documentos de um quadro de acesso"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Verificar permissÃ£o de assinatura
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© membro da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.pode_assinar_documento_oficial(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de oficiais. Apenas membros da CPO podem assinar.')
            return redirect('militares:quadro_acesso_detail', pk=pk)
    else:
        # Para quadros de praÃ§as, verificar se Ã© membro da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.pode_assinar_documento_praca(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de praÃ§as. Apenas membros da CPP podem assinar.')
            return redirect('militares:quadro_acesso_detail', pk=pk)
    
    # Buscar militares do quadro
    militares_quadro = []
    if quadro.status in ['ELABORADO', 'HOMOLOGADO']:
        militares_quadro = quadro.itemquadroacesso_set.all().order_by('posicao')
    
    # Buscar documentos pendentes de assinatura
    documentos_pendentes = Documento.objects.filter(
        militar__in=[item.militar for item in militares_quadro],
        status='PENDENTE'
    ).order_by('militar__nome_completo', 'data_upload')
    
    # Criar lista de documentos com informaÃ§Ãµes do militar e posiÃ§Ã£o
    documentos_com_info = []
    militares_sem_documentos = []
    
    for item in militares_quadro:
        documentos_militar = documentos_pendentes.filter(militar=item.militar)
        if documentos_militar.exists():
            for doc in documentos_militar:
                documentos_com_info.append({
                    'documento': doc,
                    'militar': item.militar,
                    'posicao': item.posicao,
                    'item_quadro': item
                })
        else:
            militares_sem_documentos.append(item)
    
    context = {
        'quadro': quadro,
        'militares_quadro': militares_quadro,
        'documentos_pendentes': documentos_pendentes,
        'documentos_com_info': documentos_com_info,
        'militares_sem_documentos': militares_sem_documentos,
        'total_documentos_pendentes': documentos_pendentes.count(),
    }
    
    return render(request, 'militares/assinar_documentos_quadro.html', context)


@login_required
def assinar_documento(request, pk):
    """Assinar documento com confirmaÃ§Ã£o de senha"""
    documento = get_object_or_404(Documento, pk=pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes_assinatura', '')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'documento': documento,
                'militar': documento.militar,
            }
            return render(request, 'militares/assinar_documento.html', context)
        
        # Assinar o documento
        documento.status = 'ASSINADO'
        documento.assinado_por = request.user
        documento.data_assinatura = timezone.now()
        documento.observacoes_assinatura = observacoes
        documento.save()
        
        messages.success(request, f'Documento "{documento.titulo}" assinado com sucesso!')
        return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/assinar_documento.html', context)


@login_required
def assinar_quadro_acesso(request, pk):
    """Assinar quadro de acesso com confirmaÃ§Ã£o de senha"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Verificar permissÃ£o de assinatura
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© membro da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.pode_assinar_documento_oficial(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de oficiais. Apenas membros da CPO podem assinar.')
            return redirect('militares:quadro_acesso_detail', pk=pk)
    else:
        # Para quadros de praÃ§as, verificar se Ã© membro da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.pode_assinar_documento_praca(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de praÃ§as. Apenas membros da CPP podem assinar.')
            return redirect('militares:quadro_acesso_detail', pk=pk)
    
    # Buscar comissÃ£o relacionada ao quadro
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
    else:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
    membros_comissao = comissao.membros.filter(ativo=True).select_related('militar', 'usuario').order_by('tipo', 'militar__nome_completo') if comissao else []
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        membro_id = request.POST.get('membro_id')
        membro = membros_comissao.filter(id=membro_id).first() if membro_id else None
        
        # Verificar senha do usuÃ¡rio selecionado
        if not membro or not membro.usuario or not membro.usuario.check_password(senha):
            messages.error(request, 'Senha incorreta ou membro invÃ¡lido. Tente novamente.')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Verificar se jÃ¡ existe uma assinatura deste membro para este tipo
        assinatura_existente = AssinaturaQuadroAcesso.objects.filter(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'Este membro jÃ¡ assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Obter funÃ§Ã£o atual do membro
        if membro.cargo:
            funcao_atual = f"{membro.get_tipo_display()} - {membro.cargo.nome}"
        else:
            funcao_atual = membro.get_tipo_display()
        
        # Se nÃ£o conseguir obter funÃ§Ã£o do membro, tentar buscar funÃ§Ã£o ativa do usuÃ¡rio
        if not funcao_atual or funcao_atual == " - ":
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=membro.usuario,
                status='ATIVO'
            ).first()
            
            if funcao_usuario:
                funcao_atual = funcao_usuario.cargo_funcao.nome
            else:
                funcao_atual = "UsuÃ¡rio do Sistema"
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroAcesso.objects.create(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura,
            funcao_assinatura=funcao_atual
        )
        
        messages.success(request, f'Quadro de acesso assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'membros_comissao': membros_comissao,
    }
    
    return render(request, 'militares/assinar_quadro_acesso.html', context)


# ============================================================================
# VIEWS DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS
# ============================================================================

@login_required
def comissao_list(request):
    """Lista todas as comissÃµes de promoÃ§Ã£o de oficiais"""
    comissoes = ComissaoPromocao.objects.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        comissoes = comissoes.filter(status=status)
    
    # Busca
    busca = request.GET.get('busca')
    if busca:
        comissoes = comissoes.filter(
            models.Q(nome__icontains=busca) |
            models.Q(observacoes__icontains=busca)
        )
    
    context = {
        'comissoes': comissoes,
        'status_choices': ComissaoPromocao.STATUS_CHOICES,
    }
    return render(request, 'militares/comissao/list.html', context)


@login_required
def comissao_detail(request, pk):
    """Detalhes de uma comissÃ£o de promoÃ§Ã£o de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    # Buscar quadros de acesso relacionados Ã  comissÃ£o
    if comissao.tipo == 'CPO':
        # Para comissÃ£o de oficiais, buscar quadros de oficiais
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='OFICIAIS'
        ).order_by('-data_promocao')
    else:
        # Para comissÃ£o de praÃ§as, buscar quadros de praÃ§as
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='PRACAS'
        ).order_by('-data_promocao')
    
    # Aplicar slice para mostrar apenas os Ãºltimos 10 quadros
    quadros_acesso = quadros_acesso_base[:10]
    
    # Buscar quadros de fixaÃ§Ã£o de vagas relacionados Ã  comissÃ£o
    if comissao.tipo == 'CPO':
        # Para comissÃ£o de oficiais, buscar quadros de oficiais
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='OFICIAIS'
        ).order_by('-data_promocao')[:10]  # Ãšltimos 10 quadros
    else:
        # Para comissÃ£o de praÃ§as, buscar quadros de praÃ§as
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='PRACAS'
        ).order_by('-data_promocao')[:10]  # Ãšltimos 10 quadros
    
    # Buscar quadros de acesso por merecimento e suas fichas de conceito
    quadros_merecimento = quadros_acesso_base.filter(tipo='MERECIMENTO')
    fichas_conceito_merecimento = {}
    
    for quadro in quadros_merecimento:
        militares_quadro = []
        for item in quadro.itemquadroacesso_set.all().order_by('posicao'):
            militar = item.militar
            # Buscar ficha de conceito do militar
            if comissao.tipo == 'CPO':
                ficha = militar.fichaconceitooficiais_set.first()
            else:
                ficha = militar.fichaconceitopracas_set.first()
            
            if ficha:
                militares_quadro.append({
                    'militar': militar,
                    'ficha': ficha,
                    'posicao': item.posicao,
                    'pontuacao': item.pontuacao
                })
        
        if militares_quadro:
            fichas_conceito_merecimento[quadro] = militares_quadro
    
    # Buscar votos da comissÃ£o
    votos_comissao = VotoDeliberacao.objects.filter(
        deliberacao__sessao__comissao=comissao
    ).select_related(
        'deliberacao__sessao',
        'membro__militar'
    ).order_by('-data_registro')[:10]  # Ãšltimos 10 votos
    
    # Calcular estatÃ­sticas dos votos
    total_votos = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao).count()
    votos_favor = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='FAVOR').count()
    votos_contra = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='CONTRA').count()
    votos_abstencao = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='ABSTENCAO').count()
    
    context = {
        'comissao': comissao,
        'membros': comissao.membros.all(),
        'sessoes': comissao.sessoes.all()[:5],  # Ãšltimas 5 sessÃµes
        'quadros_acesso': quadros_acesso,
        'quadros_fixacao_vagas': quadros_fixacao_vagas,
        'fichas_conceito_merecimento': fichas_conceito_merecimento,
        'votos_comissao': votos_comissao,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
    }
    return render(request, 'militares/comissao/detail.html', context)


@login_required
def comissao_create(request):
    """Criar nova comissÃ£o de promoÃ§Ã£o de oficiais"""
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST)
        if form.is_valid():
            nova_comissao = form.save(commit=False)
            # Inativar comissÃ£o ativa do mesmo tipo
            comissao_ativa = ComissaoPromocao.objects.filter(tipo=nova_comissao.tipo, status='ATIVA').first()
            if comissao_ativa:
                comissao_ativa.status = 'INATIVA'
                comissao_ativa.save()
            nova_comissao.status = 'ATIVA'
            nova_comissao.save()
            messages.success(request, 'ComissÃ£o criada com sucesso!')
            return redirect('militares:comissao_detail', pk=nova_comissao.pk)
    else:
        form = ComissaoPromocaoForm()
    context = {
        'form': form,
        'title': 'Nova ComissÃ£o de PromoÃ§Ã£o',
    }
    return render(request, 'militares/comissao/form.html', context)


@login_required
def comissao_update(request, pk):
    """Editar comissÃ£o de promoÃ§Ã£o de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST, instance=comissao)
        if form.is_valid():
            form.save()
            messages.success(request, 'ComissÃ£o atualizada com sucesso!')
            return redirect('militares:comissao_detail', pk=comissao.pk)
    else:
        form = ComissaoPromocaoForm(instance=comissao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Editar ComissÃ£o de PromoÃ§Ã£o de Oficiais',
    }
    return render(request, 'militares/comissao/form.html', context)


@login_required
@user_passes_test(lambda u: u.is_staff)
def comissao_delete(request, pk):
    """Excluir comissÃ£o de promoÃ§Ã£o de oficiais - apenas administradores"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se a comissÃ£o tem sessÃµes
    if comissao.sessoes.exists():
        messages.error(request, 'NÃ£o Ã© possÃ­vel excluir uma comissÃ£o que possui sessÃµes. Apenas ediÃ§Ã£o Ã© permitida.')
        return redirect('militares:comissao_detail', pk=pk)
    
    if request.method == 'POST':
        comissao.delete()
        messages.success(request, 'ComissÃ£o excluÃ­da com sucesso!')
        return redirect('militares:comissao_list')
    
    context = {
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/delete.html', context)


@login_required
@usuario_cpo_required
def membro_comissao_list(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar membros e ordenar por hierarquia
    membros = list(comissao.membros.all())
    
    # Ordenar por tipo primeiro, depois por hierarquia de posto
    membros.sort(key=lambda x: (
        x.tipo,  # Primeiro por tipo (EFETIVO, NATO, SUPLENTE)
        hierarquia_postos.get(x.militar.posto_graduacao, 999),  # Depois por hierarquia
        x.militar.nome_completo  # Por Ãºltimo por nome
    ))
    
    # Calcular contagens para estatÃ­sticas usando list comprehension
    membros_ativos_count = sum(1 for membro in membros if membro.ativo)
    membros_com_usuario_count = sum(1 for membro in membros if membro.usuario is not None)
    membros_sem_usuario_count = sum(1 for membro in membros if membro.usuario is None)
    
    context = {
        'comissao': comissao,
        'membros': membros,
        'membros_ativos_count': membros_ativos_count,
        'membros_com_usuario_count': membros_com_usuario_count,
        'membros_sem_usuario_count': membros_sem_usuario_count,
        'title': 'Membros da ComissÃ£o',
    }
    return render(request, 'militares/comissao/membros/list.html', context)


@login_required
@usuario_cpo_required
def membro_comissao_add(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar funÃ§Ã£o atual do usuÃ¡rio
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma funÃ§Ã£o selecionada. Selecione uma funÃ§Ã£o primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'FunÃ§Ã£o atual nÃ£o encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            membro.comissao = comissao
            # Definir o usuÃ¡rio automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # VerificaÃ§Ã£o de duplicidade
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exists()
            if existe:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })

            try:
                membro.save()
                messages.success(request, 'Membro adicionado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })
    else:
        form = MembroComissaoForm(comissao_tipo=comissao.tipo)
        
        # Verificar se o usuÃ¡rio tem permissÃ£o administrativa
        funcoes_admin = [
            'ADMINISTRADOR', 'SUPER USUÃRIO', 'COMANDANTE GERAL', 'SUBCOMANDANTE GERAL',
            'DIRETOR DE GESTÃƒO DE PESSOAS', 'CHEFE DA SEÃ‡ÃƒO DE PROMOÃ‡Ã•ES'
        ]
        
        # Verificar se o usuÃ¡rio tem funÃ§Ã£o administrativa
        tem_permissao_admin = any(
            funcao_admin in funcao_atual.cargo_funcao.nome.upper() 
            for funcao_admin in funcoes_admin
        )
        
        # Filtrar militares baseado na funÃ§Ã£o do usuÃ¡rio e tipo de comissÃ£o
        if comissao.tipo == 'CPO':  # ComissÃ£o de PromoÃ§Ã£o de Oficiais
            if tem_permissao_admin or 'CPO' in funcao_atual.cargo_funcao.nome.upper():
                # Administradores ou membros CPO podem adicionar oficiais
                form.fields['militar'].queryset = Militar.objects.filter(
                    situacao='AT',
                    posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
                ).order_by('nome_completo')
            else:
                messages.warning(request, 'VocÃª nÃ£o tem permissÃ£o para adicionar membros Ã  ComissÃ£o de Oficiais.')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
                
        elif comissao.tipo == 'CPP':  # ComissÃ£o de PromoÃ§Ã£o de PraÃ§as
            if tem_permissao_admin or 'CPP' in funcao_atual.cargo_funcao.nome.upper():
                # Administradores ou membros CPP podem adicionar oficiais (membros da comissÃ£o sÃ£o sempre oficiais)
                form.fields['militar'].queryset = Militar.objects.filter(
                    situacao='AT',
                    posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
                ).order_by('nome_completo')
            else:
                messages.warning(request, 'VocÃª nÃ£o tem permissÃ£o para adicionar membros Ã  ComissÃ£o de PraÃ§as.')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
    
    context = {
        'form': form,
        'comissao': comissao,
        'funcao_atual': funcao_atual,
        'title': 'Adicionar Membro',
    }
    return render(request, 'militares/comissao/membros/form.html', context)


@login_required
@usuario_cpo_required
def membro_comissao_update(request, comissao_pk, pk):
    """Editar membro da comissÃ£o"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro nÃ£o encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    # Verificar funÃ§Ã£o atual do usuÃ¡rio
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma funÃ§Ã£o selecionada. Selecione uma funÃ§Ã£o primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'FunÃ§Ã£o atual nÃ£o encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, instance=membro, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            # Definir o usuÃ¡rio automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # VerificaÃ§Ã£o de duplicidade (excluindo o prÃ³prio membro sendo editado)
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exclude(pk=membro.pk).exists()
            if existe:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da ComissÃ£o',
                })

            try:
                membro.save()
                messages.success(request, 'Membro atualizado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da ComissÃ£o',
                })
    else:
        form = MembroComissaoForm(instance=membro, comissao_tipo=comissao.tipo)
        
        # Verificar se o usuÃ¡rio tem permissÃ£o administrativa
        funcoes_admin = [
            'ADMINISTRADOR', 'SUPER USUÃRIO', 'COMANDANTE GERAL', 'SUBCOMANDANTE GERAL',
            'DIRETOR DE GESTÃƒO DE PESSOAS', 'CHEFE DA SEÃ‡ÃƒO DE PROMOÃ‡Ã•ES'
        ]
        
        # Verificar se o usuÃ¡rio tem funÃ§Ã£o administrativa
        tem_permissao_admin = any(
            funcao_admin in funcao_atual.cargo_funcao.nome.upper() 
            for funcao_admin in funcoes_admin
        )
        
        # Filtrar militares baseado na funÃ§Ã£o do usuÃ¡rio e tipo de comissÃ£o
        if comissao.tipo == 'CPO':  # ComissÃ£o de PromoÃ§Ã£o de Oficiais
            if tem_permissao_admin or 'CPO' in funcao_atual.cargo_funcao.nome.upper():
                # Administradores ou membros CPO podem editar oficiais
                form.fields['militar'].queryset = Militar.objects.filter(
                    situacao='AT',
                    posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
                ).order_by('nome_completo')
            else:
                messages.warning(request, 'VocÃª nÃ£o tem permissÃ£o para editar membros da ComissÃ£o de Oficiais.')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
                
        elif comissao.tipo == 'CPP':  # ComissÃ£o de PromoÃ§Ã£o de PraÃ§as
            if tem_permissao_admin or 'CPP' in funcao_atual.cargo_funcao.nome.upper():
                # Administradores ou membros CPP podem editar oficiais (membros da comissÃ£o sÃ£o sempre oficiais)
                form.fields['militar'].queryset = Militar.objects.filter(
                    situacao='AT',
                    posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
                ).order_by('nome_completo')
            else:
                messages.warning(request, 'VocÃª nÃ£o tem permissÃ£o para editar membros da ComissÃ£o de PraÃ§as.')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
    
    context = {
        'form': form,
        'comissao': comissao,
        'membro': membro,
        'funcao_atual': funcao_atual,
        'title': 'Editar Membro da ComissÃ£o',
    }
    return render(request, 'militares/comissao/membros/form.html', context)


@login_required
@usuario_cpo_required
def membro_comissao_delete(request, comissao_pk, pk):
    """Remover membro da comissÃ£o"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro nÃ£o encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    if request.method == 'POST':
        membro.delete()
        messages.success(request, 'Membro removido com sucesso!')
        return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
    
    context = {
        'comissao': comissao,
        'membro': membro,
    }
    return render(request, 'militares/comissao/membros/delete.html', context)


@login_required
@usuario_cpo_required
def sessao_comissao_list(request):
    """Lista sessÃµes de uma comissÃ£o"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'ComissÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    sessoes = comissao.sessoes.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        sessoes = sessoes.filter(status=status)
    
    tipo = request.GET.get('tipo')
    if tipo:
        sessoes = sessoes.filter(tipo=tipo)
    
    context = {
        'comissao': comissao,
        'sessoes': sessoes,
        'status_choices': SessaoComissao.STATUS_CHOICES,
        'tipo_choices': SessaoComissao.TIPO_CHOICES,
    }
    return render(request, 'militares/comissao/sessoes/list.html', context)


@login_required
@usuario_cpo_required
def sessao_comissao_detail(request, pk):
    """Detalhes de uma sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all(),
        'user_membro': user_membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
    }
    return render(request, 'militares/comissao/sessoes/detail.html', context)


@login_required
@usuario_cpo_required
def sessao_comissao_create(request):
    """Criar nova sessÃ£o"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'ComissÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES)
        if form.is_valid():
            sessao = form.save(commit=False)
            sessao.comissao = comissao
            sessao.save()
            
            # Criar registros de presenÃ§a para todos os membros
            for membro in comissao.membros.filter(ativo=True):
                PresencaSessao.objects.create(
                    sessao=sessao,
                    membro=membro,
                    presente=False
                )
            
            # Criar documento se fornecido
            documento_titulo = form.cleaned_data.get('documento_titulo')
            documento_tipo = form.cleaned_data.get('documento_tipo')
            documento_arquivo = form.cleaned_data.get('documento_arquivo')
            documento_descricao = form.cleaned_data.get('documento_descricao')
            
            if documento_titulo and documento_tipo and documento_arquivo:
                documento = DocumentoSessao.objects.create(
                    sessao=sessao,
                    tipo=documento_tipo,
                    titulo=documento_titulo,
                    descricao=documento_descricao,
                    arquivo=documento_arquivo,
                    upload_por=request.user
                )
                messages.success(request, f'SessÃ£o criada com sucesso! Documento "{documento.titulo}" anexado.')
            else:
                messages.success(request, 'SessÃ£o criada com sucesso!')
            
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = SessaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Nova SessÃ£o da ComissÃ£o',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)


@login_required
@usuario_cpo_required
def sessao_comissao_update(request, pk):
    """Editar sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES, instance=sessao)
        if form.is_valid():
            try:
                # Salvar a sessÃ£o
                sessao_atualizada = form.save()
                
                # Processar documento se fornecido
                documento_titulo = form.cleaned_data.get('documento_titulo')
                documento_tipo = form.cleaned_data.get('documento_tipo')
                documento_arquivo = form.cleaned_data.get('documento_arquivo')
                documento_descricao = form.cleaned_data.get('documento_descricao')
                
                if documento_titulo and documento_tipo and documento_arquivo:
                    # Criar ou atualizar documento da sessÃ£o
                    documento_sessao, created = DocumentoSessao.objects.get_or_create(
                        sessao=sessao_atualizada,
                        defaults={
                            'tipo': documento_tipo,
                            'titulo': documento_titulo,
                            'descricao': documento_descricao or '',
                            'arquivo': documento_arquivo,
                            'upload_por': request.user,
                        }
                    )
                    
                    if not created:
                        # Atualizar documento existente
                        documento_sessao.tipo = documento_tipo
                        documento_sessao.titulo = documento_titulo
                        documento_sessao.descricao = documento_descricao or ''
                        documento_sessao.arquivo = documento_arquivo
                        documento_sessao.save()
                
                messages.success(request, 'SessÃ£o atualizada com sucesso!')
                return redirect('militares:sessao_comissao_detail', pk=sessao_atualizada.pk)
            except Exception as e:
                messages.error(request, f'Erro ao salvar sessÃ£o: {str(e)}')
        else:
            # Log dos erros de validaÃ§Ã£o para debug
            print("Erros de validaÃ§Ã£o do formulÃ¡rio:")
            for field, errors in form.errors.items():
                print(f"Campo {field}: {errors}")
            
            # Criar mensagem de erro mais especÃ­fica
            error_messages = []
            for field, errors in form.errors.items():
                field_name = form.fields[field].label if field in form.fields else field
                for error in errors:
                    error_messages.append(f"{field_name}: {error}")
            
            if error_messages:
                messages.error(request, f'Erro ao atualizar sessÃ£o: {"; ".join(error_messages)}')
            else:
                messages.error(request, 'Erro ao atualizar sessÃ£o. Verifique os dados informados.')
    else:
        form = SessaoComissaoForm(instance=sessao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Editar SessÃ£o da ComissÃ£o',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)


@login_required
def presenca_sessao_update(request, sessao_pk):
    """Atualizar presenÃ§as de uma sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        # Obter todos os membros da comissÃ£o
        membros = comissao.membros.all()
        
        for membro in membros:
            # Verificar se o membro estÃ¡ presente
            presente = request.POST.get(f'presenca_{membro.pk}') == '1'
            
            # Obter ou criar presenÃ§a
            presenca, created = PresencaSessao.objects.get_or_create(
                sessao=sessao,
                membro=membro,
                defaults={'presente': presente}
            )
            
            # Atualizar presenÃ§a
            presenca.presente = presente
            presenca.save()
            
            # Debug: imprimir informaÃ§Ãµes
            print(f"Membro: {membro.militar.nome_completo}, Presente: {presente}, POST data: {request.POST.get(f'presenca_{membro.pk}')}")
        
        # Debug: imprimir todos os dados POST
        print("POST data:", request.POST)
        print("Total de presenÃ§as salvas:", sessao.presencas.filter(presente=True).count())
        
        messages.success(request, 'PresenÃ§as atualizadas com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Obter membros da comissÃ£o
    membros = comissao.membros.all()
    
    # Obter presenÃ§as existentes
    presencas_existentes = set(sessao.presencas.filter(presente=True).values_list('membro_id', flat=True))
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'membros': membros,
        'presencas_existentes': presencas_existentes,
    }
    return render(request, 'militares/comissao/sessoes/presenca_form.html', context)


@login_required
def deliberacao_comissao_create(request):
    """Criar nova deliberaÃ§Ã£o"""
    sessao_pk = request.GET.get('sessao')
    resultado = request.GET.get('resultado')
    
    if not sessao_pk:
        messages.error(request, 'SessÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Se o parÃ¢metro resultado estiver presente, redirecionar para a pÃ¡gina de resultados
    if resultado:
        return redirect('militares:deliberacao_comissao_resultado', sessao_pk=sessao.pk)
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST)
        if form.is_valid():
            deliberacao = form.save(commit=False)
            deliberacao.sessao = sessao
            deliberacao.save()
            
            messages.success(request, 'DeliberaÃ§Ã£o criada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Nova DeliberaÃ§Ã£o',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)


@login_required
def deliberacao_comissao_update(request, pk):
    """Editar deliberaÃ§Ã£o"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'DeliberaÃ§Ã£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST, instance=deliberacao)
        if form.is_valid():
            form.save()
            messages.success(request, 'DeliberaÃ§Ã£o atualizada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm(instance=deliberacao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'title': 'Editar DeliberaÃ§Ã£o',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)


@login_required
def voto_deliberacao_create(request, deliberacao_pk):
    """Registrar voto do usuÃ¡rio logado em uma deliberaÃ§Ã£o"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=deliberacao_pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'DeliberaÃ§Ã£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio logado Ã© membro da comissÃ£o
    membro_usuario = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    if not membro_usuario:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se o membro estava presente na sessÃ£o
    presenca = sessao.presencas.filter(membro=membro_usuario, presente=True).first()
    if not presenca:
        messages.error(request, 'VocÃª nÃ£o estava presente nesta sessÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se jÃ¡ votou
    voto_existente = deliberacao.votos.filter(membro=membro_usuario).first()
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar o voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Validar senha do usuÃ¡rio
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Obter dados do voto
        voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        
        if not voto:
            messages.error(request, 'VocÃª deve escolher uma opÃ§Ã£o de voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Criar ou atualizar voto
        if voto_existente:
            voto_existente.voto = voto
            voto_existente.voto_proferido = voto_proferido
            voto_existente.save()
        else:
            voto_existente = VotoDeliberacao.objects.create(
                deliberacao=deliberacao,
                membro=membro_usuario,
                voto=voto,
                voto_proferido=voto_proferido
            )
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        if voto_existente:
            messages.success(request, f'âœ… Voto atualizado com sucesso!')
        else:
            messages.success(request, f'âœ… Voto registrado com sucesso!')
        
        # Redirecionar de volta para o formulÃ¡rio de voto para mostrar os dados atualizados
        return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
    
    # Criar formulÃ¡rio para o voto proferido com CKEditor
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                    'class': 'ckeditor5',
                    'data-config-name': 'voto_proferido_config'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto_existente.voto_proferido if voto_existente else ''
    })
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'membro_usuario': membro_usuario,
        'voto_existente': voto_existente,
        'form': form,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)


@login_required
def comissao_pdf(request, pk):
    """Gerar PDF da comissÃ£o de promoÃ§Ã£o de oficiais"""
    from reportlab.platypus import SimpleDocTemplate, Image, Spacer, Paragraph
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    # Criar o PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="comissao_promocao_{pk}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    
    story = []
    
    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))
    
    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        f"{comissao.get_tipo_display().upper()} - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))
    

    
    # InformaÃ§Ãµes da comissÃ£o
    story.append(Paragraph(f"<b>Nome:</b> {comissao.nome}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Data de CriaÃ§Ã£o:</b> {comissao.data_criacao.strftime('%d/%m/%Y')}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Status:</b> {comissao.get_status_display()}", style_bold))
    story.append(Spacer(1, 6))
    
    if comissao.data_termino:
        story.append(Paragraph(f"<b>Data de TÃ©rmino:</b> {comissao.data_termino.strftime('%d/%m/%Y')}", style_bold))
        story.append(Spacer(1, 6))
    
    story.append(Spacer(1, 12))
    
    # Obter todos os membros ativos ordenados por tipo (presidente, membros, secretÃ¡rio)
    membros_ativos = comissao.membros.filter(ativo=True).order_by(
        'tipo'  # PRESIDENTE, EFETIVO, NATO, SECRETARIO
    )
    
    # Presidente
    presidente = membros_ativos.filter(tipo='PRESIDENTE').first()
    if presidente:
        story.append(Paragraph("<b>PRESIDENTE:</b>", style_bold))
        story.append(Paragraph(f"{presidente.militar.get_posto_graduacao_display()} {presidente.militar.get_quadro_display()} {presidente.militar.nome_completo} - {presidente.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Natos
    membros_natos = membros_ativos.filter(tipo='NATO')
    if membros_natos:
        story.append(Paragraph("<b>MEMBROS NATOS:</b>", style_bold))
        for membro in membros_natos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Efetivos
    membros_efetivos = membros_ativos.filter(tipo='EFETIVO')
    if membros_efetivos:
        story.append(Paragraph("<b>MEMBROS EFETIVOS:</b>", style_bold))
        for membro in membros_efetivos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # SecretÃ¡rio
    secretario = membros_ativos.filter(tipo='SECRETARIO').first()
    if secretario:
        story.append(Paragraph("<b>SECRETÃRIO:</b>", style_bold))
        story.append(Paragraph(f"{secretario.militar.get_posto_graduacao_display()} {secretario.militar.get_quadro_display()} {secretario.militar.nome_completo} - {secretario.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # ObservaÃ§Ãµes
    if comissao.observacoes:
        story.append(Spacer(1, 12))
        story.append(Paragraph("<b>OBSERVAÃ‡Ã•ES:</b>", style_bold))
        story.append(Paragraph(comissao.observacoes, style_center))
    
    # Gerar o PDF
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    
    response.write(pdf)
    return response

@login_required
def comissao_encerrar(request, pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    if comissao.status == 'INATIVA':
        messages.info(request, 'Esta comissÃ£o jÃ¡ estÃ¡ inativa.')
    else:
        comissao.status = 'INATIVA'
        comissao.save()
        messages.success(request, 'ComissÃ£o encerrada com sucesso!')
    return redirect('militares:comissao_list')


@login_required
def documento_sessao_create(request):
    """Upload de documento para uma sessÃ£o"""
    sessao_pk = request.GET.get('sessao')
    if not sessao_pk:
        messages.error(request, 'SessÃ£o nÃ£o especificada.')
        return redirect('militares:sessao_comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_list')
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.sessao = sessao
            documento.upload_por = request.user
            documento.save()
            messages.success(request, f'Documento "{documento.titulo}" enviado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm()
    
    context = {
        'form': form,
        'sessao': sessao,
        'title': 'Enviar Documento',
        'action': 'create',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)


@login_required
def documento_sessao_update(request, pk):
    """Editar documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES, instance=documento)
        if form.is_valid():
            form.save()
            messages.success(request, f'Documento "{documento.titulo}" atualizado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
        else:
            messages.error(request, 'Erro ao atualizar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm(instance=documento)
    
    context = {
        'form': form,
        'documento': documento,
        'sessao': documento.sessao,
        'title': 'Editar Documento',
        'action': 'update',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)


@login_required
def documento_sessao_delete(request, pk):
    """Excluir documento da sessÃ£o (apenas admin/staff)"""
    if not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir documentos. Apenas administradores podem realizar esta aÃ§Ã£o.')
        documento = get_object_or_404(DocumentoSessao, pk=pk)
        return render(request, 'militares/comissao/documentos/delete.html', {'sessao': documento.sessao, 'documento': documento})
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    sessao_pk = documento.sessao.pk
    titulo = documento.titulo
    
    if request.method == 'POST':
        documento.delete()
        messages.success(request, f'Documento "{titulo}" excluÃ­do com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao_pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    return render(request, 'militares/comissao/documentos/delete.html', context)


@login_required
def documento_sessao_view(request, pk):
    """Visualizar documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=documento.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        # Verificar se o usuÃ¡rio Ã© membro mas nÃ£o estÃ¡ ativo
        try:
            membro_inativo = MembroComissao.objects.get(
                comissao=documento.sessao.comissao,
                usuario=request.user
            )
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este documento. Seu cadastro na comissÃ£o nÃ£o estÃ¡ ativo.')
        except MembroComissao.DoesNotExist:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este documento. VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    
    if documento.can_preview():
        return render(request, 'militares/comissao/documentos/view.html', context)
    else:
        # Para arquivos que nÃ£o podem ser visualizados, fazer download
        import os
        if os.path.exists(documento.arquivo.path):
            return FileResponse(open(documento.arquivo.path, 'rb'), content_type='application/octet-stream')
        else:
            messages.error(request, 'Arquivo nÃ£o encontrado.')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)


@login_required
def documento_sessao_download(request, pk):
    """Download de documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=documento.sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        # Verificar se o usuÃ¡rio Ã© membro mas nÃ£o estÃ¡ ativo
        membro_inativo = MembroComissao.objects.filter(
            comissao=documento.sessao.comissao,
            usuario=request.user
        ).first()
        if membro_inativo:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para baixar este documento. Seu cadastro na comissÃ£o nÃ£o estÃ¡ ativo.')
        else:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para baixar este documento. VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    import os
    if os.path.exists(documento.arquivo.path):
        response = FileResponse(open(documento.arquivo.path, 'rb'))
        response['Content-Disposition'] = f'attachment; filename="{documento.filename()}"'
        return response
    else:
        messages.error(request, 'Arquivo nÃ£o encontrado.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)


@login_required
def sessao_encerrar(request, pk):
    """Encerrar sessÃ£o com confirmaÃ§Ã£o de senha"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se todos os presentes (exceto presidente) votaram
    todos_votaram = sessao.todos_presentes_votaram_exceto_presidente
    
    # Se nÃ£o todos votaram, apenas o secretÃ¡rio pode encerrar
    if not todos_votaram and membro.cargo != 'SECRETARIO':
        messages.error(request, 'Apenas o secretÃ¡rio pode encerrar a sessÃ£o quando nem todos os membros votaram.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar membros presentes que nÃ£o votaram (excluindo o presidente)
    membros_sem_voto = []
    for presenca in sessao.presencas.filter(presente=True):
        membro_presenca = presenca.membro
        # O presidente nÃ£o Ã© obrigado a votar
        if membro_presenca.cargo == 'PRESIDENTE':
            continue
            
        votos_do_membro = VotoDeliberacao.objects.filter(
            deliberacao__sessao=sessao,
            membro=membro_presenca
        ).count()
        if votos_do_membro < sessao.deliberacoes.count():
            membros_sem_voto.append({
                'membro': membro_presenca,
                'votos_realizados': votos_do_membro,
                'total_deliberacoes': sessao.deliberacoes.count(),
                'deliberacoes_nao_votadas': sessao.deliberacoes.count() - votos_do_membro
            })
    
    if request.method == 'POST':
        password = request.POST.get('password')
        if not password:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para encerrar a sessÃ£o.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        if not request.user.check_password(password):
            messages.error(request, 'Senha incorreta. SessÃ£o nÃ£o foi encerrada.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        # Coletar justificativas para membros sem voto (apenas se secretÃ¡rio e nem todos votaram)
        justificativas = {}
        if membro.cargo == 'SECRETARIO' and membros_sem_voto:
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                justificativa = request.POST.get(f'justificativa_{membro_id}', '').strip()
                if justificativa:
                    justificativas[membro_id] = justificativa
        
        # Encerrar a sessÃ£o
        sessao.status = 'CONCLUIDA'
        sessao.hora_fim = timezone.now().time()
        sessao.save()
        
        # Salvar justificativas se houver
        if justificativas:
            
            justificativas_salvas = []
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                if membro_id in justificativas:
                    # Salvar justificativa no modelo
                    justificativa_obj, created = JustificativaEncerramento.objects.get_or_create(
                        sessao=sessao,
                        membro=membro_info['membro'],
                        defaults={
                            'justificativa': justificativas[membro_id],
                            'registrado_por': request.user
                        }
                    )
                    
                    if not created:
                        # Atualizar justificativa existente
                        justificativa_obj.justificativa = justificativas[membro_id]
                        justificativa_obj.registrado_por = request.user
                        justificativa_obj.save()
                    
                    justificativas_salvas.append(
                        f"{membro_info['membro'].militar.nome_completo}: {justificativas[membro_id]}"
                    )
            
            if justificativas_salvas:
                messages.success(request, f'SessÃ£o {sessao.numero} encerrada com sucesso! {len(justificativas_salvas)} justificativa(s) registrada(s).')
        else:
            messages.success(request, f'SessÃ£o {sessao.numero} encerrada com sucesso!')
        
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'membros_sem_voto': membros_sem_voto,
        'todos_votaram': todos_votaram,
        'membro_usuario': membro
    })

@login_required
def sessao_gerar_ata(request, pk):
    """Gerar ata da sessÃ£o da comissÃ£o"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    return render(request, 'militares/comissao/sessoes/ata.html', context)

@login_required
def sessao_editar_ata(request, pk):
    """Editar ata da sessÃ£o com editor de texto rico"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    # Se for uma requisiÃ§Ã£o AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if request.method == 'POST':
            print(f"DEBUG: Recebendo POST AJAX - dados: {request.POST}")
            form = AtaSessaoForm(request.POST, instance=ata)
            print(f"DEBUG: Form vÃ¡lido: {form.is_valid()}")
            if form.is_valid():
                ata = form.save(commit=False)
                ata.editado_por = request.user
                ata.save()
                print(f"DEBUG: Ata salva com sucesso - versÃ£o: {ata.versao}")
                return JsonResponse({
                    'success': True,
                    'message': f'Ata salva com sucesso! VersÃ£o {ata.versao}.',
                    'versao': ata.versao
                })
            else:
                print(f"DEBUG: Erros no formulÃ¡rio: {form.errors}")
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                })
        else:
            return JsonResponse({
                'success': False,
                'errors': {'__all__': ['MÃ©todo nÃ£o permitido']}
            })
    
    # Processamento normal (nÃ£o-AJAX)
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! VersÃ£o {ata.versao}.')
            return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    return render(request, 'militares/comissao/sessoes/editar_ata.html', context)


@login_required
def sessao_atas_list(request, pk):
    """Listar atas da sessÃ£o"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Buscar todas as atas da sessÃ£o (incluindo histÃ³rico de versÃµes)
    atas = AtaSessao.objects.filter(sessao=sessao).order_by('-data_edicao')
    
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'atas': atas,
        'membro_usuario': membro,
    }
    
    return render(request, 'militares/comissao/sessoes/atas_list.html', context)


@login_required
def ata_conteudo_ajax(request, pk):
    """Retornar conteÃºdo da ata via AJAX"""
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'VocÃª nÃ£o Ã© membro desta comissÃ£o.'
            })
        
        return JsonResponse({
            'success': True,
            'conteudo': ata.conteudo or '',
            'sessao_numero': ata.sessao.numero,
            'data_sessao': ata.sessao.data_sessao.strftime('%d/%m/%Y'),
            'hora_sessao': ata.sessao.hora_inicio.strftime('%H:%M'),
            'local_sessao': ata.sessao.local,
            'versao': ata.versao,
            'editado_por': ata.editado_por.get_full_name() or ata.editado_por.username,
            'data_edicao': ata.data_edicao.strftime('%d/%m/%Y %H:%M')
        })
        
    except AtaSessao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Ata nÃ£o encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao carregar ata: {str(e)}'
        })


@login_required
def sessao_editar_ata_popup(request, pk):
    """Editar ata da sessÃ£o em pÃ¡gina separada/popup"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! VersÃ£o {ata.versao}.')
            return redirect('militares:sessao_editar_ata_popup', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    # Se for uma requisiÃ§Ã£o AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.save()
            return JsonResponse({
                'success': True,
                'message': f'Ata salva com sucesso! VersÃ£o {ata.versao}.',
                'versao': ata.versao
            })
        else:
            return JsonResponse({
                'success': False,
                'errors': form.errors
            })
    
    return render(request, 'militares/comissao/sessoes/editar_ata_popup.html', context)


@login_required
def ata_para_assinatura(request, pk):
    """Marcar ata para assinatura dos membros"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        ata.status = 'PARA_ASSINATURA'
        ata.save()
        messages.success(request, 'Ata marcada para assinatura dos membros.')
        return redirect('militares:ata_assinaturas', pk=pk)
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': ata.sessao.presencas.filter(presente=True),
    }
    return render(request, 'militares/comissao/sessoes/ata_para_assinatura.html', context)


@login_required
def ata_assinaturas(request, pk):
    """Gerenciar assinaturas da ata"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        # Processar assinatura
        membro_id = request.POST.get('membro_id')
        observacoes = request.POST.get('observacoes', '').strip()
        
        if membro_id:
            try:
                membro_para_assinar = MembroComissao.objects.get(id=membro_id)
                # Verificar se o membro estava presente
                if not ata.sessao.presencas.filter(membro=membro_para_assinar, presente=True).exists():
                    messages.error(request, 'Apenas membros presentes podem assinar a ata.')
                    return redirect('militares:ata_assinaturas', pk=pk)
                
                # Criar ou atualizar assinatura
                assinatura, created = AssinaturaAta.objects.get_or_create(
                    ata=ata,
                    membro=membro_para_assinar,
                    defaults={
                        'assinado_por': request.user,
                        'observacoes': observacoes
                    }
                )
                
                if not created:
                    assinatura.assinado_por = request.user
                    assinatura.observacoes = observacoes
                    assinatura.save()
                
                messages.success(request, f'Assinatura de {membro_para_assinar.militar.nome_completo} registrada com sucesso!')
                
                # Verificar se todos assinaram
                if ata.pode_ser_finalizada():
                    ata.status = 'ASSINADA'
                    ata.save()
                    messages.info(request, 'Todos os membros presentes assinaram a ata!')
                
            except MembroComissao.DoesNotExist:
                messages.error(request, 'Membro nÃ£o encontrado.')
    
    # Obter membros presentes e suas assinaturas
    membros_presentes = ata.sessao.presencas.filter(presente=True).select_related('membro__militar')
    assinaturas = ata.assinaturas.select_related('membro__militar', 'assinado_por')
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': membros_presentes,
        'assinaturas': assinaturas,
        'membro_usuario': membro,
    }
    return render(request, 'militares/comissao/sessoes/ata_assinaturas.html', context)


@login_required
def ata_gerar_pdf(request, pk):
    """Gerar PDF da ata finalizada"""
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_JUSTIFY
    from io import BytesIO
    import html2text
    import os
    import qrcode
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se a ata estÃ¡ finalizada
    if ata.status != 'ASSINADA' and ata.status != 'FINALIZADA':
        messages.error(request, 'A ata deve estar assinada para gerar o PDF.')
        return redirect('militares:ata_assinaturas', pk=pk)
    
    # Criar o PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Configurar fonte para suportar caracteres especiais
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    
    # Registrar fonte que suporta UTF-8 (usando fonte padrÃ£o do sistema)
    try:
        # Tentar usar fonte Arial que suporta caracteres especiais
        pdfmetrics.registerFont(TTFont('Arial', 'arial.ttf'))
        font_name = 'Arial'
    except:
        # Se nÃ£o conseguir, usar fonte padrÃ£o
        font_name = 'Helvetica'
    
    # Estilos customizados com fonte que suporta UTF-8
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11, fontName=font_name)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName=font_name, fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1, fontName=font_name)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8, fontName=font_name)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9, fontName=font_name)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11, spaceAfter=8, fontName=font_name)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6, fontName=font_name)
    # Novos estilos para formataÃ§Ã£o avanÃ§ada
    style_heading1 = ParagraphStyle('heading1', parent=styles['Heading1'], fontSize=12, spaceAfter=8, spaceBefore=12, fontName=font_name)
    style_heading2 = ParagraphStyle('heading2', parent=styles['Heading2'], fontSize=11, spaceAfter=6, spaceBefore=10, fontName=font_name)
    style_heading3 = ParagraphStyle('heading3', parent=styles['Heading3'], fontSize=10, spaceAfter=4, spaceBefore=8, fontName=font_name)
    style_paragraph = ParagraphStyle('paragraph', parent=styles['Normal'], fontSize=10, spaceAfter=6, alignment=4, firstLineIndent=20, fontName=font_name)
    style_list_item = ParagraphStyle('list_item', parent=styles['Normal'], fontSize=10, spaceAfter=4, leftIndent=20, firstLineIndent=-10, fontName=font_name)
    style_quote = ParagraphStyle('quote', parent=styles['Normal'], fontSize=10, spaceAfter=6, leftIndent=30, rightIndent=30, fontName=font_name)
    
    story = []
    
    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 3))
    
    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 5))
    
    # TÃ­tulo centralizado e sublinhado
    # Determinar o tipo de comissÃ£o baseado no campo tipo
    if ata.sessao.comissao.tipo == 'CPO':
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS DO CBMEPI"
    elif ata.sessao.comissao.tipo == 'CPP':
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE PRAÃ‡AS DO CBMEPI"
    else:
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DO CBMEPI"
    
    titulo = f'<u>{tipo_comissao}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))
    
    # ConteÃºdo da ata (mantendo HTML do CKEditor, mas limpo para ReportLab)
    style_html = ParagraphStyle('html', parent=styles['Normal'], fontSize=11, alignment=TA_JUSTIFY, spaceAfter=8, leading=16, fontName=font_name)
    conteudo_limpo = clean_html_for_reportlab(ata.conteudo)
    
    story.append(Paragraph(conteudo_limpo, style_html))
    story.append(Spacer(1, 30))
    
    # Assinaturas manuais
    story.append(Spacer(1, 15))
    
    assinaturas = ata.assinaturas.select_related('membro__militar').order_by('data_assinatura')
    for assinatura in assinaturas:
        # FunÃ§Ã£o para obter a abreviaÃ§Ã£o correta do quadro
        def get_quadro_abreviado(quadro):
            if quadro == 'Complementar':
                return 'QOBM/C'
            elif quadro == 'Combatente':
                return 'QOBM/Comb.'
            elif quadro == 'Engenheiro':
                return 'QOBM/E'
            elif quadro == 'SaÃºde':
                return 'QOBM/S'
            else:
                return quadro
        
        # Nome, posto e quadro na mesma linha
        quadro_abreviado = get_quadro_abreviado(assinatura.membro.militar.get_quadro_display())
        nome_posto_quadro = f"{assinatura.membro.militar.nome_completo} - {assinatura.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
        story.append(Paragraph(f"<center>{nome_posto_quadro}</center>", style_center))
        
        # Tipo de membro
        story.append(Paragraph(f"<center>{assinatura.membro.get_tipo_display()}</center>", style_center))
        
        if assinatura.observacoes:
            story.append(Paragraph(f"Obs: {assinatura.observacoes}", style_signature))
        story.append(Spacer(1, 10))
    
    # RodapÃ© com Assinaturas EletrÃ´nicas e QR Code
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas vÃ¡lidas da ata (da mais recente para a mais antiga)
    assinaturas_eletronicas = ata.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas_eletronicas.exists():
        for i, assinatura_eletronica in enumerate(assinaturas_eletronicas):
            # InformaÃ§Ãµes de assinatura eletrÃ´nica
            nome_assinante = assinatura_eletronica.assinado_por.get_full_name() or assinatura_eletronica.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrÃ£o
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "UsuÃ¡rio do Sistema"
            
            data_assinatura = assinatura_eletronica.data_assinatura
            data_formatada = f"{data_assinatura.day:02d}/{data_assinatura.month:02d}/{data_assinatura.year}"
            hora_formatada = f"{data_assinatura.hour:02d}:{data_assinatura.minute:02d}"
            
            # FunÃ§Ã£o para obter a abreviaÃ§Ã£o correta do quadro
            def get_quadro_abreviado(quadro):
                if quadro == 'Complementar':
                    return 'QOBM/C'
                elif quadro == 'Combatente':
                    return 'QOBM/Comb.'
                elif quadro == 'Engenheiro':
                    return 'QOBM/E'
                elif quadro == 'SaÃºde':
                    return 'QOBM/S'
                else:
                    return quadro
            
            # Nome, posto e quadro do militar
            quadro_abreviado = get_quadro_abreviado(assinatura_eletronica.membro.militar.get_quadro_display())
            nome_posto_quadro = f"{assinatura_eletronica.membro.militar.nome_completo} - {assinatura_eletronica.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
            
            # Obter a funÃ§Ã£o atual do usuÃ¡rio
            from .utils import obter_funcao_atual_usuario
            funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema') if request and hasattr(request, 'session') else 'UsuÃ¡rio do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_posto_quadro} - {funcao_atual}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
            if i < len(assinaturas_eletronicas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se nÃ£o houver assinaturas eletrÃ´nicas, mostrar apenas documento gerado pelo usuÃ¡rio logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "UsuÃ¡rio do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuÃ¡rio {nome_usuario} em {data_formatada}, Ã s {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Dados para autenticaÃ§Ã£o
    url_autenticacao = "https://sei.pi.gov.br/sei/controlador_externo.php?acao=documento_conferir&id_orgao_acesso_externo=0"
    codigo_verificador = f"{ata.pk:08d}"
    codigo_crc = f"{hash(str(ata.pk)) % 0xFFFFFFF:07X}"
    
    texto_autenticacao = f"A autenticidade deste documento pode ser conferida no site <a href='{url_autenticacao}' color='blue'>{url_autenticacao}</a>, informando o cÃ³digo verificador <b>{codigo_verificador}</b> e o cÃ³digo CRC <b>{codigo_crc}</b>."
    
    # Gerar QR Code
    qr = qrcode.make(url_autenticacao)
    qr_buffer = BytesIO()
    qr.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    qr_img = Image(qr_buffer, width=2*cm, height=2*cm)
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [qr_img, Paragraph(texto_autenticacao, style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Gerar PDF
    doc.build(story)
    buffer.seek(0)
    
    # Criar resposta HTTP
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="ata_sessao_{ata.sessao.numero}.pdf"'
    
    return response


@login_required
def ata_finalizar(request, pk):
    """Finalizar ata apÃ³s todas as assinaturas"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        if ata.pode_ser_finalizada():
            ata.status = 'FINALIZADA'
            ata.data_finalizacao = timezone.now()
            ata.save()
            messages.success(request, 'Ata finalizada com sucesso! Agora vocÃª pode gerar o PDF.')
        else:
            messages.error(request, 'A ata nÃ£o pode ser finalizada. Todos os membros presentes devem assinar primeiro.')
    
    return redirect('militares:ata_assinaturas', pk=pk)

def clean_html_for_reportlab(html):
    # Remove atributos style, id, class, target, etc.
    html = re.sub(r'(<\w+)([^>]*)(style|id|class|target|rel|onclick|onmouseover|onmouseout|align|width|height|data-[^=]*)=["\"][^"\"]*["\"]', r'\1', html)
    # Remove todos os atributos de todas as tags, exceto href em <a>
    html = re.sub(r'<(?!a\b)(\w+)[^>]*>', r'<\1>', html)
    # Remove atributos de <a> exceto href
    html = re.sub(r'<a\s+[^>]*?href=(["\"][^"\"]*["\"])[^>]*>', r'<a href=\1>', html)
    # Remove tags nÃ£o suportadas (mantÃ©m apenas p, b, i, u, br, a, ul, ol, li, strong, em)
    html = re.sub(r'</?(?!p\b|b\b|i\b|u\b|br\b|a\b|ul\b|ol\b|li\b|strong\b|em\b)[a-zA-Z0-9]+[^>]*>', '', html)
    # Remove comentÃ¡rios HTML
    html = re.sub(r'<!--.*?-->', '', html, flags=re.DOTALL)
    # Remove espaÃ§os extras entre tags
    html = re.sub(r'>\s+<', '><', html)
    # Decodifica entidades HTML
    html = unescape(html)
    return html

@login_required
def modelo_ata_list(request):
    modelos = ModeloAta.objects.all()
    tipo_comissao = request.GET.get('tipo_comissao')
    if tipo_comissao:
        modelos = modelos.filter(tipo_comissao=tipo_comissao)
    tipo_sessao = request.GET.get('tipo_sessao')
    if tipo_sessao:
        modelos = modelos.filter(tipo_sessao=tipo_sessao)
    ativo = request.GET.get('ativo')
    if ativo is not None:
        modelos = modelos.filter(ativo=ativo == 'true')
    padrao = request.GET.get('padrao')
    if padrao is not None:
        modelos = modelos.filter(padrao=padrao == 'true')
    context = {
        'modelos': modelos,
        'tipos_comissao': ModeloAta.TIPO_COMISSAO_CHOICES,
        'tipos_sessao': ModeloAta.TIPO_SESSAO_CHOICES,
        'filtros': {
            'tipo_comissao': tipo_comissao,
            'tipo_sessao': tipo_sessao,
            'ativo': ativo,
            'padrao': padrao,
        }
    }
    return render(request, 'militares/modelo_ata/list.html', context)

@login_required
def modelo_ata_create(request):
    if request.method == 'POST':
        form = ModeloAtaForm(request.POST)
        if form.is_valid():
            modelo = form.save(commit=False)
            modelo.criado_por = request.user
            modelo.save()
            messages.success(request, f'Modelo "{modelo.nome}" criado com sucesso!')
            return redirect('militares:modelo_ata_list')
    else:
        form = ModeloAtaForm()
    context = {
        'form': form,
        'titulo': 'Criar Novo Modelo de Ata',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_update(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    if request.method == 'POST':
        form = ModeloAtaForm(request.POST, instance=modelo)
        if form.is_valid():
            modelo = form.save()
            messages.success(request, f'Modelo "{modelo.nome}" atualizado com sucesso!')
            return redirect('militares:modelo_ata_list')
    else:
        form = ModeloAtaForm(instance=modelo)
    context = {
        'form': form,
        'modelo': modelo,
        'titulo': f'Editar Modelo: {modelo.nome}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_delete(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    if request.method == 'POST':
        nome = modelo.nome
        modelo.delete()
        messages.success(request, f'Modelo "{nome}" excluÃ­do com sucesso!')
        return redirect('militares:modelo_ata_list')
    context = {
        'modelo': modelo,
        'titulo': f'Excluir Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/delete.html', context)

@login_required
def modelo_ata_detail(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    context = {
        'modelo': modelo,
        'titulo': f'Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/detail.html', context)

@login_required
def modelo_ata_aplicar(request, sessao_pk):
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    try:
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    if request.method == 'POST':
        modelo_id = request.POST.get('modelo_id')
        if modelo_id:
            try:
                modelo = ModeloAta.objects.get(pk=modelo_id, ativo=True)
                if modelo.pode_ser_usado_para(sessao):
                    conteudo_aplicado = modelo.aplicar_variaveis(sessao)
                    try:
                        ata = sessao.ata_editada
                    except AtaSessao.DoesNotExist:
                        ata = AtaSessao(sessao=sessao, editado_por=request.user)
                    ata.conteudo = conteudo_aplicado
                    ata.editado_por = request.user
                    ata.save()
                    messages.success(request, f'Modelo "{modelo.nome}" aplicado com sucesso!')
                    return redirect('militares:sessao_editar_ata', pk=sessao.pk)
                else:
                    messages.error(request, 'Este modelo nÃ£o pode ser usado para esta sessÃ£o.')
            except ModeloAta.DoesNotExist:
                messages.error(request, 'Modelo nÃ£o encontrado.')
    modelos_disponiveis = ModeloAta.get_modelos_disponiveis(sessao)
    modelo_padrao = ModeloAta.get_modelo_padrao(sessao)
    context = {
        'sessao': sessao,
        'modelos_disponiveis': modelos_disponiveis,
        'modelo_padrao': modelo_padrao,
        'titulo': f'Aplicar Modelo Ã  SessÃ£o {sessao.numero}'
    }
    return render(request, 'militares/modelo_ata/aplicar.html', context)

@login_required
def modelo_ata_salvar_atual(request, sessao_pk):
    
    print(f"=== INÃCIO DA FUNÃ‡ÃƒO modelo_ata_salvar_atual ===")
    print(f"SessÃ£o PK: {sessao_pk}")
    print(f"MÃ©todo: {request.method}")
    
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    print(f"SessÃ£o encontrada: {sessao}")
    
    # Verificar se existe uma ata
    try:
        ata = sessao.ata_editada
        print(f"Ata encontrada: {ata}")
        print(f"ConteÃºdo da ata: {ata.conteudo[:100] if ata.conteudo else 'VAZIO'}")
    except AtaSessao.DoesNotExist:
        print("ERRO: NÃ£o existe uma ata para esta sessÃ£o")
        messages.error(request, 'NÃ£o existe uma ata para esta sessÃ£o.')
        return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    
    # Criar formulÃ¡rio personalizado sem o campo conteudo
    class ModeloAtaSalvarForm(forms.ModelForm):
        class Meta:
            model = ModeloAta
            fields = ['nome', 'descricao', 'tipo_comissao', 'tipo_sessao', 'ativo', 'padrao']
            widgets = {
                'nome': forms.TextInput(attrs={
                    'class': 'form-control',
                    'placeholder': 'Ex: Modelo PadrÃ£o CPO OrdinÃ¡ria'
                }),
                'descricao': forms.Textarea(attrs={
                    'class': 'form-control',
                    'rows': 3,
                    'placeholder': 'DescriÃ§Ã£o do modelo e quando usÃ¡-lo...'
                }),
                'tipo_comissao': forms.Select(attrs={'class': 'form-control'}),
                'tipo_sessao': forms.Select(attrs={'class': 'form-control'}),
                'ativo': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
                'padrao': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            }
    
    if request.method == 'POST':
        print("=== PROCESSANDO POST ===")
        print(f"POST data: {request.POST}")
        
        form = ModeloAtaSalvarForm(request.POST)
        print(f"Form criado: {form}")
        print(f"Form is_valid: {form.is_valid()}")
        
        if form.is_valid():
            print("=== FORMULÃRIO VÃLIDO ===")
            try:
                modelo = form.save(commit=False)
                print(f"Modelo criado (commit=False): {modelo}")
                
                modelo.criado_por = request.user
                modelo.conteudo = ata.conteudo
                print(f"ConteÃºdo definido: {modelo.conteudo[:100] if modelo.conteudo else 'VAZIO'}")
                
                modelo.save()
                print(f"Modelo salvo com sucesso: {modelo.nome} (ID: {modelo.pk})")
                
                messages.success(request, f'Modelo "{modelo.nome}" criado com sucesso a partir da ata atual!')
                return redirect('militares:modelo_ata_list')
            except Exception as e:
                print(f"ERRO ao salvar modelo: {str(e)}")
                import traceback
                traceback.print_exc()
                messages.error(request, f'Erro ao salvar modelo: {str(e)}')
        else:
            print("=== FORMULÃRIO INVÃLIDO ===")
            print(f"Form errors: {form.errors}")
            for field, errors in form.errors.items():
                for error in errors:
                    print(f"Erro no campo {field}: {error}")
                    messages.error(request, f'Erro no campo {field}: {error}')
    else:
        print("=== MÃ‰TODO GET ===")
        form = ModeloAtaSalvarForm(initial={
            'nome': f'Modelo da SessÃ£o {sessao.numero} - {sessao.comissao.nome}',
            'tipo_comissao': sessao.comissao.tipo,
            'tipo_sessao': sessao.tipo,
            'descricao': f'Modelo criado a partir da ata da sessÃ£o {sessao.numero} realizada em {sessao.data_sessao.strftime("%d/%m/%Y")}',
        })
    
    context = {
        'form': form,
        'sessao': sessao,
        'ata': ata,
        'titulo': f'Salvar Ata como Modelo - SessÃ£o {sessao.numero}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    
    print("=== RENDERIZANDO TEMPLATE ===")
    return render(request, 'militares/modelo_ata/salvar_atual.html', context)

@login_required
def deliberacao_comissao_resultado(request, sessao_pk):
    """Exibir resultado das deliberaÃ§Ãµes com votos dos membros"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    # Buscar todas as deliberaÃ§Ãµes da sessÃ£o com seus votos
    deliberacoes = sessao.deliberacoes.prefetch_related('votos__membro__militar').all()
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacoes': deliberacoes,
        'user_membro': user_membro,
        'membros_presentes': [p.membro for p in sessao.presencas.filter(presente=True)],
    }
    return render(request, 'militares/comissao/deliberacoes/resultado.html', context)


@login_required
def notificacoes_list(request):
    """Lista todas as notificaÃ§Ãµes do usuÃ¡rio"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user
    ).order_by('-data_criacao')
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        notificacoes = notificacoes.filter(tipo=tipo)
    
    lida = request.GET.get('lida')
    if lida is not None:
        notificacoes = notificacoes.filter(lida=lida == 'true')
    
    # PaginaÃ§Ã£o
    paginator = Paginator(notificacoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'notificacoes': page_obj,
        'tipos': NotificacaoSessao.TIPO_CHOICES,
        'filtros': {
            'tipo': tipo,
            'lida': lida,
        }
    }
    
    return render(request, 'militares/notificacoes/list.html', context)


@login_required
def notificacao_marcar_lida(request, pk):
    """Marca uma notificaÃ§Ã£o como lida"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.marcar_como_lida()
        messages.success(request, 'NotificaÃ§Ã£o marcada como lida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'NotificaÃ§Ã£o nÃ£o encontrada.')
    
    return redirect('militares:notificacoes_list')


@login_required
def notificacao_marcar_todas_lidas(request):
    """Marca todas as notificaÃ§Ãµes do usuÃ¡rio como lidas"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    )
    
    count = notificacoes.count()
    notificacoes.update(lida=True, data_leitura=timezone.now())
    
    messages.success(request, f'{count} notificaÃ§Ã£o(Ãµes) marcada(s) como lida(s).')
    return redirect('militares:notificacoes_list')


@login_required
def notificacao_delete(request, pk):
    """Remove uma notificaÃ§Ã£o"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.delete()
        messages.success(request, 'NotificaÃ§Ã£o removida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'NotificaÃ§Ã£o nÃ£o encontrada.')
    
    return redirect('militares:notificacoes_list')

# Views para gerenciar cargos da comissÃ£o
@login_required
def cargo_comissao_list(request):
    """Lista todos os cargos da comissÃ£o"""
    cargos = CargoComissao.objects.all()
    
    context = {
        'cargos': cargos,
        'title': 'Cargos da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/list.html', context)


@login_required
def cargo_comissao_create(request):
    """Cria um novo cargo"""
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo criado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm()
    
    context = {
        'form': form,
        'title': 'Novo Cargo da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)


@login_required
def cargo_comissao_update(request, pk):
    """Edita um cargo existente"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo nÃ£o encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST, instance=cargo)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo atualizado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm(instance=cargo)
    
    context = {
        'form': form,
        'cargo': cargo,
        'title': 'Editar Cargo da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)


@login_required
def cargo_comissao_delete(request, pk):
    """Exclui um cargo"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo nÃ£o encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    # Buscar membros vinculados ao cargo
    membros_vinculados = cargo.membrocomissao_set.all()
    erro_protegido = False
    
    if request.method == 'POST':
        try:
            cargo.delete()
            messages.success(request, 'Cargo excluÃ­do com sucesso!')
            return redirect('militares:cargo_comissao_list')
        except ProtectedError:
            erro_protegido = True
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir este cargo porque ele estÃ¡ vinculado a um ou mais membros da comissÃ£o. Troque o cargo desses membros antes de excluir.')
    
    context = {
        'cargo': cargo,
        'title': 'Excluir Cargo da ComissÃ£o',
        'membros_vinculados': membros_vinculados,
        'erro_protegido': erro_protegido,
    }
    return render(request, 'militares/comissao/cargos/delete.html', context)


# =============================================================================
# MÃ“DULO DE QUADROS DE FIXAÃ‡ÃƒO DE VAGAS
# =============================================================================

@login_required
def quadro_fixacao_vagas_list(request):
    """Lista todos os quadros de fixaÃ§Ã£o de vagas de oficiais"""
    quadros = QuadroFixacaoVagas.objects.all().order_by('-data_criacao')
    
    # Filtros
    data_inicio = request.GET.get('data_inicio')
    if data_inicio:
        try:
            data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__gte=data_inicio)
        except ValueError:
            pass
    
    data_fim = request.GET.get('data_fim')
    if data_fim:
        try:
            data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__lte=data_fim)
        except ValueError:
            pass
    
    # PaginaÃ§Ã£o
    paginator = Paginator(quadros, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # EstatÃ­sticas
    total_quadros = quadros.count()
    
    context = {
        'quadros': page_obj,
        'total_quadros': total_quadros,
        'filtros': {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
        }
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/list.html', context)


@login_required
def quadro_fixacao_vagas_create(request):
    """Cria um novo quadro de fixaÃ§Ã£o de vagas"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O tÃ­tulo do quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not tipo:
            messages.error(request, 'O tipo de quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_create')
        
        # Verificar se jÃ¡ existe um quadro para esta data
        # Removida a validaÃ§Ã£o que impedia mÃºltiplos quadros para a mesma data
        # (permitir mÃºltiplos quadros de fixaÃ§Ã£o de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo=tipo,
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Capturar previsÃµes de vagas baseado no tipo
            if tipo == 'OFICIAIS':
                # Buscar previsÃµes para oficiais (quadros COMB, SAUDE, ENG, COMP)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP'],
                    posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
                ).order_by('quadro', 'posto')
            else:  # PRACAS
                # Buscar previsÃµes para praÃ§as (quadro PRACAS)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro='PRACAS',
                    posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
                ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsÃµes
            for previsao in previsoes:
                # Capturar observaÃ§Ã£o especÃ­fica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual Ã s vagas disponÃ­veis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar previsÃµes de vagas para mostrar no preview
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    previsoes_pracas = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro='PRACAS',
        posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
    )
    
    # Agrupar previsÃµes por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    vagas_por_quadro_pracas = {}
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_por_quadro_pracas:
            vagas_por_quadro_pracas[previsao.quadro] = []
        vagas_por_quadro_pracas[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_pracas:
        vagas_por_quadro_pracas[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'tipos': QuadroFixacaoVagas.TIPO_CHOICES,
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'vagas_por_quadro_pracas': vagas_por_quadro_pracas,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/create.html', context)


@login_required
def quadro_fixacao_vagas_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }

    return render(request, 'militares/quadro_fixacao_vagas/detail.html', context)


@login_required
def quadro_fixacao_vagas_update(request, pk):
    """Atualiza um quadro de fixaÃ§Ã£o de vagas (geral)"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        # Atualizar dados bÃ¡sicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')

        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_update', pk=pk)
        quadro.observacoes = observacoes
        quadro.save()

        # Atualizar vagas fixadas e observaÃ§Ãµes dos itens
        for key, value in request.POST.items():
            if key.startswith('vagas_fixadas_'):
                item_id = key.replace('vagas_fixadas_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    vagas_fixadas = int(value) if value else 0
                    item.vagas_fixadas = vagas_fixadas
                    # Buscar observaÃ§Ãµes correspondentes
                    obs_key = f'observacoes_{item_id}'
                    observacoes_item = request.POST.get(obs_key, '')
                    item.observacoes = observacoes_item
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas atualizado com sucesso!')
        return redirect('militares:quadro_fixacao_vagas_detail', pk=quadro.pk)

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    return render(request, 'militares/quadro_fixacao_vagas/update.html', context)


@login_required
def quadro_fixacao_vagas_pdf_view(request, pk):
    """Visualiza o PDF do quadro de fixaÃ§Ã£o de vagas em nova aba"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/pdf_view.html', context)


@login_required
def quadro_fixacao_vagas_oficiais_create(request):
    """Cria um novo quadro de fixaÃ§Ã£o de vagas para oficiais"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O tÃ­tulo do quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        # Verificar se jÃ¡ existe um quadro para esta data
        quadro_existente = QuadroFixacaoVagas.objects.filter(
            data_promocao=data_promocao,
            tipo='OFICIAIS'
        ).first()
        
        # Removida a validaÃ§Ã£o que impedia mÃºltiplos quadros para a mesma data
        # (permitir mÃºltiplos quadros de fixaÃ§Ã£o de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo='OFICIAIS',
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Buscar previsÃµes para oficiais (quadros COMB, SAUDE, ENG, COMP)
            previsoes = PrevisaoVaga.objects.filter(
                ativo=True,
                quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP'],
                posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
            ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsÃµes
            for previsao in previsoes:
                # Capturar observaÃ§Ã£o especÃ­fica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual Ã s vagas disponÃ­veis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas para Oficiais criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas para Oficiais criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_oficiais_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
    }
    
    # Buscar previsÃµes de vagas para oficiais
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    # Calcular efetivo atual em tempo real para cada previsÃ£o
    for previsao in previsoes_oficiais:
        if previsao.quadro == 'COMP':
            # Para COMP, incluir ST (Subtenentes) que sÃ£o cadastrados como COMP mas contam para praÃ§as
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro='COMP',
                situacao='AT'
            ).count()
        else:
            # Para outros quadros, usar o quadro especÃ­fico
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'
            ).count()
        
        # Atualizar o efetivo atual da previsÃ£o (apenas para exibiÃ§Ã£o)
        previsao.efetivo_atual = efetivo_atual
    
    # Agrupar previsÃµes por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_create.html', context)


@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # EstatÃ­sticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)


@login_required
def assinar_quadro_fixacao_vagas(request, pk):
    """Assinar quadro de fixaÃ§Ã£o de vagas com confirmaÃ§Ã£o de senha"""
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    
    # Verificar permissÃ£o de assinatura
    if quadro.tipo == 'OFICIAIS':
        # Para quadros de oficiais, verificar se Ã© membro da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.pode_assinar_documento_oficial(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de oficiais. Apenas membros da CPO podem assinar.')
            return redirect('militares:quadro_fixacao_vagas_detail', pk=pk)
    else:
        # Para quadros de praÃ§as, verificar se Ã© membro da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.pode_assinar_documento_praca(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar documentos de praÃ§as. Apenas membros da CPP podem assinar.')
            return redirect('militares:quadro_fixacao_vagas_detail', pk=pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Verificar se jÃ¡ existe uma assinatura deste usuÃ¡rio para este tipo
        assinatura_existente = AssinaturaQuadroFixacaoVagas.objects.filter(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'VocÃª jÃ¡ assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroFixacaoVagas.objects.create(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura
        )
        
        # Se a assinatura for de aprovaÃ§Ã£o, mudar o status do quadro para APROVADO
        if tipo_assinatura == 'APROVACAO':
            quadro.status = 'APROVADO'
            quadro.save()
        
        messages.success(request, f'Quadro de fixaÃ§Ã£o de vagas assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_fixacao_vagas_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)


@login_required
def quadro_fixacao_vagas_delete(request, pk):
    """Exclui um quadro de fixaÃ§Ã£o de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        try:
            quadro.delete()
            messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas excluÃ­do com sucesso!')
            return redirect('militares:quadro_fixacao_vagas_list')
        except Exception as e:
            messages.error(request, f'Erro ao excluir quadro: {str(e)}')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/delete.html', context)


@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # EstatÃ­sticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)


@login_required
def quadro_fixacao_vagas_oficiais_update(request, pk):
    """Atualiza um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        # Atualizar dados bÃ¡sicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_update', pk=pk)
        
        quadro.observacoes = observacoes
        quadro.save()
        
        # Atualizar vagas fixadas
        for key, value in request.POST.items():
            if key.startswith('vagas_fixadas_'):
                item_id = key.replace('vagas_fixadas_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    vagas_fixadas = int(value) if value else 0
                    item.vagas_fixadas = vagas_fixadas
                    
                    # Buscar observaÃ§Ãµes correspondentes
                    obs_key = f'observacoes_{item_id}'
                    observacoes_item = request.POST.get(obs_key, '')
                    item.observacoes = observacoes_item
                    
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        
        messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas atualizado com sucesso!')
        return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=quadro.pk)
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_update.html', context)


def gerar_codigo_verificacao(texto_documento):
    """
    Gera um cÃ³digo de verificaÃ§Ã£o baseado no hash SHA-256 do texto do documento.
    Retorna os primeiros 10 caracteres do hash hexadecimal.
    """
    return hashlib.sha256(texto_documento.encode('utf-8')).hexdigest()[:10]


@login_required
def proxima_numeracao_disponivel(request):
    """Retorna a prÃ³xima numeraÃ§Ã£o disponÃ­vel para um posto/quadro especÃ­fico"""
    
    if request.method == 'GET':
        posto = request.GET.get('posto')
        quadro = request.GET.get('quadro')
        
        if not posto or not quadro:
            return JsonResponse({'erro': 'Posto e quadro sÃ£o obrigatÃ³rios'}, status=400)
        
        # Buscar todas as numeraÃ§Ãµes existentes para o posto/quadro
        numeracoes_existentes = list(Militar.objects.filter(
            situacao='AT',
            posto_graduacao=posto,
            quadro=quadro,
            numeracao_antiguidade__isnull=False
        ).values_list('numeracao_antiguidade', flat=True).order_by('numeracao_antiguidade'))
        
        # Encontrar o primeiro nÃºmero disponÃ­vel (nÃ£o necessariamente o maior + 1)
        proxima_numeracao = 1
        for num in numeracoes_existentes:
            if proxima_numeracao < num:
                # Encontrou um gap, usar este nÃºmero
                break
            proxima_numeracao = num + 1
        
        return JsonResponse({
            'proxima_numeracao': proxima_numeracao,
            'posto': posto,
            'quadro': quadro,
            'numeracoes_existentes': numeracoes_existentes
        })
    
    return JsonResponse({'erro': 'MÃ©todo nÃ£o permitido'}, status=405)


def reordenar_numeracoes_militares(posto):
    """
    Reordena as numeraÃ§Ãµes de antiguidade para um posto especÃ­fico,
    corrigindo apenas repetiÃ§Ãµes e gaps, mantendo a ordem atual dos demais.
    """
    # Buscar todos os militares ativos do posto, mantendo a ordem atual
    militares = Militar.objects.filter(
        situacao='AT',
        posto_graduacao=posto
    ).order_by('numeracao_antiguidade', 'id')

    if not militares:
        return 0

    # Detectar problemas (repetiÃ§Ãµes e gaps)
    seen = set()
    start_reorder_index = None
    expected_num = 1
    
    for idx, militar in enumerate(militares):
        current_num = militar.numeracao_antiguidade
        
        # Verificar se hÃ¡ repetiÃ§Ã£o
        if current_num in seen:
            start_reorder_index = idx
            break
        
        # Verificar se hÃ¡ gap (nÃºmero faltando)
        if current_num != expected_num:
            start_reorder_index = idx
            break
            
        seen.add(current_num)
        expected_num += 1

    # Se nÃ£o houver problemas (repetiÃ§Ã£o ou gap), nÃ£o faz nada
    if start_reorder_index is None:
        return 0

    # A partir do primeiro problema, reordena sequencialmente
    # Manter a ordem atual dos militares, apenas corrigindo a numeraÃ§Ã£o
    nova_numeracao = militares[start_reorder_index-1].numeracao_antiguidade + 1 if start_reorder_index > 0 else 1
    militares_para_atualizar = []
    
    for militar in militares[start_reorder_index:]:
        if militar.numeracao_antiguidade != nova_numeracao:
            militar.numeracao_antiguidade = nova_numeracao
            militares_para_atualizar.append(militar)
        nova_numeracao += 1

    if militares_para_atualizar:
        Militar.objects.bulk_update(militares_para_atualizar, ['numeracao_antiguidade'])

    return len(militares_para_atualizar)


@login_required
def reordenar_numeracoes_view(request):
    """View para reordenar numeraÃ§Ãµes de antiguidade por posto, baseado na data de promoÃ§Ã£o"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        
        # Exigir que o posto seja fornecido
        if not posto:
            messages.error(request, 'O posto Ã© obrigatÃ³rio para reordenar numeraÃ§Ãµes')
            return redirect('militares:militar_list')
        
        try:
            # Executar reordenaÃ§Ã£o baseada apenas no posto e data de promoÃ§Ã£o
            total_atualizados = reordenar_numeracoes_militares(posto)
            
            # Contar total de militares do posto
            total_militares = Militar.objects.filter(
                situacao='AT',
                posto_graduacao=posto
            ).count()
            
            posto_display = dict(POSTO_GRADUACAO_CHOICES).get(posto, posto)
            
            if total_atualizados > 0:
                messages.success(
                    request, 
                    f'CorreÃ§Ãµes aplicadas com sucesso para o posto {posto_display}! '
                    f'{total_atualizados} militares foram corrigidos (repetiÃ§Ãµes e gaps removidos).'
                )
            else:
                messages.info(
                    request, 
                    f'Nenhuma correÃ§Ã£o necessÃ¡ria para o posto {posto_display}. '
                    f'As numeraÃ§Ãµes jÃ¡ estÃ£o corretas (sem repetiÃ§Ãµes ou gaps).'
                )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:militar_list')
    
    return redirect('militares:militar_list')


@login_required
def aplicar_promocao_view(request):
    """View para aplicar promoÃ§Ã£o e atribuir numeraÃ§Ã£o automaticamente"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        novo_posto = request.POST.get('novo_posto')
        novo_quadro = request.POST.get('novo_quadro')
        
        if not militar_id or not novo_posto or not novo_quadro:
            return JsonResponse({'erro': 'Dados incompletos para promoÃ§Ã£o'}, status=400)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = novo_posto
            militar.quadro = novo_quadro
            
            # Aplicar nova numeraÃ§Ã£o por promoÃ§Ã£o
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÃ“GICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2Âº Tenente
            if posto_anterior == 'ST' and novo_posto == '2T':
                from militares.models import FichaConceitoPracas, FichaConceitoOficiais
                
                # Verificar se existe ficha de praÃ§as
                ficha_pracas = militar.fichaconceitopracas_set.first()
                if ficha_pracas:
                    # Criar nova ficha de oficiais com os dados da ficha de praÃ§as
                    ficha_oficiais = FichaConceitoOficiais.objects.create(
                        militar=militar,
                        tempo_posto=ficha_pracas.tempo_posto,
                        cursos_especializacao=ficha_pracas.cursos_especializacao,
                        cursos_cfsd=ficha_pracas.cursos_cfsd,
                        cursos_chc=ficha_pracas.cursos_chc,
                        cursos_chsgt=ficha_pracas.cursos_chsgt,
                        cursos_cas=ficha_pracas.cursos_cas,
                        cursos_cho=ficha_pracas.cursos_cho,
                        cursos_civis_superior=ficha_pracas.cursos_civis_superior,
                        cursos_civis_especializacao=ficha_pracas.cursos_civis_especializacao,
                        cursos_civis_mestrado=ficha_pracas.cursos_civis_mestrado,
                        cursos_civis_doutorado=ficha_pracas.cursos_civis_doutorado,
                        medalha_federal=ficha_pracas.medalha_federal,
                        medalha_estadual=ficha_pracas.medalha_estadual,
                        medalha_cbmepi=ficha_pracas.medalha_cbmepi,
                        elogio_individual=ficha_pracas.elogio_individual,
                        elogio_coletivo=ficha_pracas.elogio_coletivo,
                        punicao_repreensao=ficha_pracas.punicao_repreensao,
                        punicao_detencao=ficha_pracas.punicao_detencao,
                        punicao_prisao=ficha_pracas.punicao_prisao,
                        falta_aproveitamento=ficha_pracas.falta_aproveitamento,
                        observacoes=f"Ficha convertida automaticamente da promoÃ§Ã£o de Subtenente para 2Âº Tenente. Original: {ficha_pracas.id}"
                    )
                    
                    # Remover a ficha de praÃ§as antiga
                    ficha_pracas.delete()
                    
                    # Atualizar a mensagem para incluir informaÃ§Ã£o sobre a conversÃ£o
                    mensagem_adicional = " Ficha de conceito convertida de praÃ§as para oficiais."
                else:
                    mensagem_adicional = ""
            else:
                mensagem_adicional = ""
            
            # Salvar as alteraÃ§Ãµes
            militar.save()
            
            return JsonResponse({
                'sucesso': True,
                'nova_numeracao': nova_numeracao,
                'mensagem': f'PromoÃ§Ã£o aplicada com sucesso! Nova numeraÃ§Ã£o: {nova_numeracao}Âº. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            })
            
        except Militar.DoesNotExist:
            return JsonResponse({'erro': 'Militar nÃ£o encontrado'}, status=404)
        except Exception as e:
            return JsonResponse({'erro': f'Erro ao aplicar promoÃ§Ã£o: {str(e)}'}, status=500)
    
    return JsonResponse({'erro': 'MÃ©todo nÃ£o permitido'}, status=405)


@login_required
def militar_inativo_list(request):
    """Lista militares inativos (transferidos, aposentados, exonerados)"""
    
    # Filtrar apenas militares inativos
    militares = Militar.objects.filter(
        situacao__in=['IN', 'TR', 'AP', 'EX']
    ).order_by('posto_graduacao', 'nome_completo')
    
    # Filtros
    situacao = request.GET.get('situacao')
    if situacao:
        militares = militares.filter(situacao=situacao)
    
    posto = request.GET.get('posto')
    if posto:
        militares = militares.filter(posto_graduacao=posto)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Busca por nome
    busca = request.GET.get('busca')
    if busca:
        militares = militares.filter(
            models.Q(nome_completo__icontains=busca) |
            models.Q(nome_guerra__icontains=busca) |
            models.Q(matricula__icontains=busca)
        )
    
    # EstatÃ­sticas
    total_inativos = militares.count()
    por_situacao = militares.values('situacao').annotate(
        count=models.Count('id')
    ).order_by('situacao')
    
    # PaginaÃ§Ã£o
    paginator = Paginator(militares, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'militares': page_obj,
        'situacoes': SITUACAO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
        'filtros': {
            'situacao': situacao,
            'posto': posto,
            'quadro': quadro,
            'busca': busca
        },
        'estatisticas': {
            'total': total_inativos,
            'por_situacao': por_situacao
        }
    }
    
    return render(request, 'militares/militar_inativo_list.html', context)


@login_required
def militar_inativo_detail(request, pk):
    """Detalhes de um militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Verificar se Ã© realmente inativo
    if militar.situacao not in ['IN', 'TR', 'AP', 'EX']:
        messages.warning(request, 'Este militar nÃ£o estÃ¡ inativo.')
        return redirect('militares:militar_detail', pk=pk)
    
    # Buscar histÃ³rico de promoÃ§Ãµes
    promocoes = Promocao.objects.filter(militar=militar).order_by('-data_promocao')
    
    # Buscar fichas de conceito
    fichas_conceito = []
    try:
        ficha_oficiais = FichaConceitoOficiais.objects.get(militar=militar)
        fichas_conceito.append(ficha_oficiais)
    except FichaConceitoOficiais.DoesNotExist:
        pass
    
    try:
        ficha_pracas = FichaConceitoPracas.objects.get(militar=militar)
        fichas_conceito.append(ficha_pracas)
    except FichaConceitoPracas.DoesNotExist:
        pass
    
    # Buscar documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'promocoes': promocoes,
        'fichas_conceito': fichas_conceito,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_inativo_detail.html', context)


@login_required
def militar_transferir_inativo(request, pk):
    """Transferir militar para situaÃ§Ã£o inativa"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nova_situacao = request.POST.get('nova_situacao')
        data_transferencia = request.POST.get('data_transferencia')
        motivo = request.POST.get('motivo')
        
        if nova_situacao and data_transferencia:
            try:
                # Validar data
                from datetime import datetime
                data_transferencia = datetime.strptime(data_transferencia, '%Y-%m-%d').date()
                
                # Atualizar situaÃ§Ã£o do militar
                situacao_anterior = militar.situacao
                militar.situacao = nova_situacao
                militar.observacoes = f"{militar.observacoes or ''}\n\nTransferido para {militar.get_situacao_display()} em {data_transferencia.strftime('%d/%m/%Y')}. Motivo: {motivo}"
                militar.save()
                
                messages.success(request, f'Militar {militar.nome_completo} transferido para {militar.get_situacao_display()} com sucesso!')
                return redirect('militares:militar_inativo_detail', pk=militar.pk)
                
            except ValueError:
                messages.error(request, 'Data invÃ¡lida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Todos os campos sÃ£o obrigatÃ³rios.')
    
    context = {
        'militar': militar,
        'situacoes_inativas': [
            ('IN', 'Inativo'),
            ('TR', 'Transferido'),
            ('AP', 'Aposentado'),
            ('EX', 'Exonerado'),
        ]
    }
    
    return render(request, 'militares/militar_transferir_inativo.html', context)


@login_required
def militar_reativar(request, pk):
    """Reativar militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        
        if motivo:
            # Reativar militar
            militar.situacao = 'AT'
            militar.observacoes = f"{militar.observacoes or ''}\n\nReativado em {timezone.now().strftime('%d/%m/%Y %H:%M')}. Motivo: {motivo}"
            militar.save()
            
            messages.success(request, f'Militar {militar.nome_completo} reativado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Motivo Ã© obrigatÃ³rio.')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_reativar.html', context)


@login_required
def subtenentes_por_cho(request):
    """Lista Subtenentes separados por CHO (com e sem CHO)"""
    # Buscar todos os Subtenentes ativos
    subtenentes = Militar.objects.filter(
        posto_graduacao='ST',
        situacao='AT'
    ).order_by('quadro', '-curso_cho', 'numeracao_antiguidade', 'nome_completo')
    
    # Separar por quadro e CHO
    subtenentes_por_quadro = {}
    
    for militar in subtenentes:
        quadro = militar.quadro
        if quadro not in subtenentes_por_quadro:
            subtenentes_por_quadro[quadro] = {
                'com_cho': [],
                'sem_cho': []
            }
        
        if militar.curso_cho:
            subtenentes_por_quadro[quadro]['com_cho'].append(militar)
        else:
            subtenentes_por_quadro[quadro]['sem_cho'].append(militar)
    
    # Ordenar cada grupo por numeracao_antiguidade
    for quadro in subtenentes_por_quadro:
        subtenentes_por_quadro[quadro]['com_cho'].sort(key=lambda m: m.numeracao_antiguidade or 99999)
        subtenentes_por_quadro[quadro]['sem_cho'].sort(key=lambda m: m.numeracao_antiguidade or 99999)
    
    # EstatÃ­sticas
    total_subtenentes = subtenentes.count()
    total_com_cho = sum(len(quadro_data['com_cho']) for quadro_data in subtenentes_por_quadro.values())
    total_sem_cho = sum(len(quadro_data['sem_cho']) for quadro_data in subtenentes_por_quadro.values())
    
    context = {
        'subtenentes_por_quadro': subtenentes_por_quadro,
        'total_subtenentes': total_subtenentes,
        'total_com_cho': total_com_cho,
        'total_sem_cho': total_sem_cho,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/subtenentes_por_cho.html', context)


    class Meta:
        model = User
        fields = [
            'username', 'first_name', 'last_name', 'email',
            'is_active', 'is_staff', 'is_superuser', 'groups'
        ]
        widgets = {
            'username': forms.TextInput(attrs={'class': 'form-control'}),
            'first_name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'ğŸ” Digite o nome do militar para buscar e preencher automaticamente...',
                'autocomplete': 'off'
            }),
            'last_name': forms.TextInput(attrs={'class': 'form-control'}),
            'email': forms.EmailInput(attrs={'class': 'form-control'}),
            'groups': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }
    
    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        
        # Se Ã© uma criaÃ§Ã£o de usuÃ¡rio (nÃ£o tem instance.pk), senha Ã© obrigatÃ³ria
        if not self.instance.pk:
            if not password:
                raise forms.ValidationError('Senha Ã© obrigatÃ³ria para novos usuÃ¡rios.')
            if not confirm_password:
                raise forms.ValidationError('ConfirmaÃ§Ã£o de senha Ã© obrigatÃ³ria para novos usuÃ¡rios.')
        
        if password and confirm_password and password != confirm_password:
            raise forms.ValidationError('As senhas nÃ£o coincidem.')
        
        return cleaned_data


@login_required
@permission_required('auth.add_user')
def usuario_create(request):
    """Criar novo usuÃ¡rio"""
    if request.method == 'POST':
        form = UsuarioForm(request.POST)
        if form.is_valid():
            usuario = form.save(commit=False)
            password = form.cleaned_data.get('password')
            if password:
                usuario.set_password(password)
            usuario.save()
            form.save_m2m()  # Salvar grupos
            
            # Associar militar se fornecido
            militar_id = form.cleaned_data.get('militar_id')
            if militar_id:
                try:
                    militar = Militar.objects.get(id=militar_id)
                    # Vincular militar ao usuÃ¡rio
                    militar.user = usuario
                    militar.save()
                    messages.success(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso e vinculado ao militar "{militar.nome_completo}"!')
                except Militar.DoesNotExist:
                    messages.warning(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso, mas militar nÃ£o encontrado.')
            else:
                messages.success(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso!')
            
            return redirect('militares:usuarios_custom_list')
    else:
        form = UsuarioForm()
    
    context = {
        'form': form,
        'title': 'Criar Novo UsuÃ¡rio',
        'submit_text': 'Criar UsuÃ¡rio'
    }
    
    return render(request, 'militares/usuarios/form.html', context)


class GrupoForm(forms.ModelForm):
    """FormulÃ¡rio para criaÃ§Ã£o/ediÃ§Ã£o de grupos"""
    
    class Meta:
        model = Group
        fields = ['name', 'permissions']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'permissions': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }


@login_required
@permission_required('auth.view_user')
def dashboard_permissoes(request):
    """Dashboard com estatÃ­sticas do sistema de permissÃµes"""
    
    # EstatÃ­sticas bÃ¡sicas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    total_grupos = Group.objects.count()
    grupos_com_usuarios = Group.objects.filter(user__isnull=False).distinct().count()
    total_permissoes = Permission.objects.count()
    permissoes_utilizadas = Permission.objects.filter(group__isnull=False).distinct().count()
    
    # AplicaÃ§Ãµes e modelos
    content_types = ContentType.objects.all()
    total_apps = content_types.values('app_label').distinct().count()
    modelos_por_app = content_types.count()
    
    # EstatÃ­sticas por grupo
    grupos_estatisticas = {}
    grupos_nomes = {
        'admin': 'Administrador - Acesso total',
        'superusuario': 'Super UsuÃ¡rio - Acesso total',
        'membro_cpo': 'Membro CPO - Acesso a oficiais e comissÃµes',
        'membro_cpp': 'Membro CPP - Acesso a praÃ§as e comissÃµes',
        'comandante_geral': 'Comandante Geral - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'subcomandante_geral': 'Subcomandante Geral - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'diretor_gestao_pessoas': 'Diretor de GestÃ£o de Pessoas - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'chefe_secao_promocoes': 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'digitador': 'Digitador - Acesso total sem exclusÃ£o e sem usuÃ¡rios/administraÃ§Ã£o',
        'usuario': 'UsuÃ¡rio - Acesso a documentos especÃ­ficos e visualizaÃ§Ã£o'
    }
    
    for codigo, nome in grupos_nomes.items():
        try:
            grupo = Group.objects.get(name=nome)
            usuarios_count = grupo.user_set.count()
            permissoes_count = grupo.permissions.count()
            grupos_estatisticas[codigo] = {
                'usuarios': usuarios_count,
                'permissoes': permissoes_count
            }
        except Group.DoesNotExist:
            grupos_estatisticas[codigo] = {
                'usuarios': 0,
                'permissoes': 0
            }
    
    # Atividades recentes (simuladas)
    recent_activities = [
        {
            'icon': 'shield-alt',
            'title': 'Sistema de permissÃµes simplificado',
            'description': 'ConfiguraÃ§Ã£o de permissÃµes por nÃ­veis de acesso concluÃ­da',
            'time': '5 minutos atrÃ¡s'
        },
        {
            'icon': 'users-cog',
            'title': 'Grupos criados',
            'description': '10 grupos de permissÃµes foram configurados',
            'time': '10 minutos atrÃ¡s'
        },
        {
            'icon': 'key',
            'title': 'PermissÃµes atribuÃ­das',
            'description': 'Sistema de permissÃµes organizado por nÃ­veis',
            'time': '15 minutos atrÃ¡s'
        }
    ]
    
    context = {
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'total_grupos': total_grupos,
        'grupos_com_usuarios': grupos_com_usuarios,
        'total_permissoes': total_permissoes,
        'permissoes_utilizadas': permissoes_utilizadas,
        'total_apps': total_apps,
        'modelos_por_app': modelos_por_app,
        'recent_activities': recent_activities,
        # EstatÃ­sticas por grupo
        'admin_users': grupos_estatisticas.get('admin', {}).get('usuarios', 0),
        'admin_permissions': grupos_estatisticas.get('admin', {}).get('permissoes', 88),
        'super_users': grupos_estatisticas.get('superusuario', {}).get('usuarios', 0),
        'super_permissions': grupos_estatisticas.get('superusuario', {}).get('permissoes', 88),
        'cpo_users': grupos_estatisticas.get('membro_cpo', {}).get('usuarios', 0),
        'cpo_permissions': grupos_estatisticas.get('membro_cpo', {}).get('permissoes', 44),
        'cpp_users': grupos_estatisticas.get('membro_cpp', {}).get('usuarios', 0),
        'cpp_permissions': grupos_estatisticas.get('membro_cpp', {}).get('permissoes', 44),
        'comandante_users': grupos_estatisticas.get('comandante_geral', {}).get('usuarios', 0),
        'comandante_permissions': grupos_estatisticas.get('comandante_geral', {}).get('permissoes', 76),
        'subcomandante_users': grupos_estatisticas.get('subcomandante_geral', {}).get('usuarios', 0),
        'subcomandante_permissions': grupos_estatisticas.get('subcomandante_geral', {}).get('permissoes', 76),
        'diretor_users': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('usuarios', 0),
        'diretor_permissions': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('permissoes', 76),
        'chefe_users': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('usuarios', 0),
        'chefe_permissions': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('permissoes', 76),
        'digitador_users': grupos_estatisticas.get('digitador', {}).get('usuarios', 0),
        'digitador_permissions': grupos_estatisticas.get('digitador', {}).get('permissoes', 57),
        'usuario_users': grupos_estatisticas.get('usuario', {}).get('usuarios', 0),
        'usuario_permissions': grupos_estatisticas.get('usuario', {}).get('permissoes', 2),
    }
    
    return render(request, 'militares/usuarios/dashboard.html', context)


@login_required
def meus_votos_list(request):
    """Lista todos os votos do usuÃ¡rio logado"""
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o
    membros_usuario = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True
    )
    
    if not membros_usuario.exists():
        messages.warning(request, 'VocÃª nÃ£o Ã© membro de nenhuma comissÃ£o ativa.')
        return redirect('militares:comissao_list')
    
    # Buscar todos os votos do usuÃ¡rio
    votos = VotoDeliberacao.objects.filter(
        membro__usuario=request.user,
        membro__ativo=True
    ).select_related(
        'deliberacao__sessao__comissao',
        'membro__militar'
    ).order_by('-data_registro')
    
    # Calcular estatÃ­sticas
    total_votos = votos.count()
    votos_favor = votos.filter(voto='FAVOR').count()
    votos_contra = votos.filter(voto='CONTRA').count()
    votos_abstencao = votos.filter(voto='ABSTENCAO').count()
    
    context = {
        'votos': votos,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
        'title': 'Meus Votos',
    }
    return render(request, 'militares/comissao/deliberacoes/meus_votos_list.html', context)


@login_required
def meu_voto_detail(request, pk):
    """Visualizar detalhes de um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este voto.')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_detail.html', context)


@login_required
def meu_voto_update(request, pk):
    """Editar um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessÃ£o ainda estÃ¡ aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'NÃ£o Ã© possÃ­vel editar votos de sessÃµes finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Obter dados do voto
        novo_voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        
        if not novo_voto:
            messages.error(request, 'VocÃª deve escolher uma opÃ§Ã£o de voto.')
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        # Atualizar voto
        voto.voto = novo_voto
        voto.voto_proferido = voto_proferido
        voto.save()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = voto.deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = voto.deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = voto.deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        voto.deliberacao.votos_favor = votos_favor
        voto.deliberacao.votos_contra = votos_contra
        voto.deliberacao.votos_abstencao = votos_abstencao
        voto.deliberacao.save()
        
        messages.success(request, f'âœ… Voto atualizado com sucesso!')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    # Criar formulÃ¡rio para o voto proferido
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto.voto_proferido
    })
    
    context = {
        'voto': voto,
        'form': form,
        'title': f'Editar Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)


@login_required
def meu_voto_delete(request, pk):
    """Excluir um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessÃ£o ainda estÃ¡ aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'NÃ£o Ã© possÃ­vel excluir votos de sessÃµes finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Salvar referÃªncias antes de excluir
        deliberacao = voto.deliberacao
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, 'âœ… Voto excluÃ­do com sucesso!')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Excluir Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_confirm_delete.html', context)


@login_required
def status_efetivo_vagas(request):
    """Mostra o status do efetivo atual e permite atualizaÃ§Ã£o manual das vagas"""
    from .signals import atualizar_todas_vagas_efetivo
    
    # Contar militares por posto e quadro
    efetivo_por_posto_quadro = {}
    militares_ativos = Militar.objects.filter(situacao='AT')
    
    for militar in militares_ativos:
        key = f"{militar.get_posto_graduacao_display()} - {militar.get_quadro_display()}"
        if key not in efetivo_por_posto_quadro:
            efetivo_por_posto_quadro[key] = {
                'posto': militar.posto_graduacao,
                'quadro': militar.quadro,
                'efetivo_atual': 0,
                'militares': []
            }
        efetivo_por_posto_quadro[key]['efetivo_atual'] += 1
        efetivo_por_posto_quadro[key]['militares'].append(militar)
    
    # Buscar vagas existentes
    vagas = Vaga.objects.all().order_by('posto', 'quadro')
    vagas_dict = {}
    for vaga in vagas:
        key = f"{vaga.get_posto_display()} - {vaga.get_quadro_display()}"
        vagas_dict[key] = vaga
    
    # Buscar previsÃµes existentes
    previsoes = PrevisaoVaga.objects.filter(ativo=True).order_by('posto', 'quadro')
    previsoes_dict = {}
    for previsao in previsoes:
        key = f"{previsao.get_posto_display()} - {previsao.get_quadro_display()}"
        previsoes_dict[key] = previsao
    
    # Processar atualizaÃ§Ã£o se solicitado
    if request.method == 'POST' and 'atualizar_efetivo' in request.POST:
        try:
            resultado = atualizar_todas_vagas_efetivo()
            messages.success(
                request, 
                f"Efetivo atualizado com sucesso! "
                f"Militares processados: {resultado['militares_processados']}, "
                f"Vagas criadas: {resultado['vagas_criadas']}, "
                f"Vagas atualizadas: {resultado['vagas_atualizadas']}, "
                f"PrevisÃµes atualizadas: {resultado['previsoes_atualizadas']}"
            )
            return redirect('militares:status_efetivo_vagas')
        except Exception as e:
            messages.error(request, f"Erro ao atualizar efetivo: {str(e)}")
    
    context = {
        'efetivo_por_posto_quadro': efetivo_por_posto_quadro,
        'vagas_dict': vagas_dict,
        'previsoes_dict': previsoes_dict,
        'total_militares_ativos': militares_ativos.count(),
        'total_vagas': vagas.count(),
        'total_previsoes': previsoes.count(),
    }
    
    return render(request, 'militares/status_efetivo_vagas.html', context)


@login_required
def reordenar_antiguidade_apos_inativacao(request):
    """View para reordenar numeraÃ§Ãµes de antiguidade apÃ³s inativaÃ§Ãµes"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        
        try:
            # Executar reordenaÃ§Ã£o
            total_reordenados = Militar.reordenar_todos_apos_inativacao(
                posto_graduacao=posto if posto else None,
                quadro=quadro if quadro else None
            )
            
            messages.success(
                request, 
                f'ReordenaÃ§Ã£o concluÃ­da com sucesso! {total_reordenados} militares foram reordenados.'
            )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:status_efetivo_vagas')
    
    # GET - mostrar formulÃ¡rio
    context = {
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/reordenar_antiguidade_apos_inativacao.html', context)


@login_required
def promocao_subtenente_view(request):
    """View especÃ­fica para promoÃ§Ã£o de subtenentes do quadro praÃ§as para complementar"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        data_promocao = request.POST.get('data_promocao')
        
        if not militar_id or not data_promocao:
            messages.error(request, 'Militar e data de promoÃ§Ã£o sÃ£o obrigatÃ³rios.')
            return redirect('militares:militar_list')
        
        try:
            from datetime import datetime
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
            return redirect('militares:militar_list')
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se Ã© subtenente do quadro praÃ§as
            if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
                messages.error(request, 'Apenas subtenentes do quadro praÃ§as podem ser promovidos.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Verificar se estÃ¡ apto para promoÃ§Ã£o
            if not militar.apto_promocao_antiguidade():
                messages.error(request, 'Militar nÃ£o estÃ¡ apto para promoÃ§Ã£o. Verifique inspeÃ§Ã£o de saÃºde, interstÃ­cio e cursos obrigatÃ³rios.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = '2T'  # 2Âº Tenente
            militar.quadro = 'COMP'  # Complementar
            militar.data_promocao_atual = data_promocao
            
            # Aplicar nova numeraÃ§Ã£o por promoÃ§Ã£o
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÃ“GICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2Âº Tenente
            ficha_oficiais, mensagem_conversao = militar.converter_ficha_pracas_para_oficiais(
                motivo_conversao="PromoÃ§Ã£o de Subtenente para 2Âº Tenente"
            )
            
            if ficha_oficiais:
                mensagem_adicional = " Ficha de conceito convertida de praÃ§as para oficiais."
            else:
                mensagem_adicional = f" {mensagem_conversao}"
            
            # Salvar as alteraÃ§Ãµes
            militar.save()
            
            # Registrar a promoÃ§Ã£o no histÃ³rico
            from militares.models import Promocao
            Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo='2T',
                criterio='ANTIGUIDADE',
                data_promocao=data_promocao,
                data_publicacao=data_promocao,
                numero_ato='PromoÃ§Ã£o automÃ¡tica via sistema',
                observacoes=f'PromoÃ§Ã£o de Subtenente (PraÃ§as) para 2Âº Tenente (Complementar). Nova numeraÃ§Ã£o: {nova_numeracao}Âº.{mensagem_adicional}'
            )
            
            messages.success(
                request, 
                f'PromoÃ§Ã£o realizada com sucesso! {militar.nome_completo} foi promovido de Subtenente (PraÃ§as) para 2Âº Tenente (Complementar) com a {nova_numeracao}Âª numeraÃ§Ã£o de antiguidade. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            )
            
            return redirect('militares:militar_detail', pk=militar_id)
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
            return redirect('militares:militar_list')
        except Exception as e:
            messages.error(request, f'Erro ao realizar promoÃ§Ã£o: {str(e)}')
            return redirect('militares:militar_detail', pk=militar_id)
    
    # GET - mostrar formulÃ¡rio de promoÃ§Ã£o
    militar_id = request.GET.get('militar_id')
    if not militar_id:
        messages.error(request, 'ID do militar Ã© obrigatÃ³rio.')
        return redirect('militares:militar_list')
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se Ã© subtenente do quadro praÃ§as
        if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
            messages.error(request, 'Apenas subtenentes do quadro praÃ§as podem ser promovidos.')
            return redirect('militares:militar_detail', pk=militar_id)
        
        # Verificar se estÃ¡ apto para promoÃ§Ã£o
        apto_promocao = militar.apto_promocao_antiguidade()
        
        # Calcular prÃ³xima data de promoÃ§Ã£o
        from datetime import date
        hoje = date.today()
        proxima_data = date(hoje.year, 7, 18) if hoje < date(hoje.year, 7, 18) else date(hoje.year, 12, 25)
        
        context = {
            'militar': militar,
            'apto_promocao': apto_promocao,
            'proxima_data': proxima_data,
        }
        
        return render(request, 'militares/promocao_subtenente.html', context)
        
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
        return redirect('militares:militar_list')


@login_required
@administracao_required
def usuarios_custom_list(request):
    # ParÃ¢metros de filtro
    query = request.GET.get('q', '').strip()
    status = request.GET.get('status', '')
    grupo = request.GET.get('grupo', '')
    ordenacao = request.GET.get('ordenacao', 'nome')
    
    # Query base
    usuarios = User.objects.all().select_related('militar').prefetch_related('groups', 'funcoes')
    
    # Aplicar filtros
    if query:
        usuarios = usuarios.filter(
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query) |
            Q(email__icontains=query) |
            Q(militar__nome_completo__icontains=query)
        )
    
    if status == 'ativo':
        usuarios = usuarios.filter(is_active=True)
    elif status == 'inativo':
        usuarios = usuarios.filter(is_active=False)
    
    if grupo:
        usuarios = usuarios.filter(groups__name__icontains=grupo)
    
    # Aplicar ordenaÃ§Ã£o
    if ordenacao == 'nome':
        usuarios = usuarios.order_by('first_name', 'last_name')
    elif ordenacao == 'username':
        usuarios = usuarios.order_by('username')
    elif ordenacao == 'email':
        usuarios = usuarios.order_by('email')
    elif ordenacao == 'data_criacao':
        usuarios = usuarios.order_by('-date_joined')
    elif ordenacao == 'status':
        usuarios = usuarios.order_by('-is_active', 'first_name')
    else:
        usuarios = usuarios.order_by('first_name', 'last_name')
    
    # Buscar militar e funÃ§Ãµes/cargos
    usuarios_info = []
    for usuario in usuarios:
        militar = getattr(usuario, 'militar', None)
        funcoes_militar = []
        if militar:
            membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
            funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
        
        # FunÃ§Ãµes diretas do usuÃ¡rio
        funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
        
        usuarios_info.append({
            'usuario': usuario,
            'militar': militar,
            'funcoes_militar': funcoes_militar,
            'funcoes_usuario': funcoes_usuario,
        })
    
    # EstatÃ­sticas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    usuarios_inativos = User.objects.filter(is_active=False).count()
    
    # Grupos disponÃ­veis para filtro
    grupos_disponiveis = Group.objects.all().order_by('name')
    
    context = {
        'usuarios_info': usuarios_info,
        'query': query,
        'status': status,
        'grupo': grupo,
        'ordenacao': ordenacao,
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'usuarios_inativos': usuarios_inativos,
        'grupos_disponiveis': grupos_disponiveis,
        'resultados_count': len(usuarios_info),
    }
    return render(request, 'militares/usuarios/custom_list.html', context)


@login_required
@permission_required('auth.view_user')
def usuario_detail(request, pk):
    """Detalhes de um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    # Buscar militar vinculado
    militar = getattr(usuario, 'militar', None)
    funcoes_militar = []
    
    if militar:
        membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
        funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
    
    # FunÃ§Ãµes diretas do usuÃ¡rio
    funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
    
    # PermissÃµes do usuÃ¡rio
    permissoes_usuario = usuario.user_permissions.all()
    permissoes_grupos = []
    for grupo in usuario.groups.all():
        permissoes_grupo = grupo.permissions.all()
        permissoes_grupos.extend(permissoes_grupo)
    permissoes_grupos = list(set(permissoes_grupos))
    
    context = {
        'usuario': usuario,
        'militar': militar,
        'funcoes_militar': funcoes_militar,
        'funcoes_usuario': funcoes_usuario,
        'permissoes_usuario': permissoes_usuario,
        'permissoes_grupos': permissoes_grupos,
    }
    return render(request, 'militares/usuarios/detail.html', context)


# Views para gerenciamento de permissÃµes
@login_required
@permission_required('auth.view_user')
def gerenciar_permissoes(request):
    """Interface principal para gerenciar permissÃµes"""
    cargos = CargoFuncao.objects.filter(ativo=True).order_by('nome')
    perfis = PerfilAcesso.objects.filter(ativo=True).order_by('nome')
    
    # EstatÃ­sticas
    total_cargos = cargos.count()
    total_perfis = perfis.count()
    total_permissoes = PermissaoFuncao.objects.filter(ativo=True).count()
    
    context = {
        'cargos': cargos,
        'perfis': perfis,
        'total_cargos': total_cargos,
        'total_perfis': total_perfis,
        'total_permissoes': total_permissoes,
    }
    return render(request, 'militares/permissoes/gerenciar_permissoes.html', context)


@login_required
@permission_required('auth.view_user')
def permissao_cargo_detail(request, cargo_id):
    """Detalhes das permissÃµes de um cargo especÃ­fico"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    permissoes = PermissaoFuncao.objects.filter(cargo_funcao=cargo).order_by('modulo', 'acesso')
    
    # Agrupar permissÃµes por mÃ³dulo
    permissoes_por_modulo = {}
    for permissao in permissoes:
        if permissao.modulo not in permissoes_por_modulo:
            permissoes_por_modulo[permissao.modulo] = []
        permissoes_por_modulo[permissao.modulo].append(permissao)
    
    # MÃ³dulos disponÃ­veis
    modulos_disponiveis = dict(PermissaoFuncao.MODULOS_CHOICES)
    acessos_disponiveis = dict(PermissaoFuncao.ACESSOS_CHOICES)
    
    context = {
        'cargo': cargo,
        'permissoes_por_modulo': permissoes_por_modulo,
        'modulos_disponiveis': modulos_disponiveis,
        'acessos_disponiveis': acessos_disponiveis,
    }
    return render(request, 'militares/permissoes/permissao_cargo_detail.html', context)


@login_required
@permission_required('auth.view_user')
def permissao_cargo_edit(request, cargo_id):
    """Editar permissÃµes de um cargo"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    if request.method == 'POST':
        # Processar formulÃ¡rio de permissÃµes
        permissoes_selecionadas = request.POST.getlist('permissoes')
        
        print(f"DEBUG: Recebidas {len(permissoes_selecionadas)} permissÃµes")
        print(f"DEBUG: PermissÃµes: {permissoes_selecionadas}")
        
        # Limpar permissÃµes existentes
        permissoes_removidas = PermissaoFuncao.objects.filter(cargo_funcao=cargo).count()
        PermissaoFuncao.objects.filter(cargo_funcao=cargo).delete()
        print(f"DEBUG: Removidas {permissoes_removidas} permissÃµes existentes")
        
        # Criar novas permissÃµes
        for permissao_str in permissoes_selecionadas:
            if ':' in permissao_str:
                modulo, acesso = permissao_str.split(':', 1)
                PermissaoFuncao.objects.create(
                    cargo_funcao=cargo,
                    modulo=modulo,
                    acesso=acesso,
                    ativo=True
                )
                print(f"DEBUG: Criada permissÃ£o {modulo}:{acesso}")
        
        print(f"DEBUG: Total de permissÃµes criadas: {len(permissoes_selecionadas)}")
        messages.success(request, f'PermissÃµes do cargo "{cargo.nome}" atualizadas com sucesso!')
        return redirect('militares:permissao_cargo_detail', cargo_id=cargo_id)
    
    # Obter permissÃµes atuais
    permissoes_atuais = PermissaoFuncao.objects.filter(cargo_funcao=cargo)
    permissoes_ativas = set(f"{p.modulo}:{p.acesso}" for p in permissoes_atuais)
    
    # Obter perfis disponÃ­veis
    perfis = PerfilAcesso.objects.filter(ativo=True).order_by('nome')
    
    context = {
        'cargo': cargo,
        'permissoes_ativas': permissoes_ativas,
        'modulos': PermissaoFuncao.MODULOS_CHOICES,
        'acessos': PermissaoFuncao.ACESSOS_CHOICES,
        'perfis': perfis,
    }
    return render(request, 'militares/permissoes/permissao_cargo_edit.html', context)


@login_required
@permission_required('auth.view_user')
def aplicar_perfil_cargo(request, cargo_id, perfil_id):
    """Aplicar um perfil de acesso a um cargo"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    perfil = get_object_or_404(PerfilAcesso, pk=perfil_id)
    
    if request.method == 'POST':
        # Limpar permissÃµes existentes
        PermissaoFuncao.objects.filter(cargo_funcao=cargo).delete()
        
        # Aplicar permissÃµes do perfil
        for permissao in perfil.permissoes.all():
            obj, created = PermissaoFuncao.objects.get_or_create(
                cargo_funcao=cargo,
                modulo=permissao.modulo,
                acesso=permissao.acesso,
                defaults={
                    'ativo': True,
                    'observacoes': f"Aplicado do perfil: {perfil.nome}"
                }
            )
            if not created:
                obj.ativo = True
                obj.observacoes = f"Aplicado do perfil: {perfil.nome}"
                obj.save()
        
        messages.success(request, f'Perfil "{perfil.nome}" aplicado ao cargo "{cargo.nome}" com sucesso!')
        return redirect('militares:permissao_cargo_detail', cargo_id=cargo_id)
    
    context = {
        'cargo': cargo,
        'perfil': perfil,
    }
    return render(request, 'militares/permissoes/aplicar_perfil_confirm.html', context)


@login_required
@permission_required('auth.view_user')
def perfil_acesso_detail(request, perfil_id):
    """Detalhes de um perfil de acesso"""
    perfil = get_object_or_404(PerfilAcesso, pk=perfil_id)
    permissoes = perfil.permissoes.all().order_by('modulo', 'acesso')
    
    # Agrupar permissÃµes por mÃ³dulo
    permissoes_por_modulo = {}
    for permissao in permissoes:
        if permissao.modulo not in permissoes_por_modulo:
            permissoes_por_modulo[permissao.modulo] = []
        permissoes_por_modulo[permissao.modulo].append(permissao)
    
    # Cargos que usam este perfil
    cargos_com_perfil = CargoFuncao.objects.filter(
        permissoes__in=permissoes
    ).distinct()
    
    context = {
        'perfil': perfil,
        'permissoes_por_modulo': permissoes_por_modulo,
        'cargos_com_perfil': cargos_com_perfil,
    }
    return render(request, 'militares/permissoes/perfil_acesso_detail.html', context)


@login_required
@permission_required('auth.view_user')
def perfil_acesso_edit(request, perfil_id):
    """Editar um perfil de acesso"""
    perfil = get_object_or_404(PerfilAcesso, pk=perfil_id)
    
    if request.method == 'POST':
        # Processar formulÃ¡rio
        permissoes_selecionadas = request.POST.getlist('permissoes')
        
        # Limpar permissÃµes existentes
        perfil.permissoes.clear()
        
        # Adicionar novas permissÃµes
        for permissao_str in permissoes_selecionadas:
            if ':' in permissao_str:
                modulo, acesso = permissao_str.split(':', 1)
                permissao, created = PermissaoFuncao.objects.get_or_create(
                    modulo=modulo,
                    acesso=acesso,
                    defaults={'ativo': True}
                )
                perfil.permissoes.add(permissao)
        
        messages.success(request, f'Perfil "{perfil.nome}" atualizado com sucesso!')
        return redirect('militares:perfil_acesso_detail', perfil_id=perfil_id)
    
    # Obter permissÃµes atuais
    permissoes_ativas = set(f"{p.modulo}:{p.acesso}" for p in perfil.permissoes.all())
    
    context = {
        'perfil': perfil,
        'permissoes_ativas': permissoes_ativas,
        'modulos': PermissaoFuncao.MODULOS_CHOICES,
        'acessos': PermissaoFuncao.ACESSOS_CHOICES,
    }
    return render(request, 'militares/permissoes/perfil_acesso_edit.html', context)


@login_required
@permission_required('auth.view_user')
def perfil_acesso_create(request):
    """Criar um novo perfil de acesso"""
    if request.method == 'POST':
        nome = request.POST.get('nome')
        descricao = request.POST.get('descricao', '')
        permissoes_selecionadas = request.POST.getlist('permissoes')
        
        if nome:
            perfil = PerfilAcesso.objects.create(
                nome=nome,
                descricao=descricao,
                ativo=True
            )
            
            # Adicionar permissÃµes
            for permissao_str in permissoes_selecionadas:
                if ':' in permissao_str:
                    modulo, acesso = permissao_str.split(':', 1)
                    permissao, created = PermissaoFuncao.objects.get_or_create(
                        modulo=modulo,
                        acesso=acesso,
                        defaults={'ativo': True}
                    )
                    perfil.permissoes.add(permissao)
            
            messages.success(request, f'Perfil "{nome}" criado com sucesso!')
            return redirect('militares:perfil_acesso_detail', perfil_id=perfil.id)
        else:
            messages.error(request, 'Nome do perfil Ã© obrigatÃ³rio!')
    
    context = {
        'modulos': PermissaoFuncao.MODULOS_CHOICES,
        'acessos': PermissaoFuncao.ACESSOS_CHOICES,
    }
    return render(request, 'militares/permissoes/perfil_acesso_create.html', context)


@login_required
@permission_required('auth.view_user')
def usuario_permissoes_detail(request, usuario_id):
    """Detalhes das permissÃµes de um usuÃ¡rio especÃ­fico"""
    usuario = get_object_or_404(User, pk=usuario_id)
    
    # FunÃ§Ãµes do usuÃ¡rio
    funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('cargo_funcao__nome')
    
    # PermissÃµes diretas do usuÃ¡rio
    permissoes_diretas = usuario.user_permissions.all()
    
    # PermissÃµes via grupos
    permissoes_grupos = []
    for grupo in usuario.groups.all():
        permissoes_grupo = grupo.permissions.all()
        permissoes_grupos.extend(permissoes_grupo)
    permissoes_grupos = list(set(permissoes_grupos))
    
    # PermissÃµes via funÃ§Ãµes
    permissoes_funcoes = []
    for funcao in funcoes_usuario:
        if funcao.cargo_funcao:
            permissoes_cargo = PermissaoFuncao.objects.filter(
                cargo_funcao=funcao.cargo_funcao,
                ativo=True
            )
            permissoes_funcoes.extend(permissoes_cargo)
    
    context = {
        'usuario': usuario,
        'funcoes_usuario': funcoes_usuario,
        'permissoes_diretas': permissoes_diretas,
        'permissoes_grupos': permissoes_grupos,
        'permissoes_funcoes': permissoes_funcoes,
    }
    return render(request, 'militares/permissoes/usuario_permissoes_detail.html', context)


@login_required
@permission_required('auth.change_user')
def usuario_update(request, pk):
    """Editar um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        # FormulÃ¡rio simples para editar dados bÃ¡sicos
        first_name = request.POST.get('first_name', '')
        last_name = request.POST.get('last_name', '')
        email = request.POST.get('email', '')
        is_active = request.POST.get('is_active') == 'on'
        
        usuario.first_name = first_name
        usuario.last_name = last_name
        usuario.email = email
        usuario.is_active = is_active
        usuario.save()
        
        messages.success(request, f'UsuÃ¡rio {usuario.get_full_name()} atualizado com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/update.html', context)


@login_required
@permission_required('auth.delete_user')
def usuario_delete(request, pk):
    """Excluir um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        nome_usuario = usuario.get_full_name()
        usuario.delete()
        messages.success(request, f'UsuÃ¡rio {nome_usuario} excluÃ­do com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/delete.html', context)


# Views para gerenciar funÃ§Ãµes dos usuÃ¡rios
@login_required
@permission_required('auth.view_user')
def usuario_funcoes_list(request, pk):
    """Lista todas as funÃ§Ãµes de um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcoes = usuario.funcoes.all().order_by('-data_inicio')
    
    # EstatÃ­sticas
    funcoes_ativas = funcoes.filter(status='AT')
    funcoes_inativas = funcoes.filter(status='INATIVO')
    funcoes_suspensas = funcoes.filter(status='SUSPENSO')
    
    context = {
        'usuario': usuario,
        'funcoes': funcoes,
        'funcoes_ativas': funcoes_ativas,
        'funcoes_inativas': funcoes_inativas,
        'funcoes_suspensas': funcoes_suspensas,
    }
    return render(request, 'militares/usuarios/funcoes/list.html', context)


@login_required
@permission_required('auth.change_user')
def usuario_funcao_add(request, pk):
    """Adiciona uma nova funÃ§Ã£o ao usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST)
        if form.is_valid():
            # Verificar se jÃ¡ existe uma funÃ§Ã£o com a mesma combinaÃ§Ã£o
            cargo_funcao = form.cleaned_data['cargo_funcao']
            data_inicio = form.cleaned_data['data_inicio']
            
            funcao_existente = UsuarioFuncao.objects.filter(
                usuario=usuario,
                cargo_funcao=cargo_funcao,
                data_inicio=data_inicio
            ).first()
            
            if funcao_existente:
                messages.error(request, f'JÃ¡ existe uma funÃ§Ã£o "{cargo_funcao.nome}" para este usuÃ¡rio com a data de inÃ­cio {data_inicio}.')
                context = {
                    'form': form,
                    'usuario': usuario,
                }
                return render(request, 'militares/usuarios/funcoes/form.html', context)
            
            funcao = form.save(commit=False)
            funcao.usuario = usuario
            funcao.save()
            messages.success(request, f'FunÃ§Ã£o "{funcao.cargo_funcao.nome}" adicionada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(initial={'usuario': usuario})
    
    context = {
        'form': form,
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)


@login_required
@permission_required('auth.change_user')
def usuario_funcao_edit(request, pk, funcao_pk):
    """Edita uma funÃ§Ã£o do usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST, instance=funcao)
        if form.is_valid():
            form.save()
            messages.success(request, f'FunÃ§Ã£o "{funcao.cargo_funcao.nome}" atualizada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(instance=funcao)
    
    context = {
        'form': form,
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)


@login_required
@permission_required('auth.change_user')
def usuario_funcao_delete(request, pk, funcao_pk):
    """Remove uma funÃ§Ã£o do usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        nome_funcao = funcao.cargo_funcao.nome
        
        # Verificar se a funÃ§Ã£o excluÃ­da Ã© a mesma que estÃ¡ na sessÃ£o do usuÃ¡rio
        funcao_na_sessao = request.session.get('funcao_atual_id')
        if funcao_na_sessao and int(funcao_na_sessao) == funcao_pk:
            # Se for a funÃ§Ã£o da sessÃ£o, limpar a sessÃ£o antes de excluir
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
        
        funcao.delete()
        messages.success(request, f'FunÃ§Ã£o "{nome_funcao}" removida com sucesso!')
        return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    
    context = {
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/delete.html', context)


# Views para seleÃ§Ã£o de funÃ§Ã£o apÃ³s login
def selecionar_funcao(request):
    """
    View para selecionar funÃ§Ã£o/cargo apÃ³s login
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funÃ§Ãµes ativas do usuÃ¡rio
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    # Se sÃ³ tem uma funÃ§Ã£o, seleciona automaticamente
    if funcoes_usuario.count() == 1:
        funcao = funcoes_usuario.first()
        request.session['funcao_atual_id'] = funcao.id
        request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
        request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
        messages.success(request, f'FunÃ§Ã£o selecionada automaticamente: {funcao.cargo_funcao.nome}')
        return redirect('militares:militar_dashboard')
    
    # Se nÃ£o tem funÃ§Ãµes, redireciona para erro
    if funcoes_usuario.count() == 0:
        messages.error(request, 'VocÃª nÃ£o possui funÃ§Ãµes ativas no sistema.')
        return redirect('logout')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'FunÃ§Ã£o selecionada: {funcao.cargo_funcao.nome}')
                return redirect('militares:militar_dashboard')
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'FunÃ§Ã£o invÃ¡lida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/selecionar_funcao.html', context)


def trocar_funcao(request):
    """
    View para trocar funÃ§Ã£o durante a sessÃ£o
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funÃ§Ãµes ativas do usuÃ¡rio
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'FunÃ§Ã£o alterada para: {funcao.cargo_funcao.nome}')
                return redirect(request.POST.get('next', 'militares:militar_dashboard'))
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'FunÃ§Ã£o invÃ¡lida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
        'funcao_atual_id': request.session.get('funcao_atual_id'),
        'next': request.GET.get('next', 'militares:militar_dashboard'),
    }
    return render(request, 'militares/usuarios/trocar_funcao.html', context)


def obter_funcao_atual(request):
    """
    FunÃ§Ã£o helper para obter a funÃ§Ã£o atual da sessÃ£o
    """
    if not request.user.is_authenticated:
        return None
    
    funcao_id = request.session.get('funcao_atual_id')
    if funcao_id:
        try:
            return UsuarioFuncao.objects.get(id=funcao_id, usuario=request.user)
        except UsuarioFuncao.DoesNotExist:
            # Se a funÃ§Ã£o nÃ£o existe mais, limpa a sessÃ£o
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
    
    return None

@login_required
def alterar_senha(request):
    """View para alterar senha do usuÃ¡rio logado"""
    if request.method == 'POST':
        form = AlterarSenhaForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            # Atualizar a sessÃ£o para nÃ£o deslogar o usuÃ¡rio
            update_session_auth_hash(request, form.user)
            messages.success(request, 'âœ… Senha alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=request.user.pk)
    else:
        form = AlterarSenhaForm(request.user)
    
    context = {
        'form': form,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/alterar_senha.html', context)


@login_required
@permission_required('auth.change_user')
def alterar_senha_usuario(request, pk):
    """View para administradores alterarem senha de outros usuÃ¡rios"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = AlterarSenhaAdminForm(usuario, request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, f'âœ… Senha do usuÃ¡rio {usuario.get_full_name()} alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=usuario.pk)
    else:
        form = AlterarSenhaAdminForm(usuario)
    
    context = {
        'form': form,
        'usuario': usuario,
        'usuario_alvo': usuario,
    }
    return render(request, 'militares/usuarios/alterar_senha_admin.html', context)


class AlterarSenhaForm(forms.Form):
    """FormulÃ¡rio para alterar senha"""
    senha_atual = forms.CharField(
        label='Senha Atual',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite sua senha atual'
        }),
        strip=False
    )
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean_senha_atual(self):
        senha_atual = self.cleaned_data.get('senha_atual')
        if not self.user.check_password(senha_atual):
            raise forms.ValidationError('Senha atual incorreta.')
        return senha_atual

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas nÃ£o coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user


class AlterarSenhaAdminForm(forms.Form):
    """FormulÃ¡rio para administradores alterarem senha de outros usuÃ¡rios"""
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas nÃ£o coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user

@login_required
@permission_required('auth.delete_user')
def perfil_acesso_delete(request, perfil_id):
    """Exclui um perfil de acesso"""
    perfil = get_object_or_404(PerfilAcesso, pk=perfil_id)
    erro_protegido = False
    
    # Verificar se hÃ¡ permissÃµes vinculadas
    permissoes_vinculadas = perfil.permissoes.all()
    cargos_com_perfil = CargoFuncao.objects.filter(permissoes__in=permissoes_vinculadas).distinct()
    
    if request.method == 'POST':
        try:
            # Verificar se hÃ¡ cargos usando este perfil
            if cargos_com_perfil.exists():
                erro_protegido = True
                messages.error(request, f'NÃ£o Ã© possÃ­vel excluir este perfil porque {cargos_com_perfil.count()} cargo(s)/funÃ§Ã£o(Ãµes) estÃ£o usando este perfil.')
            elif permissoes_vinculadas.exists():
                erro_protegido = True
                messages.error(request, f'NÃ£o Ã© possÃ­vel excluir este perfil porque hÃ¡ {permissoes_vinculadas.count()} permissÃ£o(Ãµes) vinculada(s).')
            else:
                perfil.delete()
                messages.success(request, 'Perfil de acesso excluÃ­do com sucesso!')
                return redirect('militares:gerenciar_permissoes')
        except Exception as e:
            erro_protegido = True
            messages.error(request, f'Erro ao excluir perfil: {str(e)}')
    
    context = {
        'perfil': perfil,
        'erro_protegido': erro_protegido,
        'cargos_com_perfil': cargos_com_perfil,
        'permissoes_vinculadas': permissoes_vinculadas,
    }
    return render(request, 'militares/permissoes/perfil_acesso_confirm_delete.html', context)

@login_required
@permission_required('auth.delete_user')
def cargo_funcao_delete(request, cargo_id):
    """Exclui um cargo/funÃ§Ã£o"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    erro_protegido = False
    
    # Verificar se hÃ¡ usuÃ¡rios usando esta funÃ§Ã£o
    usuarios_com_funcao = UsuarioFuncao.objects.filter(cargo_funcao=cargo)
    permissoes_vinculadas = PermissaoFuncao.objects.filter(cargo_funcao=cargo)
    
    if request.method == 'POST':
        try:
            # Verificar se hÃ¡ usuÃ¡rios usando esta funÃ§Ã£o
            if usuarios_com_funcao.exists():
                erro_protegido = True
                messages.error(request, f'NÃ£o Ã© possÃ­vel excluir este cargo/funÃ§Ã£o porque {usuarios_com_funcao.count()} usuÃ¡rio(s) estÃ£o usando esta funÃ§Ã£o.')
            elif permissoes_vinculadas.exists():
                erro_protegido = True
                messages.error(request, f'NÃ£o Ã© possÃ­vel excluir este cargo/funÃ§Ã£o porque hÃ¡ {permissoes_vinculadas.count()} permissÃ£o(Ãµes) vinculada(s).')
            else:
                cargo.delete()
                messages.success(request, 'Cargo/FunÃ§Ã£o excluÃ­do com sucesso!')
                return redirect('militares:gerenciar_permissoes')
        except Exception as e:
            erro_protegido = True
            messages.error(request, f'Erro ao excluir cargo/funÃ§Ã£o: {str(e)}')
    
    context = {
        'cargo': cargo,
        'erro_protegido': erro_protegido,
        'usuarios_com_funcao': usuarios_com_funcao,
        'permissoes_vinculadas': permissoes_vinculadas,
    }
    return render(request, 'militares/permissoes/cargo_funcao_confirm_delete.html', context)

from django.contrib.auth.models import Group, Permission
from django.contrib.auth.decorators import login_required, permission_required
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages

@login_required
@permission_required('auth.view_group')
def grupo_list(request):
    grupos = Group.objects.all().order_by('name')
    return render(request, 'militares/permissoes/grupo_list.html', {'grupos': grupos})

@login_required
@permission_required('auth.add_group')
def grupo_create(request):
    if request.method == 'POST':
        nome = request.POST.get('name')
        permissoes = request.POST.getlist('permissoes')
        grupo = Group.objects.create(name=nome)
        grupo.permissions.set(Permission.objects.filter(id__in=permissoes))
        messages.success(request, 'Grupo criado com sucesso!')
        return redirect('militares:grupo_list')
    permissoes = Permission.objects.all().order_by('content_type__app_label', 'codename')
    return render(request, 'militares/permissoes/grupo_form.html', {'permissoes': permissoes})

@login_required
@permission_required('auth.change_group')
def grupo_edit(request, grupo_id):
    grupo = get_object_or_404(Group, pk=grupo_id)
    if request.method == 'POST':
        nome = request.POST.get('name')
        permissoes = request.POST.getlist('permissoes')
        grupo.name = nome
        grupo.save()
        grupo.permissions.set(Permission.objects.filter(id__in=permissoes))
        messages.success(request, 'Grupo atualizado com sucesso!')
        return redirect('militares:grupo_list')
    permissoes = Permission.objects.all().order_by('content_type__app_label', 'codename')
    grupo_permissoes = grupo.permissions.values_list('id', flat=True)
    return render(request, 'militares/permissoes/grupo_form.html', {
        'grupo': grupo,
        'permissoes': permissoes,
        'grupo_permissoes': grupo_permissoes
    })

@login_required
@permission_required('auth.delete_group')
def grupo_delete(request, grupo_id):
    grupo = get_object_or_404(Group, pk=grupo_id)
    if request.method == 'POST':
        grupo.delete()
        messages.success(request, 'Grupo excluÃ­do com sucesso!')
        return redirect('militares:grupo_list')
    return render(request, 'militares/permissoes/grupo_confirm_delete.html', {'grupo': grupo})


@login_required
@permission_required('auth.change_group')
def gerenciar_permissoes_funcao(request, cargo_id):
    """Gerencia as permissÃµes de uma funÃ§Ã£o especÃ­fica"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    if request.method == 'POST':
        permissoes_selecionadas = request.POST.getlist('permissoes')
        
        # Limpar permissÃµes atuais da funÃ§Ã£o
        PermissaoFuncao.objects.filter(cargo_funcao=cargo).delete()
        
        # Adicionar novas permissÃµes
        for perm_id in permissoes_selecionadas:
            permissao = Permission.objects.get(id=perm_id)
            # Extrair mÃ³dulo e acesso da permissÃ£o Django
            codename = permissao.codename
            if '_' in codename:
                modulo, acesso = codename.rsplit('_', 1)
                modulo = modulo.upper()
                acesso = acesso.upper()
            else:
                modulo = 'OUTROS'
                acesso = 'VISUALIZAR'
            
            PermissaoFuncao.objects.create(
                cargo_funcao=cargo,
                modulo=modulo,
                acesso=acesso
            )
        
        # Aplicar permissÃµes aos usuÃ¡rios que possuem esta funÃ§Ã£o
        aplicar_permissoes_funcao_a_usuarios(cargo)
        
        messages.success(request, f'PermissÃµes da funÃ§Ã£o "{cargo.nome}" atualizadas e aplicadas aos usuÃ¡rios com sucesso!')
        return redirect('militares:gerenciar_permissoes')
    
    # Buscar todas as permissÃµes organizadas por app
    permissoes_por_app = {}
    for perm in Permission.objects.all().order_by('content_type__app_label', 'name'):
        app_label = perm.content_type.app_label
        if app_label not in permissoes_por_app:
            permissoes_por_app[app_label] = []
        permissoes_por_app[app_label].append(perm)
    
    # Buscar permissÃµes atuais da funÃ§Ã£o
    permissoes_atuais = set(
        (p.modulo, p.acesso)
        for p in PermissaoFuncao.objects.filter(cargo_funcao=cargo)
    )
    
    context = {
        'cargo': cargo,
        'permissoes_por_app': permissoes_por_app,
        'permissoes_atuais': list(permissoes_atuais)
    }
    
    return render(request, 'militares/permissoes/gerenciar_permissoes_funcao.html', context)

def aplicar_permissoes_funcao_a_usuarios(cargo_funcao):
    """Aplica as permissÃµes de uma funÃ§Ã£o a todos os usuÃ¡rios que possuem essa funÃ§Ã£o"""
    # Buscar todos os usuÃ¡rios que possuem esta funÃ§Ã£o
    usuarios_com_funcao = UsuarioFuncao.objects.filter(cargo_funcao=cargo_funcao)
    
    # Buscar todas as permissÃµes desta funÃ§Ã£o
    permissoes_funcao = PermissaoFuncao.objects.filter(cargo_funcao=cargo_funcao)
    
    for usuario_funcao in usuarios_com_funcao:
        usuario = usuario_funcao.usuario
        
        # Remover permissÃµes antigas da funÃ§Ã£o
        for permissao_funcao in permissoes_funcao:
            # Buscar permissÃ£o Django correspondente ao mÃ³dulo e acesso
            try:
                permissao_django = Permission.objects.get(
                    content_type__app_label='militares',
                    codename=f"{permissao_funcao.modulo.lower()}_{permissao_funcao.acesso.lower()}"
                )
                usuario.user_permissions.remove(permissao_django)
            except Permission.DoesNotExist:
                # Se a permissÃ£o nÃ£o existe, apenas continuar
                pass
        
        # Adicionar novas permissÃµes
        for permissao_funcao in permissoes_funcao:
            # Buscar permissÃ£o Django correspondente ao mÃ³dulo e acesso
            try:
                permissao_django = Permission.objects.get(
                    content_type__app_label='militares',
                    codename=f"{permissao_funcao.modulo.lower()}_{permissao_funcao.acesso.lower()}"
                )
                usuario.user_permissions.add(permissao_django)
            except Permission.DoesNotExist:
                # Se a permissÃ£o nÃ£o existe, apenas continuar
                pass


@login_required
def buscar_funcao_militar(request):
    """Busca a funÃ§Ã£o/cargo do militar para preenchimento automÃ¡tico"""
    militar_id = request.GET.get('militar_id')
    
    if not militar_id:
        return JsonResponse({'error': 'ID do militar nÃ£o fornecido'}, status=400)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Buscar funÃ§Ã£o do militar atravÃ©s do usuÃ¡rio vinculado
        funcao_militar = None
        if militar.user:
            # Buscar funÃ§Ã£o ativa do usuÃ¡rio
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='ATIVO'
            ).select_related('cargo_funcao').first()
            
            if funcao_usuario:
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        # Se nÃ£o encontrou funÃ§Ã£o via usuÃ¡rio, buscar todas as funÃ§Ãµes do usuÃ¡rio
        if not funcao_militar and militar.user:
            # Buscar todas as funÃ§Ãµes ativas do usuÃ¡rio
            funcoes_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='AT'
            ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
            
            if funcoes_usuario.exists():
                # Se hÃ¡ mÃºltiplas funÃ§Ãµes, retornar a primeira como padrÃ£o
                funcao_usuario = funcoes_usuario.first()
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        return JsonResponse({
            'success': True,
            'funcao': funcao_militar,
            'militar': {
                'id': militar.id,
                'nome': militar.nome_completo,
                'posto': militar.get_posto_graduacao_display(),
                'matricula': militar.matricula
            }
        })
        
    except Militar.DoesNotExist:
        return JsonResponse({'error': 'Militar nÃ£o encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar funÃ§Ã£o: {str(e)}'}, status=500)


@login_required
def buscar_funcoes_usuario(request):
    """Busca as funÃ§Ãµes/cargos do usuÃ¡rio para permitir escolha"""
    usuario_id = request.GET.get('usuario_id')
    
    if not usuario_id:
        return JsonResponse({'error': 'ID do usuÃ¡rio nÃ£o fornecido'}, status=400)
    
    try:
        usuario = User.objects.get(pk=usuario_id)
        
        # Buscar todas as funÃ§Ãµes ativas do usuÃ¡rio
        funcoes_usuario = UsuarioFuncao.objects.filter(
            usuario=usuario,
            status='AT'
        ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
        
        funcoes = []
        for funcao in funcoes_usuario:
            funcoes.append({
                'id': funcao.cargo_funcao.id,
                'nome': funcao.cargo_funcao.nome,
                'tipo': funcao.get_tipo_funcao_display(),
                'descricao': funcao.cargo_funcao.descricao or '',
                'data_inicio': funcao.data_inicio.strftime('%d/%m/%Y'),
                'data_fim': funcao.data_fim.strftime('%d/%m/%Y') if funcao.data_fim else None
            })
        
        return JsonResponse({
            'success': True,
            'funcoes': funcoes,
            'usuario': {
                'id': usuario.id,
                'nome': usuario.get_full_name(),
                'username': usuario.username
            }
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'UsuÃ¡rio nÃ£o encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar funÃ§Ãµes: {str(e)}'}, status=500)


@login_required
def voto_deliberacao_delete(request, voto_pk):
    """Excluir voto de uma deliberaÃ§Ã£o"""
    try:
        voto = VotoDeliberacao.objects.get(pk=voto_pk)
        deliberacao = voto.deliberacao
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio logado Ã© o autor do voto ou tem permissÃ£o
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir este voto.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar a exclusÃ£o.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Validar senha do usuÃ¡rio
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, 'âœ… Voto excluÃ­do com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    context = {
        'voto': voto,
        'deliberacao': deliberacao,
        'sessao': sessao,
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_delete.html', context)


@login_required
def assinar_ata_html(request, pk):
    """PÃ¡gina para assinar ata em HTML"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar a ata da sessÃ£o
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            messages.error(request, 'Ata nÃ£o encontrada para esta sessÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Verificar se a ata estÃ¡ para assinatura
        if ata.status != 'PARA_ASSINATURA':
            messages.error(request, 'Ata nÃ£o estÃ¡ disponÃ­vel para assinatura.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        context = {
            'sessao': sessao,
            'comissao': sessao.comissao,
            'ata': ata,
            'membro_usuario': membro,
        }
        
        return render(request, 'militares/comissao/sessoes/assinar_ata_html.html', context)
        
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    except Exception as e:
        messages.error(request, f'Erro ao carregar ata: {str(e)}')
        return redirect('militares:sessao_comissao_detail', pk=pk)


@login_required
def assinar_ata_eletronica(request, pk):
    """Processar assinatura eletrÃ´nica da ata"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'MÃ©todo nÃ£o permitido'})
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'VocÃª nÃ£o Ã© membro desta comissÃ£o.'
            })
        
        # Buscar a ata da sessÃ£o
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Ata nÃ£o encontrada para esta sessÃ£o.'
            })
        
        # Verificar se a ata estÃ¡ para assinatura
        if ata.status != 'PARA_ASSINATURA':
            return JsonResponse({
                'success': False,
                'error': 'Ata nÃ£o estÃ¡ disponÃ­vel para assinatura.'
            })
        
        # Processar dados da assinatura
        import json
        dados = json.loads(request.body)
        
        hash_documento = dados.get('hash')
        timestamp = dados.get('timestamp')
        assinatura_digital = dados.get('assinatura')
        certificado = dados.get('certificado')
        assinante = dados.get('assinante')
        data_assinatura = dados.get('data_assinatura')
        
        # Validar dados obrigatÃ³rios (certificado pode ser 'ASSINATURA_SIMPLES_SEI' para assinatura simples)
        if not all([hash_documento, timestamp, assinatura_digital, assinante]):
            return JsonResponse({
                'success': False,
                'error': 'Dados de assinatura incompletos.'
            })
        
        # Criar registro de assinatura
        from .models import AssinaturaAta
        
        # Buscar o membro da comissÃ£o
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
        
        # Verificar se jÃ¡ existe uma assinatura para este membro nesta ata
        assinatura_criada = False
        try:
            assinatura = AssinaturaAta.objects.get(ata=ata, membro=membro)
            # Atualizar a assinatura existente com os novos dados eletrÃ´nicos
            assinatura.hash_documento = hash_documento
            assinatura.timestamp = timestamp
            assinatura.assinatura_digital = assinatura_digital
            assinatura.certificado = certificado or 'ASSINATURA_SIMPLES_SEI'
            assinatura.ip_assinatura = request.META.get('REMOTE_ADDR', '')
            assinatura.user_agent = request.META.get('HTTP_USER_AGENT', '')
            assinatura.assinado_por = request.user
            assinatura.save()
        except AssinaturaAta.DoesNotExist:
            # Criar nova assinatura
            assinatura = AssinaturaAta.objects.create(
                ata=ata,
                membro=membro,
                assinado_por=request.user,
                hash_documento=hash_documento,
                timestamp=timestamp,
                assinatura_digital=assinatura_digital,
                certificado=certificado or 'ASSINATURA_SIMPLES_SEI',
                ip_assinatura=request.META.get('REMOTE_ADDR', ''),
                user_agent=request.META.get('HTTP_USER_AGENT', '')
            )
            assinatura_criada = True
        
        # Verificar se todos os membros presentes assinaram
        membros_presentes = sessao.presencas.filter(presente=True)
        assinaturas_realizadas = AssinaturaAta.objects.filter(ata=ata)
        
        if assinaturas_realizadas.count() >= membros_presentes.count():
            # Todos assinaram, marcar ata como assinada
            ata.status = 'ASSINADA'
            ata.save()
            
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Ata marcada como assinada.',
                'ata_status': 'ASSINADA'
            })
        else:
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Aguardando outras assinaturas.',
                'ata_status': 'PARA_ASSINATURA',
                'assinaturas_restantes': membros_presentes.count() - assinaturas_realizadas.count()
            })
        
    except SessaoComissao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'SessÃ£o nÃ£o encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao processar assinatura: {str(e)}'
        })


@login_required
def ata_assinaturas_eletronicas(request, pk):
    """PÃ¡gina para visualizar assinaturas eletrÃ´nicas da ata no formato SEI"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar a ata da sessÃ£o
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            messages.error(request, 'Ata nÃ£o encontrada para esta sessÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar assinaturas eletrÃ´nicas
        assinaturas = AssinaturaAta.objects.filter(ata=ata).order_by('data_assinatura')
        
        context = {
            'sessao': sessao,
            'comissao': sessao.comissao,
            'ata': ata,
            'assinaturas': assinaturas,
            'membro_usuario': membro,
        }
        
        return render(request, 'militares/comissao/sessoes/ata_assinaturas_eletronicas.html', context)
        
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    except Exception as e:
        messages.error(request, f'Erro ao carregar assinaturas: {str(e)}')
        return redirect('militares:sessao_comissao_detail', pk=pk)
@ l o g i n _ r e q u i r e d  
 d e f   r e t i r a r _ a s s i n a t u r a _ q u a d r o _ a c e s s o ( r e q u e s t ,   p k ,   a s s i n a t u r a _ p k ) :  
         " " " R e t i r a r   a s s i n a t u r a   d e   u m   q u a d r o   d e   a c e s s o " " "  
         q u a d r o   =   g e t _ o b j e c t _ o r _ 4 0 4 ( Q u a d r o A c e s s o ,   p k = p k )  
         a s s i n a t u r a   =   g e t _ o b j e c t _ o r _ 4 0 4 ( A s s i n a t u r a Q u a d r o A c e s s o ,   p k = a s s i n a t u r a _ p k ,   q u a d r o _ a c e s s o = q u a d r o )  
          
         #   V e r i f i c a r   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a  
         i f   q u a d r o . t i p o   i n   [ ' A N T I G U I D A D E ' ,   ' M E R E C I M E N T O ' ] :  
                 #   P a r a   q u a d r o s   d e   o f i c i a i s ,   v e r i f i c a r   s e   Ã ©   m e m b r o   d a   C P O  
                 c o m i s s a o _ c p o   =   C o m i s s a o P r o m o c a o . g e t _ c o m i s s a o _ a t i v a _ p o r _ t i p o ( ' C P O ' )  
                 i f   n o t   c o m i s s a o _ c p o   o r   n o t   c o m i s s a o _ c p o . p o d e _ a s s i n a r _ d o c u m e n t o _ o f i c i a l ( r e q u e s t . u s e r ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' V o c Ã ª   n Ã £ o   t e m   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a s   d e   d o c u m e n t o s   d e   o f i c i a i s .   A p e n a s   m e m b r o s   d a   C P O   p o d e m   f a z e r   i s s o . ' )  
                         r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ a c e s s o _ d e t a i l ' ,   p k = p k )  
         e l s e :  
                 #   P a r a   q u a d r o s   d e   p r a Ã § a s ,   v e r i f i c a r   s e   Ã ©   m e m b r o   d a   C P P  
                 c o m i s s a o _ c p p   =   C o m i s s a o P r o m o c a o . g e t _ c o m i s s a o _ a t i v a _ p o r _ t i p o ( ' C P P ' )  
                 i f   n o t   c o m i s s a o _ c p p   o r   n o t   c o m i s s a o _ c p p . p o d e _ a s s i n a r _ d o c u m e n t o _ p r a c a ( r e q u e s t . u s e r ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' V o c Ã ª   n Ã £ o   t e m   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a s   d e   d o c u m e n t o s   d e   p r a Ã § a s .   A p e n a s   m e m b r o s   d a   C P P   p o d e m   f a z e r   i s s o . ' )  
                         r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ a c e s s o _ d e t a i l ' ,   p k = p k )  
          
         i f   r e q u e s t . m e t h o d   = =   ' P O S T ' :  
                 s e n h a   =   r e q u e s t . P O S T . g e t ( ' s e n h a ' )  
                  
                 #   V e r i f i c a r   s e   a   s e n h a   f o i   f o r n e c i d a  
                 i f   n o t   s e n h a :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   Ã ©   o b r i g a t Ã ³ r i a   p a r a   c o n f i r m a r   a   r e t i r a d a   d a   a s s i n a t u r a . ' )  
                         c o n t e x t   =   {  
                                 ' q u a d r o ' :   q u a d r o ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ a c e s s o . h t m l ' ,   c o n t e x t )  
                  
                 #   V e r i f i c a r   s e n h a   d o   u s u Ã ¡ r i o   q u e   e s t Ã ¡   r e t i r a n d o   a   a s s i n a t u r a  
                 i f   n o t   r e q u e s t . u s e r . c h e c k _ p a s s w o r d ( s e n h a ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   i n c o r r e t a .   T e n t e   n o v a m e n t e . ' )  
                         c o n t e x t   =   {  
                                 ' q u a d r o ' :   q u a d r o ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ a c e s s o . h t m l ' ,   c o n t e x t )  
                  
                 #   E x c l u i r   a   a s s i n a t u r a  
                 a s s i n a t u r a . d e l e t e ( )  
                  
                 m e s s a g e s . s u c c e s s ( r e q u e s t ,   ' â S&   A s s i n a t u r a   r e t i r a d a   c o m   s u c e s s o ! ' )  
                 r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ a c e s s o _ d e t a i l ' ,   p k = q u a d r o . p k )  
          
         c o n t e x t   =   {  
                 ' q u a d r o ' :   q u a d r o ,  
                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
         }  
          
         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ a c e s s o . h t m l ' ,   c o n t e x t )  
  
  
 @ l o g i n _ r e q u i r e d  
 d e f   r e t i r a r _ a s s i n a t u r a _ q u a d r o _ f i x a c a o _ v a g a s ( r e q u e s t ,   p k ,   a s s i n a t u r a _ p k ) :  
         " " " R e t i r a r   a s s i n a t u r a   d e   u m   q u a d r o   d e   f i x a Ã § Ã £ o   d e   v a g a s " " "  
         q u a d r o   =   g e t _ o b j e c t _ o r _ 4 0 4 ( Q u a d r o F i x a c a o V a g a s ,   p k = p k )  
         a s s i n a t u r a   =   g e t _ o b j e c t _ o r _ 4 0 4 ( A s s i n a t u r a Q u a d r o F i x a c a o V a g a s ,   p k = a s s i n a t u r a _ p k ,   q u a d r o _ f i x a c a o _ v a g a s = q u a d r o )  
          
         #   V e r i f i c a r   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a  
         i f   q u a d r o . t i p o   = =   ' O F I C I A I S ' :  
                 #   P a r a   q u a d r o s   d e   o f i c i a i s ,   v e r i f i c a r   s e   Ã ©   m e m b r o   d a   C P O  
                 c o m i s s a o _ c p o   =   C o m i s s a o P r o m o c a o . g e t _ c o m i s s a o _ a t i v a _ p o r _ t i p o ( ' C P O ' )  
                 i f   n o t   c o m i s s a o _ c p o   o r   n o t   c o m i s s a o _ c p o . p o d e _ a s s i n a r _ d o c u m e n t o _ o f i c i a l ( r e q u e s t . u s e r ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' V o c Ã ª   n Ã £ o   t e m   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a s   d e   d o c u m e n t o s   d e   o f i c i a i s .   A p e n a s   m e m b r o s   d a   C P O   p o d e m   f a z e r   i s s o . ' )  
                         r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ f i x a c a o _ v a g a s _ d e t a i l ' ,   p k = p k )  
         e l s e :  
                 #   P a r a   q u a d r o s   d e   p r a Ã § a s ,   v e r i f i c a r   s e   Ã ©   m e m b r o   d a   C P P  
                 c o m i s s a o _ c p p   =   C o m i s s a o P r o m o c a o . g e t _ c o m i s s a o _ a t i v a _ p o r _ t i p o ( ' C P P ' )  
                 i f   n o t   c o m i s s a o _ c p p   o r   n o t   c o m i s s a o _ c p p . p o d e _ a s s i n a r _ d o c u m e n t o _ p r a c a ( r e q u e s t . u s e r ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' V o c Ã ª   n Ã £ o   t e m   p e r m i s s Ã £ o   p a r a   r e t i r a r   a s s i n a t u r a s   d e   d o c u m e n t o s   d e   p r a Ã § a s .   A p e n a s   m e m b r o s   d a   C P P   p o d e m   f a z e r   i s s o . ' )  
                         r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ f i x a c a o _ v a g a s _ d e t a i l ' ,   p k = p k )  
          
         i f   r e q u e s t . m e t h o d   = =   ' P O S T ' :  
                 s e n h a   =   r e q u e s t . P O S T . g e t ( ' s e n h a ' )  
                  
                 #   V e r i f i c a r   s e   a   s e n h a   f o i   f o r n e c i d a  
                 i f   n o t   s e n h a :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   Ã ©   o b r i g a t Ã ³ r i a   p a r a   c o n f i r m a r   a   r e t i r a d a   d a   a s s i n a t u r a . ' )  
                         c o n t e x t   =   {  
                                 ' q u a d r o ' :   q u a d r o ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ f i x a c a o _ v a g a s . h t m l ' ,   c o n t e x t )  
                  
                 #   V e r i f i c a r   s e n h a   d o   u s u Ã ¡ r i o   q u e   e s t Ã ¡   r e t i r a n d o   a   a s s i n a t u r a  
                 i f   n o t   r e q u e s t . u s e r . c h e c k _ p a s s w o r d ( s e n h a ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   i n c o r r e t a .   T e n t e   n o v a m e n t e . ' )  
                         c o n t e x t   =   {  
                                 ' q u a d r o ' :   q u a d r o ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ f i x a c a o _ v a g a s . h t m l ' ,   c o n t e x t )  
                  
                 #   E x c l u i r   a   a s s i n a t u r a  
                 a s s i n a t u r a . d e l e t e ( )  
                  
                 m e s s a g e s . s u c c e s s ( r e q u e s t ,   ' â S&   A s s i n a t u r a   r e t i r a d a   c o m   s u c e s s o ! ' )  
                 r e t u r n   r e d i r e c t ( ' m i l i t a r e s : q u a d r o _ f i x a c a o _ v a g a s _ d e t a i l ' ,   p k = q u a d r o . p k )  
          
         c o n t e x t   =   {  
                 ' q u a d r o ' :   q u a d r o ,  
                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
         }  
          
         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / r e t i r a r _ a s s i n a t u r a _ q u a d r o _ f i x a c a o _ v a g a s . h t m l ' ,   c o n t e x t )  
  
  
 @ l o g i n _ r e q u i r e d  
 d e f   r e t i r a r _ a s s i n a t u r a _ a t a ( r e q u e s t ,   p k ,   a s s i n a t u r a _ p k ) :  
         " " " R e t i r a r   a s s i n a t u r a   d e   u m a   a t a " " "  
         t r y :  
                 s e s s a o   =   S e s s a o C o m i s s a o . o b j e c t s . g e t ( p k = p k )  
                 a t a   =   A t a S e s s a o . o b j e c t s . g e t ( s e s s a o = s e s s a o )  
                 a s s i n a t u r a   =   A s s i n a t u r a A t a . o b j e c t s . g e t ( p k = a s s i n a t u r a _ p k ,   a t a = a t a )  
         e x c e p t   ( S e s s a o C o m i s s a o . D o e s N o t E x i s t ,   A t a S e s s a o . D o e s N o t E x i s t ,   A s s i n a t u r a A t a . D o e s N o t E x i s t ) :  
                 m e s s a g e s . e r r o r ( r e q u e s t ,   ' A t a   o u   a s s i n a t u r a   n Ã £ o   e n c o n t r a d a . ' )  
                 r e t u r n   r e d i r e c t ( ' m i l i t a r e s : s e s s a o _ c o m i s s a o _ d e t a i l ' ,   p k = p k )  
          
         #   V e r i f i c a r   s e   o   u s u Ã ¡ r i o   Ã ©   m e m b r o   d a   c o m i s s Ã £ o  
         m e m b r o   =   M e m b r o C o m i s s a o . o b j e c t s . f i l t e r (  
                 c o m i s s a o = s e s s a o . c o m i s s a o ,  
                 u s u a r i o = r e q u e s t . u s e r ,  
                 a t i v o = T r u e  
         ) . f i r s t ( )  
          
         i f   n o t   m e m b r o :  
                 m e s s a g e s . e r r o r ( r e q u e s t ,   ' V o c Ã ª   n Ã £ o   Ã ©   m e m b r o   d e s t a   c o m i s s Ã £ o . ' )  
                 r e t u r n   r e d i r e c t ( ' m i l i t a r e s : s e s s a o _ c o m i s s a o _ d e t a i l ' ,   p k = s e s s a o . p k )  
          
         i f   r e q u e s t . m e t h o d   = =   ' P O S T ' :  
                 s e n h a   =   r e q u e s t . P O S T . g e t ( ' s e n h a ' )  
                  
                 #   V e r i f i c a r   s e   a   s e n h a   f o i   f o r n e c i d a  
                 i f   n o t   s e n h a :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   Ã ©   o b r i g a t Ã ³ r i a   p a r a   c o n f i r m a r   a   r e t i r a d a   d a   a s s i n a t u r a . ' )  
                         c o n t e x t   =   {  
                                 ' s e s s a o ' :   s e s s a o ,  
                                 ' a t a ' :   a t a ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                                 ' m e m b r o _ u s u a r i o ' :   m e m b r o ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / c o m i s s a o / s e s s o e s / r e t i r a r _ a s s i n a t u r a _ a t a . h t m l ' ,   c o n t e x t )  
                  
                 #   V e r i f i c a r   s e n h a   d o   u s u Ã ¡ r i o   q u e   e s t Ã ¡   r e t i r a n d o   a   a s s i n a t u r a  
                 i f   n o t   r e q u e s t . u s e r . c h e c k _ p a s s w o r d ( s e n h a ) :  
                         m e s s a g e s . e r r o r ( r e q u e s t ,   ' S e n h a   i n c o r r e t a .   T e n t e   n o v a m e n t e . ' )  
                         c o n t e x t   =   {  
                                 ' s e s s a o ' :   s e s s a o ,  
                                 ' a t a ' :   a t a ,  
                                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                                 ' m e m b r o _ u s u a r i o ' :   m e m b r o ,  
                         }  
                         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / c o m i s s a o / s e s s o e s / r e t i r a r _ a s s i n a t u r a _ a t a . h t m l ' ,   c o n t e x t )  
                  
                 #   E x c l u i r   a   a s s i n a t u r a  
                 a s s i n a t u r a . d e l e t e ( )  
                  
                 m e s s a g e s . s u c c e s s ( r e q u e s t ,   ' â S&   A s s i n a t u r a   r e t i r a d a   c o m   s u c e s s o ! ' )  
                 r e t u r n   r e d i r e c t ( ' m i l i t a r e s : s e s s a o _ c o m i s s a o _ d e t a i l ' ,   p k = s e s s a o . p k )  
          
         c o n t e x t   =   {  
                 ' s e s s a o ' :   s e s s a o ,  
                 ' a t a ' :   a t a ,  
                 ' a s s i n a t u r a ' :   a s s i n a t u r a ,  
                 ' m e m b r o _ u s u a r i o ' :   m e m b r o ,  
         }  
          
         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / c o m i s s a o / s e s s o e s / r e t i r a r _ a s s i n a t u r a _ a t a . h t m l ' ,   c o n t e x t )  
  
  
 @ l o g i n _ r e q u i r e d  
 d e f   q u a d r o _ f i x a c a o _ v a g a s _ v i s u a l i z a r _ h t m l ( r e q u e s t ,   p k ) :  
         " " " V i s u a l i z a r   q u a d r o   d e   f i x a Ã § Ã £ o   d e   v a g a s   e m   H T M L " " "  
         q u a d r o   =   g e t _ o b j e c t _ o r _ 4 0 4 ( Q u a d r o F i x a c a o V a g a s ,   p k = p k )  
          
         c o n t e x t   =   {  
                 ' q u a d r o ' :   q u a d r o ,  
                 ' i t e n s ' :   q u a d r o . i t e m q u a d r o f i x a c a o v a g a s _ s e t . a l l ( ) . o r d e r _ b y ( ' p o s i c a o ' ) ,  
         }  
          
         r e t u r n   r e n d e r ( r e q u e s t ,   ' m i l i t a r e s / q u a d r o _ f i x a c a o _ v a g a s / v i s u a l i z a r _ h t m l . h t m l ' ,   c o n t e x t )  
  
  
 @ l o g i n _ r e q u i r e d  
 d e f   q u a d r o _ f i x a c a o _ v a g a s _ p d f ( r e q u e s t ,   p k ) :  
         " " " G e r a r   P D F   d o   q u a d r o   d e   f i x a Ã § Ã £ o   d e   v a g a s " " "  
         q u a d r o   =   g e t _ o b j e c t _ o r _ 4 0 4 ( Q u a d r o F i x a c a o V a g a s ,   p k = p k )  
          
         #   G e r a r   P D F  
         r e s p o n s e   =   H t t p R e s p o n s e ( c o n t e n t _ t y p e = ' a p p l i c a t i o n / p d f ' )  
         r e s p o n s e [ ' C o n t e n t - D i s p o s i t i o n ' ]   =   f ' a t t a c h m e n t ;   f i l e n a m e = " q u a d r o _ f i x a c a o _ v a g a s _ { q u a d r o . p k } . p d f " '  
          
         #   A q u i   v o c Ã ª   i m p l e m e n t a r i a   a   g e r a Ã § Ã £ o   d o   P D F  
         #   P o r   e n q u a n t o ,   r e t o r n a m o s   u m a   r e s p o s t a   v a z i a  
         r e s p o n s e . w r i t e ( b ' P D F   c o n t e n t   w o u l d   b e   g e n e r a t e d   h e r e ' )  
          
         r e t u r n   r e s p o n s e    
 