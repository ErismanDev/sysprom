from militares.permissoes_simples import (
    requer_edicao_militares, requer_edicao_fichas_conceito,
    requer_gerenciamento_quadros_vagas, requer_gerenciamento_comissoes,
    requer_gerenciamento_usuarios, requer_assinatura_documentos,
    requer_funcao_especial, apenas_visualizacao_comissao
)
# Imports para sistema de permissÃµes
from .permissoes_sistema import (
    requer_perm_militares_visualizar, requer_perm_militares_criar, requer_perm_militares_editar, requer_perm_militares_excluir, requer_perm_militares_admin,
    requer_perm_fichas_visualizar, requer_perm_fichas_criar, requer_perm_fichas_editar, requer_perm_fichas_aprovar, requer_perm_fichas_admin,
    requer_perm_quadros_visualizar, requer_perm_quadros_criar, requer_perm_quadros_editar, requer_perm_quadros_excluir, requer_perm_quadros_admin,
    requer_perm_promocoes_visualizar, requer_perm_promocoes_criar, requer_perm_promocoes_editar, requer_perm_promocoes_aprovar, requer_perm_promocoes_homologar, requer_perm_promocoes_admin,
    requer_perm_vagas_visualizar, requer_perm_vagas_criar, requer_perm_vagas_editar, requer_perm_vagas_excluir, requer_perm_vagas_admin,
    requer_perm_comissao_visualizar, requer_perm_comissao_criar, requer_perm_comissao_editar, requer_perm_comissao_excluir, requer_perm_comissao_assinar, requer_perm_comissao_admin,
    requer_perm_documentos_visualizar, requer_perm_documentos_criar, requer_perm_documentos_editar, requer_perm_documentos_excluir, requer_perm_documentos_gerar_pdf, requer_perm_documentos_imprimir, requer_perm_documentos_assinar, requer_perm_documentos_admin,
    requer_perm_usuarios_visualizar, requer_perm_usuarios_criar, requer_perm_usuarios_editar, requer_perm_usuarios_excluir, requer_perm_usuarios_admin,
    requer_perm_relatorios_visualizar, requer_perm_relatorios_gerar_pdf, requer_perm_relatorios_imprimir, requer_perm_relatorios_admin,
    requer_perm_configuracoes_visualizar, requer_perm_configuracoes_editar, requer_perm_configuracoes_admin,
)



from django.shortcuts import render, get_object_or_404, redirect
from django.core.files.base import ContentFile
from django.contrib import messages
from django.urls import reverse
from django.contrib.auth.decorators import login_required, user_passes_test, permission_required
from django.views.decorators.csrf import csrf_protect
from django.contrib.auth import update_session_auth_hash
from django.core.exceptions import ValidationError
from django.contrib.auth.password_validation import validate_password
from django.core.paginator import Paginator
from django.db.models import Q, Sum, Count, Case, When, IntegerField, Case, When, IntegerField, Case, When, IntegerField, Case, When, IntegerField
from django.db.models.deletion import ProtectedError
from django.http import JsonResponse, HttpResponse
from django.utils import timezone
from datetime import date, datetime
from django.contrib.auth.models import User, Group, Permission
from django.db import models, IntegrityError
from django.conf import settings
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.http import JsonResponse
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import NotificacaoSessao
from django.http import JsonResponse
from django.http import HttpResponse
from django.utils import timezone
from .models import Promocao
from .models import Vaga
from django import forms
from django.http import FileResponse
from django.http import FileResponse
from .models import JustificativaEncerramento
from .models import AtaSessao
from .forms import AtaSessaoForm
from .models import AtaSessao
from .models import AtaSessao, AssinaturaAta
from .models import AtaSessao
from django.http import HttpResponse
from django.utils import timezone
from .models import AtaSessao
from django.utils import timezone
from .models import ModeloAta
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .forms import ModeloAtaForm
from .models import ModeloAta
from .models import ModeloAta
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .models import SessaoComissao, ModeloAta, AtaSessao, MembroComissao
from .forms import ModeloAtaForm
from django import forms
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from .models import NotificacaoSessao
from django.db import models
from django.core.paginator import Paginator
from django.contrib.auth.models import User, Group, Permission
from django.contrib.contenttypes.models import ContentType
from django import forms
# from dal import autocomplete

# Importar views especÃ­ficas para praÃ§as
from .views_pracas_import import *
from .utils import calcular_proxima_data_promocao
from .models import (
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Militar, FichaConceitoOficiais, FichaConceitoPracas, QuadroAcesso, ItemQuadroAcesso, 
    Promocao, Vaga, Curso, MedalhaCondecoracao, Documento, Intersticio,
    POSTO_GRADUACAO_CHOICES, SITUACAO_CHOICES, QUADRO_CHOICES,
    PrevisaoVaga, AssinaturaQuadroAcesso, AssinaturaQuadroFixacaoVagas, ComissaoPromocao, MembroComissao, SessaoComissao, PresencaSessao, DeliberacaoComissao, VotoDeliberacao, DocumentoSessao, AtaSessao, ModeloAta, CargoComissao,
    VagaManual, QuadroFixacaoVagas, ItemQuadroFixacaoVagas, UsuarioFuncao,
    CargoFuncao, PermissaoFuncao, PerfilAcesso, CalendarioPromocao, ItemCalendarioPromocao,
    AssinaturaCalendarioPromocao, AlmanaqueMilitar, AssinaturaAlmanaque
)
from .forms import MilitarForm, DocumentoForm, UserRegistrationForm, ConfirmarSenhaForm, ComissaoPromocaoForm, MembroComissaoForm, SessaoComissaoForm, DeliberacaoComissaoForm, DocumentoSessaoForm, AtaSessaoForm, ModeloAtaForm, CargoComissaoForm, FichaConceitoPracasForm, FichaConceitoOficiaisForm, UsuarioFuncaoForm, UsuarioForm, CargoFuncaoForm
from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito, can_edit_militar
from .admin_decorators import admin_bypass, admin_or_permission_required
from .permissoes_simples import requer_gerenciamento_comissoes
from .permissoes import requer_funcao_ativa
from django import forms
from django.contrib.auth import authenticate
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.units import cm
from reportlab.lib import colors
from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from io import BytesIO
import qrcode
from reportlab.lib.utils import ImageReader
import os
from reportlab.lib.enums import TA_JUSTIFY
import re
from html import unescape
import logging
import unicodedata

@login_required
def teste_modal(request):
    """View temporÃ¡ria para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporÃ¡ria para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporÃ¡ria para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporÃ¡ria para testar modal simples"""
    return render(request, 'teste_modal_simples.html')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PaginaÃ§Ã£o
    itens_por_pagina = request.GET.get('itens_por_pagina', 20)
    try:
        itens_por_pagina = int(itens_por_pagina)
        if itens_por_pagina not in [20, 50, 100]:
            itens_por_pagina = 20
    except (ValueError, TypeError):
        itens_por_pagina = 20
    
    # Converter para lista se necessÃ¡rio
    if hasattr(militares, 'count'):
        # Ã‰ um QuerySet
        militares_list = list(militares)
    else:
        # JÃ¡ Ã© uma lista
        militares_list = militares
    
    paginator = Paginator(militares_list, itens_por_pagina)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': len(militares_list),
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
def militar_detail_pessoal(request):
    """Exibe os detalhes do prÃ³prio militar do usuÃ¡rio logado"""
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Verificar se o usuÃ¡rio tem militar associado
    try:
        militar = request.user.militar
    except Militar.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o possui militar associado.')
        return redirect('militares:militar_dashboard')
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
        'is_own_ficha': True,  # Flag para indicar que Ã© a prÃ³pria ficha
    }
    
    return render(request, 'militares/militar_detail.html', context)


@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    logger.info(f'ğŸ” Busca AJAX recebida: {query}')
    logger.info(f'ğŸ“¡ MÃ©todo da requisiÃ§Ã£o: {request.method}')
    logger.info(f'ğŸ“¡ Headers: {dict(request.headers)}')
    
    if len(query) < 2:
        logger.info('âš ï¸ Query muito curta, retornando vazio')
        return JsonResponse({'results': []})
    
    try:
        # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
        militares = Militar.objects.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query)
        ).exclude(
            posto_graduacao='CB'  # Excluir coronÃ©is
        )[:10]
        
        logger.info(f'âœ… Encontrados {militares.count()} militares')
        
        results = []
        for militar in militares:
            result = {
                'id': militar.id,
                'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
                'nome': militar.nome_completo,
                'matricula': militar.matricula,
                'posto': militar.get_posto_graduacao_display(),
            }
            results.append(result)
            logger.info(f'ğŸ‘¤ Militar encontrado: {result["nome"]} ({result["posto"]})')
        
        logger.info(f'ğŸ“¦ Retornando {len(results)} resultados')
        return JsonResponse({'results': results})
        
    except Exception as e:
        logger.error(f'âŒ Erro na busca AJAX: {str(e)}')
        logger.error(f'âŒ Stack trace: {e.__traceback__}')
        return JsonResponse({'results': [], 'error': str(e)}, status=500)

def buscar_usuarios_ajax(request):
    """Busca usuÃ¡rios via AJAX para autocomplete"""
    import logging
    logger = logging.getLogger(__name__)
    
    query = request.GET.get('q', '')
    comissao_tipo = request.GET.get('comissao_tipo', '')  # CPO ou CPP
    logger.info(f'ğŸ” Busca de usuÃ¡rios AJAX recebida: {query} (comissÃ£o: {comissao_tipo})')
    
    if len(query) < 2:
        logger.info('âš ï¸ Query muito curta, retornando vazio')
        return JsonResponse({'usuarios': []})
    
    try:
        # Buscar usuÃ¡rios que tÃªm militares vinculados e estÃ£o ativos
        usuarios = User.objects.filter(
            militar__isnull=False,  # Apenas usuÃ¡rios com militar vinculado
            militar__situacao='AT',  # Apenas militares ativos
            is_active=True  # Apenas usuÃ¡rios ativos
        ).filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query)
        )
        
        # Filtrar por tipo de comissÃ£o se especificado
        if comissao_tipo == 'CPO':
            # Para CPO: apenas usuÃ¡rios com funÃ§Ãµes CPO
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPO',  # Com funÃ§Ã£o CPO
                funcoes__status='ATIVO'  # FunÃ§Ã£o ativa
            ).distinct()
            
        elif comissao_tipo == 'CPP':
            # Para CPP: apenas usuÃ¡rios com funÃ§Ãµes CPP
            usuarios = usuarios.filter(
                militar__posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS'],  # Apenas oficiais
                funcoes__cargo_funcao__nome__icontains='CPP',  # Com funÃ§Ã£o CPP
                funcoes__status='ATIVO'  # FunÃ§Ã£o ativa
            ).distinct()
        
        usuarios = usuarios.order_by('militar__nome_completo')[:10]
        
        logger.info(f'ğŸ“Š Encontrados {usuarios.count()} usuÃ¡rios')
        
        results = []
        for usuario in usuarios:
            militar = usuario.militar
            
            # Buscar a funÃ§Ã£o especÃ­fica do usuÃ¡rio
            funcao_cpo_cpp = usuario.funcoes.filter(
                status='ATIVO',
                cargo_funcao__nome__icontains=comissao_tipo if comissao_tipo else ''
            ).first()
            
            results.append({
                'id': usuario.id,
                'username': usuario.username,
                'first_name': usuario.first_name,
                'last_name': usuario.last_name,
                'militar': {
                    'id': militar.id,
                    'nome': militar.nome_completo,
                    'posto': militar.get_posto_graduacao_display(),
                    'matricula': militar.matricula,
                },
                'funcao': funcao_cpo_cpp.cargo_funcao.nome if funcao_cpo_cpp else None
            })
        
        logger.info(f'âœ… Retornando {len(results)} resultados')
        return JsonResponse({'usuarios': results})
        
    except Exception as e:
        logger.error(f'âŒ Erro na busca de usuÃ¡rios: {e}')
        return JsonResponse({'usuarios': [], 'error': str(e)})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    
    # Verificar se usuÃ¡rio Ã© do tipo "UsuÃ¡rio" e redirecionar para sua ficha
    is_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO',
        cargo_funcao__nome='UsuÃ¡rio'
    ).exists()
    
    if is_usuario:
        return redirect('militares:redirect_usuario_ficha')
    
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    militares_inativos = total_militares - militares_ativos
    # Contar militares que possuem ficha de conceito (nÃ£o o total de fichas)
    militares_com_ficha = Militar.objects.filter(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    ).distinct().count()
    
    # Contar militares ativos sem ficha de conceito
    militares_sem_ficha = militares_ativos - militares_com_ficha
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    total_quadros = QuadroAcesso.objects.count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # EstatÃ­sticas por posto/graduaÃ§Ã£o
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    ).order_by('posto_graduacao')
    
    # EstatÃ­sticas de documentos por status
    documentos_por_status = Documento.objects.values('status').annotate(
        total=Count('id')
    ).order_by('status')
    
    # Militares aptos a quadro de acesso por posto/graduaÃ§Ã£o
    from datetime import date
    hoje = date.today()
    
    # Buscar militares aptos (com ficha de conceito e interstÃ­cio mÃ­nimo)
    militares_aptos_por_posto = {}
    
    # Definir interstÃ­cios mÃ­nimos por posto (em anos)
    intersticios_minimos = {
        '2T': 2,  # 2Âº Tenente -> 1Âº Tenente
        '1T': 3,  # 1Âº Tenente -> CapitÃ£o
        'CP': 4,  # CapitÃ£o -> Major
        'MJ': 4,  # Major -> Tenente-Coronel
        'TC': 4,  # Tenente-Coronel -> Coronel
        'ST': 3,  # Subtenente -> 1Âº Sargento
        '1S': 3,  # 1Âº Sargento -> 2Âº Sargento
        '2S': 3,  # 2Âº Sargento -> 3Âº Sargento
        '3S': 3,  # 3Âº Sargento -> Cabo
        'CAB': 2, # Cabo -> Soldado
    }
    
    # Buscar militares ativos com ficha de conceito (para cÃ¡lculo de aptos)
    militares_aptos_candidatos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=intersticios_minimos.keys()
    ).filter(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    ).distinct()
    
    # Verificar aptidÃ£o por interstÃ­cio
    for militar in militares_aptos_candidatos:
        posto = militar.posto_graduacao
        if posto in intersticios_minimos:
            # Calcular anos no posto atual
            anos_no_posto = (hoje - militar.data_promocao_atual).days / 365.25
            
            if anos_no_posto >= intersticios_minimos[posto]:
                if posto not in militares_aptos_por_posto:
                    militares_aptos_por_posto[posto] = 0
                militares_aptos_por_posto[posto] += 1
    
    # Ordenar por hierarquia
    hierarquia = ['2T', '1T', 'CP', 'MJ', 'TC', 'ST', '1S', '2S', '3S', 'CAB']
    militares_aptos_ordenados = []
    total_aptos = 0
    for posto in hierarquia:
        if posto in militares_aptos_por_posto:
            militares_aptos_ordenados.append({
                'posto': posto,
                'total': militares_aptos_por_posto[posto]
            })
            total_aptos += militares_aptos_por_posto[posto]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'militares_inativos': militares_inativos,
        'militares_com_ficha': militares_com_ficha,
        'militares_sem_ficha': militares_sem_ficha,
        'documentos_pendentes': documentos_pendentes,
        'total_quadros': total_quadros,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto,
        'documentos_por_status': documentos_por_status,
        'militares_aptos_por_posto': militares_aptos_ordenados,
        'total_aptos_quadro': total_aptos,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required

@login_required
def teste_modal(request):
    """View temporÃ¡ria para testar modais Bootstrap"""
    return render(request, 'teste_bootstrap_modal.html')

@login_required
def teste_ficha_conceito_modal(request):
    """View temporÃ¡ria para testar modal da ficha de conceito"""
    return render(request, 'teste_ficha_conceito_modal.html')

@login_required
def teste_modal_debug(request):
    """View temporÃ¡ria para testar debug do modal"""
    return render(request, 'teste_modal_debug.html')

@login_required
def teste_modal_simples(request):
    """View temporÃ¡ria para testar modal simples"""
    return render(request, 'teste_modal_simples.html')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÃ‡ÃƒO OBRIGATÃ“RIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # PadrÃ£o mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginaÃ§Ã£o


        total_militares = militares.count()


        


        # Aplicar paginaÃ§Ã£o


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
        oficiais_com_ficha = fichas
        oficiais_sem_ficha = []
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        # Buscar oficiais com ficha
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        
        # Buscar oficiais sem ficha
        oficiais_sem_ficha = oficiais.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        
        # Ordenar fichas existentes
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        
        # Ordenar oficiais sem ficha
        oficiais_sem_ficha_list = list(oficiais_sem_ficha)
        oficiais_sem_ficha_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
            x.nome_completo                                    # Depois por nome
        ))
        
        oficiais_com_ficha = fichas_list
        oficiais_sem_ficha = oficiais_sem_ficha_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
    }
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
    # SuperusuÃ¡rios e staff tÃªm acesso total
    if request.user.is_superuser or request.user.is_staff:
        quadros = QuadroAcesso.objects.all()
    else:
        # PermissÃ£o especial para funÃ§Ãµes administrativas
        cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes', 'Administrador do Sistema', 'Administrador']
        funcoes_ativas = request.user.funcoes.filter(
            cargo_funcao__nome__in=cargos_especiais,
            status='ATIVO',
        )
        if funcoes_ativas.exists():
            quadros = QuadroAcesso.objects.all()
        else:
            # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
            membros_comissao = MembroComissao.objects.filter(
                usuario=request.user,
                ativo=True,
                comissao__status='ATIVA'
            )
            if membros_comissao.exists():
                tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
                tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
                if tem_cpo and tem_cpp:
                    quadros = QuadroAcesso.objects.all()
                elif tem_cpo:
                    quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
                elif tem_cpp:
                    quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
                else:
                    quadros = QuadroAcesso.objects.none()
            else:
                quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÃ‡ÃƒO OBRIGATÃ“RIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # PadrÃ£o mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginaÃ§Ã£o


        total_militares = militares.count()


        


        # Aplicar paginaÃ§Ã£o


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # PermissÃ£o especial para Diretor de GestÃ£o de Pessoas ou Chefe da SeÃ§Ã£o de PromoÃ§Ãµes
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }

            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # LÃ³gica especial para o quadro ID 312 - forÃ§ar exibiÃ§Ã£o da transiÃ§Ã£o Major â†’ Tenente-Coronel
    if quadro.id == 312:
        # Criar transiÃ§Ã£o especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transiÃ§Ã£o especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        categoria = request.POST.get('categoria', 'OFICIAIS')
        
        # Log para debug
        print(f"DEBUG - Tipo: {tipo}")
        print(f"DEBUG - Categoria: {categoria}")
        print(f"DEBUG - Data: {data_promocao}")
        print(f"DEBUG - Todos os POST data: {request.POST}")
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Verificar se jÃ¡ existe um quadro para este tipo, data e categoria
        quadros_existentes = QuadroAcesso.objects.filter(
            tipo=tipo,
            data_promocao=data_promocao,
            categoria=categoria
        ).order_by('data_criacao')
        
        # Determinar se Ã© um aditamento
        is_aditamento = quadros_existentes.exists()
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            print(f"DEBUG - Criando quadro com categoria: {categoria}")
            print(f"DEBUG - Ã‰ aditamento: {is_aditamento}")
            
            # Determinar o nÃºmero do aditamento se for um aditamento
            numero_aditamento = None
            if is_aditamento:
                # Contar quantos aditamentos jÃ¡ existem
                numero_aditamento = quadros_existentes.count() + 1
                print(f"DEBUG - NÃºmero do aditamento: {numero_aditamento}")
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Se for aditamento, forÃ§ar a geraÃ§Ã£o do nÃºmero com aditamento
            if is_aditamento and numero_aditamento:
                # Gerar o nÃºmero base
                ano = data_promocao.year
                mes = data_promocao.month
                dia = data_promocao.day
                tipo_prefixo = 'OF' if categoria == 'OFICIAIS' else 'PR'
                
                # Prefixo do quadro
                if tipo == 'ANTIGUIDADE':
                    quadro_prefixo = 'QAA'
                elif tipo == 'MERECIMENTO':
                    quadro_prefixo = 'QAM'
                else:
                    quadro_prefixo = 'QAA'
                
                base_numero = f"{quadro_prefixo}-{tipo_prefixo}-{ano:04d}/{mes:02d}/{dia:02d}"
                
                # Se for o primeiro quadro (nÃ£o aditamento), usar -01
                if numero_aditamento == 1:
                    novo_quadro.numero = f"{base_numero} - 01"
                else:
                    # Se for aditamento, usar -a01, -a02, etc.
                    novo_quadro.numero = f"{base_numero} - a{numero_aditamento:02d}"
                
                novo_quadro.save()
                print(f"DEBUG - NÃºmero gerado para aditamento: {novo_quadro.numero}")
            
            # --- SEGURANÃ‡A EXTRA: Remover assinaturas Ã³rfÃ£s e antigas ---
            from militares.models import AssinaturaQuadroAcesso, QuadroAcesso
            # Remove assinaturas Ã³rfÃ£s (sem quadro)
            AssinaturaQuadroAcesso.objects.filter(quadro_acesso__isnull=True).delete()
            # Remove assinaturas associadas a quadros antigos com a mesma data, tipo e categoria
            quadros_antigos = QuadroAcesso.objects.filter(
                data_promocao=data_promocao,
                tipo=tipo,
                categoria=categoria
            ).exclude(pk=novo_quadro.pk)
            AssinaturaQuadroAcesso.objects.filter(quadro_acesso__in=quadros_antigos).delete()
            # --- FIM DA SEGURANÃ‡A EXTRA ---
            
            print(f"DEBUG - Quadro criado com ID: {novo_quadro.pk}, categoria: {novo_quadro.categoria}")
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                
                # Redirecionar para a view correta baseada na categoria
                print(f"DEBUG - Redirecionando para categoria: {novo_quadro.categoria}")
                if novo_quadro.categoria == 'PRACAS':
                    print(f"DEBUG - Redirecionando para praÃ§as: quadro_acesso_pracas_detail")
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    print(f"DEBUG - Redirecionando para oficiais: quadro_acesso_detail")
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado (apenas para usuÃ¡rios nÃ£o administradores)
        if quadro.status == 'HOMOLOGADO' and not request.user.is_superuser:
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Apenas administradores podem excluir quadros homologados.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        if quadro.status == 'HOMOLOGADO':
            messages.success(request, 'Quadro de acesso homologado excluÃ­do com sucesso pelo administrador!')
        else:
            messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

@login_required
def quadro_acesso_pdf(request, pk):
    """Gera PDF do quadro de acesso no modelo institucional solicitado"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "COMISSÃƒO DE PROMOÃ‡Ã•ES DE OFICIAIS - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    tipo_quadro = quadro.get_tipo_display().upper()
    # O get_tipo_display() jÃ¡ retorna "QUADRO DE ACESSO POR ANTIGUIDADE" ou "QUADRO DE ACESSO POR MERECIMENTO"
    # EntÃ£o usamos diretamente o valor retornado
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio com data em portuguÃªs
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Definir tipo e sigla do quadro
    if quadro.tipo == 'ANTIGUIDADE':
        tipo_quadro = 'por Antiguidade'
        sigla_quadro = 'QAA'
    elif quadro.tipo == 'MERECIMENTO':
        tipo_quadro = 'por Merecimento'
        sigla_quadro = 'QAM'
    else:
        tipo_quadro = 'Manual'
        sigla_quadro = 'QAM'
    
    # Definir texto introdutÃ³rio baseado no tipo de quadro
    if quadro.tipo == 'MERECIMENTO':
        texto_intro = (
            f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
            f"que visa Ã s promoÃ§Ãµes do dia {data_formatada}, tudo com fulcro no parÃ¡grafo Ãºnico do art. 6Âº c/c o Â§ 2Â° do art. 20 da Lei nÂ° 5.462, de 30 de junho de 2005 "
            "c/c o art. 10 da Lei 7.772 de 04 de abril de 2022."
        )
    else:
        texto_intro = (
            f"Fica organizado o Quadro de Acesso {tipo_quadro} ({sigla_quadro}) "
            f"que visa Ã s promoÃ§Ãµes do dia {data_formatada}, com fulcro nos artigos 12, 13, c/c Â§ 3Âº do Art. 20, da Lei nÂº 5.461, de 30 de junho de 2005, "
            "alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
        )
    story.append(Paragraph(texto_intro, style_just))
    story.append(Spacer(1, 13))

    # Definir todos os quadros
    quadros_info = [
        {
            'numero': 1,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMBATENTES (QOBM/Comb.)',
            'codigo': 'COMB'
        },
        {
            'numero': 2,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES DE SAÃšDE (QOBM/S)',
            'codigo': 'SAUDE'
        },
        {
            'numero': 3,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES ENGENHEIROS (QOBM/E)',
            'codigo': 'ENG'
        },
        {
            'numero': 4,
            'nome': 'QUADRO DE OFICIAIS BOMBEIROS MILITARES COMPLEMENTARES (QOBM/C)',
            'codigo': 'COMP'
        }
    ]

    # Definir transiÃ§Ãµes especÃ­ficas por quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB, MJâ†’TC, CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Processar cada quadro
    for i, quadro_info in enumerate(quadros_info):
        # Adicionar espaÃ§amento entre quadros (exceto no primeiro)
        if i > 0:
            story.append(Spacer(1, 16))
        
        story.append(Paragraph(f'<b>{quadro_info["numero"]}. {quadro_info["nome"]}</b>', style_center))
        story.append(Spacer(1, 13))

        # Processar cada transiÃ§Ã£o de posto especÃ­fica do quadro
        transicoes_do_quadro = transicoes_por_quadro.get(quadro_info['codigo'], [])
        
        # Ordenar transiÃ§Ãµes para garantir ordem correta
        if quadro_info['codigo'] == 'COMB':
            # Para Combatente: TCâ†’CB, MJâ†’TC, CPâ†’MJ (ordem hierÃ¡rquica)
            transicoes_ordenadas = []
            # Primeiro, adicionar TCâ†’CB (mais alto)
            for transicao in transicoes_do_quadro:
                if transicao['origem'] == 'TC' and transicao['destino'] == 'CB':
                    transicoes_ordenadas.insert(0, transicao)
                else:
                    transicoes_ordenadas.append(transicao)
            # Reordenar para garantir MJâ†’TC antes de CPâ†’MJ
            final_ordenadas = []
            for transicao in transicoes_ordenadas:
                if transicao['origem'] == 'MJ' and transicao['destino'] == 'TC':
                    final_ordenadas.insert(1, transicao)  # ApÃ³s TCâ†’CB
                else:
                    final_ordenadas.append(transicao)
            transicoes_do_quadro = final_ordenadas
        else:
            # Para outros quadros: MJâ†’TC, CPâ†’MJ (ordem hierÃ¡rquica)
            transicoes_ordenadas = []
            for transicao in transicoes_do_quadro:
                if transicao['origem'] == 'MJ' and transicao['destino'] == 'TC':
                    transicoes_ordenadas.insert(0, transicao)
                else:
                    transicoes_ordenadas.append(transicao)
            transicoes_do_quadro = transicoes_ordenadas
        for transicao in transicoes_do_quadro:
            story.append(Spacer(1, 13))
            story.append(Paragraph(f'<b>{transicao["numero"]} â€“ {transicao["titulo"]}</b>', style_bold))
            story.append(Spacer(1, 13))
            
            # Buscar militares aptos para esta transiÃ§Ã£o neste quadro especÃ­fico
            todos_militares = quadro.itemquadroacesso_set.all()
            
            # Filtrar por quadro especÃ­fico
            if quadro_info['codigo'] == 'COMB':
                # Quadro Combatente - incluir apenas militares do quadro COMB
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='COMB'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'SAUDE':
                # Quadro SaÃºde - incluir apenas militares do quadro SAUDE
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='SAUDE'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'ENG':
                # Quadro Engenheiro - incluir apenas militares do quadro ENG
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem'],
                    militar__quadro='ENG'
                ).order_by('posicao')
            elif quadro_info['codigo'] == 'COMP':
                # Quadro Complementar - incluir militares do quadro COMP
                # Para transiÃ§Ã£o ST->2T, incluir subtenentes do quadro PRACAS
                if transicao['origem'] == 'ST' and transicao['destino'] == '2T':
                    aptos = todos_militares.filter(
                        militar__posto_graduacao=transicao['origem'],
                        militar__quadro='PRACAS'
                    ).order_by('posicao')
                else:
                    aptos = todos_militares.filter(
                        militar__posto_graduacao=transicao['origem'],
                        militar__quadro='COMP'
                    ).order_by('posicao')
            else:
                # Fallback - usar filtro genÃ©rico
                aptos = todos_militares.filter(
                    militar__posto_graduacao=transicao['origem']
                ).order_by('posicao')
            
            if aptos.exists():
                # Preparar dados da tabela
                from .utils import criptografar_cpf_lgpd
                if quadro.tipo == 'MERECIMENTO':
                    header_data = [['ORD', 'CPF', 'POSTO', 'NOME', 'PONTUAÃ‡ÃƒO']]
                    for idx, item in enumerate(aptos, 1):
                        header_data.append([
                            str(idx),
                            criptografar_cpf_lgpd(item.militar.cpf),
                            item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                            item.militar.nome_completo,
                            f"{item.pontuacao:.2f}" if item.pontuacao else "-"
                        ])
                    # Calcular larguras das colunas baseado no conteÃºdo
                    max_ord = max([len(str(row[0])) for row in header_data])
                    max_cpf = max([len(row[1]) for row in header_data])
                    max_posto = max([len(row[2]) for row in header_data])
                    max_pontuacao = max([len(row[4]) for row in header_data])
                    
                    # Definir larguras mÃ­nimas e ajustÃ¡veis
                    col_widths = [
                        max(1.2*cm, max_ord * 0.3*cm),  # ORD
                        max(3*cm, max_cpf * 0.3*cm),    # CPF
                        max(3*cm, max_posto * 0.3*cm),  # POSTO
                        6*cm,  # NOME (reduzido para dar espaÃ§o Ã  pontuaÃ§Ã£o)
                        max(2*cm, max_pontuacao * 0.3*cm)  # PONTUAÃ‡ÃƒO
                    ]
                else:
                    header_data = [['ORD', 'CPF', 'POSTO', 'NOME']]
                    for idx, item in enumerate(aptos, 1):
                        header_data.append([
                            str(idx),
                            criptografar_cpf_lgpd(item.militar.cpf),
                            item.militar.get_posto_graduacao_display() if hasattr(item.militar, 'get_posto_graduacao_display') else item.militar.posto_graduacao,
                            item.militar.nome_completo
                        ])
                    # Calcular larguras das colunas baseado no conteÃºdo
                    max_ord = max([len(str(row[0])) for row in header_data])
                    max_cpf = max([len(row[1]) for row in header_data])
                    max_posto = max([len(row[2]) for row in header_data])
                    
                    # Definir larguras mÃ­nimas e ajustÃ¡veis
                    col_widths = [
                        max(1.2*cm, max_ord * 0.3*cm),  # ORD
                        max(3*cm, max_cpf * 0.3*cm),    # CPF
                        max(3*cm, max_posto * 0.3*cm),  # POSTO
                        8*cm  # NOME (fixo)
                    ]
                table = Table(header_data, colWidths=col_widths)
                # Aplicar estilo diferente baseado no tipo de quadro
                if quadro.tipo == 'MERECIMENTO':
                    table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                        ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                        ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                        ('ALIGN', (4, 1), (4, -1), 'CENTER'),  # Alinhar coluna de pontuaÃ§Ã£o ao centro
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ]))
                else:
                    table.setStyle(TableStyle([
                        ('ALIGN', (0, 0), (-1, 0), 'CENTER'),
                        ('ALIGN', (0, 1), (2, -1), 'CENTER'),
                        ('ALIGN', (3, 1), (3, -1), 'LEFT'),
                        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                        ('FONTSIZE', (0, 0), (-1, -1), 9),
                        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
                        ('GRID', (0, 0), (-1, -1), 1, colors.black),
                        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                    ]))
                story.append(table)
            else:
                # Mostrar mensagem padrÃ£o institucional quando nÃ£o hÃ¡ militares
                if quadro.tipo == 'MERECIMENTO':
                    # Converter sigla do posto para nome completo
                    posto_nomes = {
                        'CB': 'CORONEL',
                        'TC': 'TENENTE-CORONEL', 
                        'MJ': 'MAJOR',
                        'CP': 'CAPITÃƒO',
                        '1T': '1Âº TENENTE',
                        '2T': '2Âº TENENTE',
                        'AS': 'ASPIRANTE A OFICIAL',
                        'AA': 'ALUNO DE ADAPTAÃ‡ÃƒO',
                        'ST': 'SUBTENENTE'
                    }
                    nome_posto = posto_nomes.get(transicao['destino'], transicao['destino'])
                    mensagem = (
                        f"Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de {nome_posto} em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
                    )
                else:
                    # Converter sigla do posto para nome completo
                    posto_nomes = {
                        'CB': 'CORONEL',
                        'TC': 'TENENTE-CORONEL', 
                        'MJ': 'MAJOR',
                        'CP': 'CAPITÃƒO',
                        '1T': '1Âº TENENTE',
                        '2T': '2Âº TENENTE',
                        'AS': 'ASPIRANTE A OFICIAL',
                        'AA': 'ALUNO DE ADAPTAÃ‡ÃƒO',
                        'ST': 'SUBTENENTE'
                    }
                    nome_posto = posto_nomes.get(transicao['destino'], transicao['destino'])
                    mensagem = (
                        f"Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de {nome_posto} em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022."
                    )
                
                story.append(Paragraph(mensagem, style_just))

    # Data e local por extenso, centralizado
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    # Buscar a primeira assinatura eletrÃ´nica para usar sua data
    primeira_assinatura = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('data_assinatura').first()
    if primeira_assinatura:
        data_assinatura = primeira_assinatura.data_assinatura
        data_extenso = f"Teresina - PI, {data_assinatura.day} de {meses_pt[data_assinatura.month]} de {data_assinatura.year}"
    else:
        # Se nÃ£o houver assinatura, usar a data do quadro
        data_extenso = f"Teresina - PI, {quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # SeÃ§Ã£o de Assinaturas FÃ­sicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas vÃ¡lidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo nÃ£o registrado"
        
        # Exibir no formato fÃ­sico: Nome - Posto BM (negrito), FunÃ§Ã£o (normal), Tipo (negrito menor)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Paragraph(f"<b>{tipo}</b>", style_center))
        story.append(Spacer(1, 13))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))
    
    # Processar assinaturas eletrÃ´nicas
    for i, assinatura in enumerate(assinaturas):
        # InformaÃ§Ãµes de assinatura eletrÃ´nica
        nome_assinante = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        # Se o nome estiver vazio, usar um nome padrÃ£o
        if not nome_assinante or nome_assinante.strip() == '':
            nome_assinante = "UsuÃ¡rio do Sistema"
        
        # Se o usuÃ¡rio tem militar associado, incluir posto com BM
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_assinante = f"{posto} {militar.nome_completo}"
        
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
        
        # Adicionar logo do CBMEPI
        logo_path = os.path.join(settings.STATIC_ROOT, 'logo_cbmepi.png')
        if not os.path.exists(logo_path):
            logo_path = os.path.join(settings.STATICFILES_DIRS[0], 'logo_cbmepi.png') if settings.STATICFILES_DIRS else os.path.join(settings.BASE_DIR, 'static', 'logo_cbmepi.png')
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
        if i < len(assinaturas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # Se nÃ£o houver assinaturas, mostrar mensagem
    if not assinaturas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))

    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a funÃ§Ã£o utilitÃ¡ria para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(quadro, request, tipo_documento='quadro')
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),

    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualizaÃ§Ã£o em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'quadro_acesso_{quadro.pk}.pdf')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')

    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = 'hierarquia_antiguidade'
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # Para Subtenentes, ordenar primeiro os que tÃªm CHO, depois os que nÃ£o tÃªm
        # Cada grupo de Subtenentes (com CHO e sem CHO) terÃ¡ sua prÃ³pria numeraÃ§Ã£o de antiguidade
        # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para Subtenentes (ST), ordenar por CHO primeiro (True vem antes de False)
            (x.posto_graduacao == 'ST' and not x.curso_cho, x.posto_graduacao == 'ST' and x.curso_cho),
            x.numeracao_antiguidade or 999999,  # Militares sem antiguidade vÃ£o para o final
            x.nome_completo
        ))
        
        # Reordenar numeraÃ§Ã£o de antiguidade para Subtenentes separadamente por CHO
        if militares:
            # Separar Subtenentes dos outros postos
            subtenentes = [m for m in militares if m.posto_graduacao == 'ST']
            outros_militares = [m for m in militares if m.posto_graduacao != 'ST']
            
            if subtenentes:
                # Separar Subtenentes com CHO e sem CHO
                subtenentes_com_cho = [m for m in subtenentes if m.curso_cho]
                subtenentes_sem_cho = [m for m in subtenentes if not m.curso_cho]
                
                # Reordenar numeraÃ§Ã£o para Subtenentes com CHO
                for i, militar in enumerate(subtenentes_com_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reordenar numeraÃ§Ã£o para Subtenentes sem CHO
                for i, militar in enumerate(subtenentes_sem_cho, 1):
                    militar.numeracao_antiguidade = i
                    militar.save(update_fields=['numeracao_antiguidade'])
                
                # Reconstruir a lista com Subtenentes reordenados
                militares = outros_militares + subtenentes_com_cho + subtenentes_sem_cho
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        militares = militares.order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÃ‡ÃƒO OBRIGATÃ“RIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # PadrÃ£o mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginaÃ§Ã£o


        total_militares = militares.count()


        


        # Aplicar paginaÃ§Ã£o


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    # Filtrar militares excluindo coronÃ©is (Ãºltimo posto)
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    ).exclude(
        posto_graduacao='CB'  # Excluir coronÃ©is
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    fichas_pendentes = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'fichas_pendentes': fichas_pendentes,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'ultimas_fichas': ultimas_fichas,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    oficiais_sem_ficha = total_oficiais_ativos - total_fichas_oficiais
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # PermissÃ£o especial para Diretor de GestÃ£o de Pessoas ou Chefe da SeÃ§Ã£o de PromoÃ§Ãµes
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }

            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # LÃ³gica especial para o quadro ID 312 - forÃ§ar exibiÃ§Ã£o da transiÃ§Ã£o Major â†’ Tenente-Coronel
    if quadro.id == 312:
        # Criar transiÃ§Ã£o especial de Major para Tenente-Coronel para todos os quadros
        transicao_especial = {
            'numero': 'I',
            'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
            'origem': 'MJ',
            'destino': 'TC',
            'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
        }
        # Adicionar a transiÃ§Ã£o especial em todos os quadros
        for q in quadros:
            if q in transicoes_por_quadro:
                transicoes_por_quadro[q].insert(0, transicao_especial)
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validaÃ§Ã£o que bloqueava quadros para a mesma data/tipo
        # (permitir mÃºltiplos quadros na mesma data)
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        # Para quadros de oficiais, verificar se Ã© presidente da CPO
        comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
        if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
            return redirect('militares:quadro_acesso_list')
    else:
        # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
        comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
        if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
            return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        if senha:
            user = authenticate(username=request.user.username, password=senha)
            if user is not None:
                if quadro.status == 'ELABORADO':
                    quadro.status = 'HOMOLOGADO'
                    quadro.data_homologacao = timezone.now().date()
                    quadro.homologado_por = request.user
                    quadro.save()
                    messages.success(request, 'Quadro de acesso homologado com sucesso!')
                    return redirect('militares:quadro_acesso_list')
                else:
                    messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
                    return redirect('militares:quadro_acesso_list')
            else:
                messages.error(request, 'Senha incorreta. Tente novamente.')
                return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

    buffer.seek(0)
    return FileResponse(buffer, as_attachment=True, filename=f'quadro_acesso_{quadro.pk}.pdf')

@login_required
@requer_perm_militares_visualizar
def militar_list(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o e busca"""
    militares = Militar.objects.filter(situacao='AT')
    
    # Busca
    query = request.GET.get('q')
    if query:
        militares = militares.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query) |
            Q(cpf__icontains=query) |
            Q(email__icontains=query)
        )
    
    # Filtros
    posto = request.GET.get('posto')
    if posto:
        # Mapear os valores do frontend para os cÃ³digos do banco
        posto_mapping = {
            'cb': 'CB',
            'tc': 'TC', 
            'mj': 'MJ',
            'cp': 'CP',
            '1t': '1T',
            '2t': '2T',
            'st': 'ST',
            '1s': '1S',
            '2s': '2S',
            '3s': '3S',
            'cab': 'CAB',
            'sd': 'SD',
            'nvrr': 'NVRR'
        }
        posto_codigo = posto_mapping.get(posto.lower())
        if posto_codigo:
            militares = militares.filter(posto_graduacao=posto_codigo)
    
    situacao = request.GET.get('situacao')
    if situacao:
        situacao_mapping = {
            'at': 'AT',
            'in': 'IN'
        }
        situacao_codigo = situacao_mapping.get(situacao.lower())
        if situacao_codigo:
            militares = militares.filter(situacao=situacao_codigo)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # OrdenaÃ§Ã£o padrÃ£o por hierarquia e antiguidade
    ordenacao = request.GET.get('ordenacao', 'hierarquia_antiguidade')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,  # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
        'NVRR': 15,  # NVRR - tratado separadamente
    }
    
    if ordenacao == 'hierarquia_antiguidade':
        # Ordenar por hierarquia de postos e depois por antiguidade
        # NVRR Ã© tratado separadamente - sem numeraÃ§Ã£o de antiguidade
        # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
            hierarquia_postos.get(x.posto_graduacao, 999),
            # Para NVRR, nÃ£o usar numeraÃ§Ã£o de antiguidade
            0 if (x.posto_graduacao == 'NVRR' or x.quadro == 'NVRR') else (x.numeracao_antiguidade or 999999),
            x.nome_completo
        ))
    elif ordenacao == 'posto':
        militares = militares.order_by('posto_graduacao', 'nome_completo')
    elif ordenacao == 'matricula':
        militares = militares.order_by('matricula')
    elif ordenacao == 'data_ingresso':
        militares = militares.order_by('data_ingresso')
    elif ordenacao == 'numeracao_antiguidade':
        # Excluir militares do NVRR da ordenaÃ§Ã£o por antiguidade
        militares = militares.exclude(quadro='NVRR').exclude(posto_graduacao='NVRR').order_by('numeracao_antiguidade', 'nome_completo')
    elif ordenacao == 'pontuacao':
        militares = militares.annotate(
            pontuacao_total=Sum('fichaconceitooficiais__pontos') + Sum('fichaconceitopracas__pontos')
        ).order_by('-pontuacao_total')
    else:
        militares = militares.order_by('nome_completo')

    # PAGINAÃ‡ÃƒO OBRIGATÃ“RIA para evitar timeout


        itens_por_pagina = request.GET.get('itens_por_pagina', 50)


        try:


            itens_por_pagina = int(itens_por_pagina)


            if itens_por_pagina not in [20, 50, 100]:


                itens_por_pagina = 50  # PadrÃ£o mais conservador


        except (ValueError, TypeError):


            itens_por_pagina = 50


        


        # Contar total antes da paginaÃ§Ã£o


        total_militares = militares.count()


        


        # Aplicar paginaÃ§Ã£o


        paginator = Paginator(militares, itens_por_pagina)


        page_number = request.GET.get('page')


        page_obj = paginator.get_page(page_number)


        


        context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': total_militares,
    }
    
    return render(request, 'militares/militar_list.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_detail(request, pk):
    """Exibe os detalhes de um militar"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Busca ficha de conceito
    fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
    fichas_pracas = list(militar.fichaconceitopracas_set.all())
    ficha_conceito = fichas_oficiais + fichas_pracas
    ficha_conceito.sort(key=lambda x: x.data_registro, reverse=True)
    
    # Busca promoÃ§Ãµes
    promocoes = militar.promocao_set.all().order_by('-data_promocao')
    
    # Busca documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'ficha_conceito': ficha_conceito,
        'promocoes': promocoes,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_detail.html', context)

@login_required
@admin_bypass
def militar_create(request):
    """Cria um novo militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para cadastrar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem cadastrar.')
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES)
        if form.is_valid():
            militar = form.save(commit=False)
            
            # Se for NVRR, garantir que nÃ£o tenha numeraÃ§Ã£o de antiguidade
            if militar.quadro == 'NVRR' or militar.posto_graduacao == 'NVRR':
                militar.numeracao_antiguidade = None
            
            militar.save()
            messages.success(request, f'Militar {militar.nome_completo} cadastrado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao cadastrar militar. Verifique os dados.')
    else:
        form = MilitarForm()
    
    context = {
        'form': form,
        'title': 'Novo Militar',
        'action': 'create',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_update(request, pk):
    """Atualiza um militar existente"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        form = MilitarForm(request.POST, request.FILES, instance=militar)
        if form.is_valid():
            # Capturar a numeraÃ§Ã£o anterior antes de salvar
            numeracao_anterior = militar.numeracao_antiguidade
            
            # Salvar o militar
            militar = form.save(commit=False)
            
            # Se for NVRR, garantir que nÃ£o tenha numeraÃ§Ã£o de antiguidade
            if militar.quadro == 'NVRR' or militar.posto_graduacao == 'NVRR':
                militar.numeracao_antiguidade = None
            
            militar.save()
            
            # Se a numeraÃ§Ã£o de antiguidade foi alterada, reordenar automaticamente
            if numeracao_anterior != militar.numeracao_antiguidade and militar.numeracao_antiguidade is not None:
                try:
                    militares_reordenados = militar.reordenar_numeracoes_apos_alteracao(numeracao_anterior)
                    if militares_reordenados and militares_reordenados > 0:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso! {militares_reordenados} militares foram reordenados automaticamente.')
                    else:
                        messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                except Exception as e:
                    messages.warning(request, f'Militar atualizado, mas houve um erro na reordenaÃ§Ã£o automÃ¡tica: {str(e)}')
            else:
                messages.success(request, f'Militar {militar.nome_completo} atualizado com sucesso!')
                return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Erro ao atualizar militar. Verifique os dados.')
    else:
        form = MilitarForm(instance=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'title': 'Editar Militar',
        'action': 'update',
        'today': timezone.now().date().isoformat(),
    }
    
    return render(request, 'militares/militar_form.html', context)

@login_required
@admin_bypass
def militar_delete(request, pk):
    """Remove um militar"""
    # Verificar permissÃ£o
    if not can_edit_militar(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir militares. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem excluir.')
        return redirect('militares:militar_list')
    
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nome = militar.nome_completo
        militar.delete()
        messages.success(request, f'Militar {nome} removido com sucesso!')
        return redirect('militares:militar_list')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_confirm_delete.html', context)

def militar_search_ajax(request):
    """Busca militares via AJAX para autocomplete"""
    query = request.GET.get('q', '')
    if len(query) < 2:
        return JsonResponse({'results': []})
    
    militares = Militar.objects.filter(
        Q(nome_completo__icontains=query) |
        Q(nome_guerra__icontains=query) |
        Q(matricula__icontains=query)
    )[:10]
    
    results = []
    for militar in militares:
        results.append({
            'id': militar.id,
            'text': f"{militar.get_posto_graduacao_display()} {militar.nome_completo} - {militar.matricula}",
            'nome': militar.nome_completo,
            'matricula': militar.matricula,
            'posto': militar.get_posto_graduacao_display(),
            'cpf': militar.cpf,
        })
    
    return JsonResponse({'results': results})

@login_required
def militar_dashboard(request):
    """Dashboard principal do sistema"""
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    militares_inativos = total_militares - militares_ativos
    
    # EstatÃ­sticas detalhadas por posto/graduaÃ§Ã£o
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    )
    
    # Definir hierarquia para ordenaÃ§Ã£o
    hierarquia_posto = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
        'AL': 15,  # Aluno
    }
    
    # Ordenar estatÃ­sticas por hierarquia
    estatisticas_posto_list = list(estatisticas_posto)
    estatisticas_posto_list.sort(key=lambda x: hierarquia_posto.get(x['posto_graduacao'], 999))
    
    # Manter contadores gerais para compatibilidade
    oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    pracas_ativas = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['1S', '2S', '3S', 'CB', 'SD', 'AL']
    ).count()
    
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Ãšltimas fichas de conceito
    fichas_oficiais = list(FichaConceitoOficiais.objects.select_related('militar').order_by('-data_registro')[:5])
    fichas_pracas = list(FichaConceitoPracas.objects.select_related('militar').order_by('-data_registro')[:5])
    ultimas_fichas = fichas_oficiais + fichas_pracas
    ultimas_fichas.sort(key=lambda x: x.data_registro, reverse=True)
    ultimas_fichas = ultimas_fichas[:5]
    
    # Documentos recentes
    documentos_recentes = Documento.objects.select_related('militar').order_by('-data_upload')[:5]
    
    # Quadros de acesso recentes
    quadros_recentes = QuadroAcesso.objects.all().order_by('-data_criacao')[:5]
    
    # NotificaÃ§Ãµes do usuÃ¡rio
    notificacoes_base = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    ).order_by('-prioridade', '-data_criacao')
    
    # Contadores de notificaÃ§Ãµes (antes do slice)
    total_notificacoes = notificacoes_base.count()
    notificacoes_urgentes = notificacoes_base.filter(prioridade='URGENTE').count()
    notificacoes_altas = notificacoes_base.filter(prioridade='ALTA').count()
    
    # Aplicar slice apenas para exibiÃ§Ã£o
    notificacoes = notificacoes_base[:10]
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_posto = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
        'AL': 15,  # Aluno
    }
    
    # EstatÃ­sticas por gÃªnero - Posto/GraduaÃ§Ã£o
    estatisticas_genero_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao', 'sexo').annotate(
        total=Count('id')
    ).order_by('posto_graduacao', 'sexo')
    
    # Ordenar por hierarquia
    estatisticas_genero_posto_list = list(estatisticas_genero_posto)
    estatisticas_genero_posto_list.sort(key=lambda x: hierarquia_posto.get(x['posto_graduacao'], 999))
    
    # EstatÃ­sticas por gÃªnero - Quadro
    estatisticas_genero_quadro = Militar.objects.filter(situacao='AT').values('quadro', 'sexo').annotate(
        total=Count('id')
    ).order_by('quadro', 'sexo')
    
    # Totais por gÃªnero
    total_homens = Militar.objects.filter(situacao='AT', sexo='M').count()
    total_mulheres = Militar.objects.filter(situacao='AT', sexo='F').count()
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'militares_inativos': militares_inativos,
        'oficiais_ativos': oficiais_ativos,
        'pracas_ativas': pracas_ativas,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto_list,
        'estatisticas_genero_posto': estatisticas_genero_posto_list,
        'estatisticas_genero_quadro': estatisticas_genero_quadro,
        'total_homens': total_homens,
        'total_mulheres': total_mulheres,
        'documentos_recentes': documentos_recentes,
        'quadros_recentes': quadros_recentes,
        'notificacoes': notificacoes,
        'total_notificacoes': total_notificacoes,
        'notificacoes_urgentes': notificacoes_urgentes,
        'notificacoes_altas': notificacoes_altas,
    }
    
    return render(request, 'militares/dashboard.html', context)

# Views para Ficha de Conceito
@login_required
@apenas_visualizacao_comissao
def ficha_conceito_list(request):
    """Lista ficha de conceito de oficiais"""
    militar_id = request.GET.get('militar')
    if militar_id:
        militar = get_object_or_404(Militar, pk=militar_id)
        fichas_oficiais = list(militar.fichaconceitooficiais_set.all())
        fichas_pracas = list(militar.fichaconceitopracas_set.all())
        fichas = fichas_oficiais + fichas_pracas
        fichas.sort(key=lambda x: x.data_registro, reverse=True)
    else:
        militar = None
        # Filtrar apenas oficiais (CB, TC, MJ, CP, 1T, 2T, AS, AA)
        oficiais = Militar.objects.filter(
            situacao='AT',
            posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
        )
        fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
        hierarquia_oficiais = {
            'CB': 1,   # Coronel
            'TC': 2,   # Tenente Coronel
            'MJ': 3,   # Major
            'CP': 4,   # CapitÃ£o
            '1T': 5,   # 1Âº Tenente
            '2T': 6,   # 2Âº Tenente
            'AS': 7,   # Aspirante a Oficial
            'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        }
        fichas_list = list(fichas)
        fichas_list.sort(key=lambda x: (
            hierarquia_oficiais.get(x.militar.posto_graduacao, 999),  # Primeiro por hierarquia
            x.militar.nome_completo                                    # Depois por nome
        ))
        fichas = fichas_list
    
    # EstatÃ­sticas para mostrar no template (apenas oficiais)
    total_oficiais_ativos = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).count()
    total_fichas_oficiais = len(fichas)
    
    # Buscar oficiais sem ficha
    oficiais_sem_ficha = Militar.objects.filter(
        situacao='AT',
        posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ).exclude(
        Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
    )
    
    # Ordenar oficiais sem ficha por hierarquia
    hierarquia_oficiais = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
    }
    
    oficiais_sem_ficha_list = list(oficiais_sem_ficha)
    oficiais_sem_ficha_list.sort(key=lambda x: (
        hierarquia_oficiais.get(x.posto_graduacao, 999),  # Primeiro por hierarquia
        x.nome_completo                                    # Depois por nome
    ))
    
    # Montar lista final: primeiro os sem ficha, depois os com ficha
    fichas_final = oficiais_sem_ficha_list + fichas

    context = {
        'militar': militar,
        'fichas': fichas_final,
        'total_oficiais_ativos': total_oficiais_ativos,
        'total_fichas_oficiais': total_fichas_oficiais,
        'oficiais_sem_ficha': oficiais_sem_ficha_list,
        'oficiais_com_ficha': fichas,
        'is_oficiais': True,
}
    return render(request, 'militares/ficha_conceito_list.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_create(request):
    """Cria nova ficha de conceito"""
    if request.method == 'POST':
        # Determinar qual formulÃ¡rio usar baseado no tipo de militar
        militar_id = request.POST.get('militar')
        if militar_id:
            militar = Militar.objects.get(id=militar_id)
            if militar.is_oficial():
                form = FichaConceitoOficiaisForm(request.POST)
            else:
                form = FichaConceitoPracasForm(request.POST)
        else:
            # FormulÃ¡rio padrÃ£o para oficiais
            form = FichaConceitoOficiaisForm(request.POST)
        
        if form.is_valid():
            ficha = form.save()
            messages.success(request, f'Ficha de conceito registrada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        # FormulÃ¡rio padrÃ£o para oficiais
        form = FichaConceitoOficiaisForm()
    
    context = {
        'form': form,
        'title': 'Nova Ficha de Conceito',
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_detail.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_delete(request, pk):
    """Excluir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        ficha.delete()
        messages.success(request, 'Ficha de conceito excluÃ­da com sucesso!')
        return redirect('militares:ficha_conceito_list')
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_confirm_delete.html', context)

@login_required
def documento_upload(request, ficha_pk):
    """Faz upload de documentos para uma ficha de conceito"""
    ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.ficha_conceito = ficha
            documento.save()
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:ficha_conceito_detail', pk=ficha_pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoForm()
    
    context = {
        'form': form,
        'ficha': ficha,
    }
    
    return render(request, 'militares/documento_upload.html', context)

# Views para Quadros de Acesso
@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_list(request):
    """Lista todos os quadros de acesso"""
        # PermissÃ£o especial para Diretor de GestÃ£o de Pessoas ou Chefe da SeÃ§Ã£o de PromoÃ§Ãµes
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists():
        quadros = QuadroAcesso.objects.all()
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroAcesso.objects.all()
            elif tem_cpo:
                quadros = QuadroAcesso.objects.filter(categoria='OFICIAIS')
            elif tem_cpp:
                quadros = QuadroAcesso.objects.filter(categoria='PRACAS')
            else:
                quadros = QuadroAcesso.objects.none()
        else:
            quadros = QuadroAcesso.objects.none()
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        quadros = quadros.filter(tipo=tipo)
    
    status = request.GET.get('status')
    if status:
        quadros = quadros.filter(status=status)
    
    # OrdenaÃ§Ã£o
    ordenacao = request.GET.get('ordenacao', '-data_criacao')
    quadros = quadros.order_by(ordenacao)
    
    # Adicionar quantidade de militares para cada quadro
    for quadro in quadros:
        quadro.total_militares_count = quadro.total_militares()
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    if request.GET.get('ajax') == '1':
        import json
        
        # Preparar dados para JSON
        quadros_data = []
        for quadro in quadros:
            quadros_data.append({
                'id': quadro.id,
                'tipo': quadro.tipo,
                'get_tipo_display': quadro.get_tipo_display(),
                'data_promocao': quadro.data_promocao.strftime('%d/%m/%Y'),
                'status': quadro.status,
                'get_status_display': quadro.get_status_display(),
                'total_militares': quadro.total_militares(),
                'motivo_nao_elaboracao': quadro.motivo_nao_elaboracao,
                'get_motivo_display_completo': quadro.get_motivo_display_completo() if quadro.motivo_nao_elaboracao else None,
            })
        
        return JsonResponse({
            'quadros': quadros_data,
            'total': len(quadros_data)
        })
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    homologados = quadros.filter(status='HOMOLOGADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'quadros': quadros,
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'status_choices': QuadroAcesso.STATUS_CHOICES,
        'filtros': {
            'tipo': tipo,
            'status': status,
            'ordenacao': ordenacao
        },
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'homologados': homologados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/quadro_acesso_list.html', context)

@login_required
@requer_perm_quadros_visualizar
def quadro_acesso_detail(request, pk):
    """Exibe detalhes de um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    militares_inaptos = quadro.militares_inaptos_com_motivo()

    nomes_postos = dict(QuadroAcesso.POSTO_CHOICES)
    nomes_quadros = dict(QuadroAcesso.QUADRO_CHOICES)
    
    # Definir ordem dos quadros e transiÃ§Ãµes (do mais graduado ao menos graduado)
    quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    
    # Verificar se Ã© um quadro de praÃ§as
    if quadro.tipo == 'PRACAS':
        # Para quadros de praÃ§as: transiÃ§Ãµes especÃ­ficas para praÃ§as
        quadros = ['PRACAS']
        transicoes_por_quadro = {
            'PRACAS': [  # PraÃ§as
                {
                    'numero': 'I',
                    'titulo': '1Âº SARGENTO para o posto de SUBTENENTE',
                    'origem': '1S',
                    'destino': 'ST',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Subtenente em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': '2Âº SARGENTO para o posto de 1Âº SARGENTO',
                    'origem': '2S',
                    'destino': '1S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '3Âº SARGENTO para o posto de 2Âº SARGENTO',
                    'origem': '3S',
                    'destino': '2S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': 'CABO para o posto de 3Âº SARGENTO',
                    'origem': 'CAB',
                    'destino': '3S',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 3Âº Sargento em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SOLDADO para o posto de CABO',
                    'origem': 'SD',
                    'destino': 'CAB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Cabo em virtude de nÃ£o haver praÃ§a que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    elif quadro.tipo == 'MERECIMENTO':
        # Para quadros de merecimento: transiÃ§Ãµes especÃ­ficas conforme regras
        transicoes_por_quadro = {
            'COMB': [  # Combatente - inclui TCâ†’CB
                {
                    'numero': 'I',
                    'titulo': 'TENENTE-CORONEL para o posto de CORONEL',
                    'origem': 'TC',
                    'destino': 'CB',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar - apenas MJâ†’TC e CPâ†’MJ
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Merecimento para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    else:
        # Para quadros de antiguidade: todas as transiÃ§Ãµes por antiguidade
        transicoes_por_quadro = {
            'COMB': [  # Combatente
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ASPIRANTE A OFICIAL para o posto de 2Âº TENENTE',
                    'origem': 'AS',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'SAUDE': [  # SaÃºde
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'ENG': [  # Engenheiro
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'ALUNO DE ADAPTAÃ‡ÃƒO para o posto de 2Âº TENENTE',
                    'origem': 'AA',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ],
            'COMP': [  # Complementar
                {
                    'numero': 'I',
                    'titulo': 'MAJOR para o posto de TENENTE-CORONEL',
                    'origem': 'MJ',
                    'destino': 'TC',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Tenente-Coronel em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'II',
                    'titulo': 'CAPITÃƒO para o posto de MAJOR',
                    'origem': 'CP',
                    'destino': 'MJ',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de Major em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'III',
                    'titulo': '1Âº TENENTE para o posto de CAPITÃƒO',
                    'origem': '1T',
                    'destino': 'CP',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de CapitÃ£o em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'IV',
                    'titulo': '2Âº TENENTE para o posto de 1Âº TENENTE',
                    'origem': '2T',
                    'destino': '1T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 1Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                },
                {
                    'numero': 'V',
                    'titulo': 'SUBTENENTE para o posto de 2Âº TENENTE',
                    'origem': 'ST',
                    'destino': '2T',
                    'texto': 'Deixa de ser elaborado o Quadro de Acesso por Antiguidade para o posto de 2Âº Tenente em virtude de nÃ£o haver oficial que satisfaÃ§a os requisitos essenciais para ingresso ao Quadro de acesso, nos termos do <b>art. 12</b> da Lei nÂº 5.461, de 30 de junho de 2005, alterada pela Lei NÂº 7.772, de 04 de abril de 2022.'
                }
            ]
        }
    
    # Buscar todos os militares aptos do quadro
    militares_aptos = quadro.itemquadroacesso_set.all().select_related('militar').order_by('posicao')
    
    # Organizar militares por quadro e transiÃ§Ã£o
    estrutura_quadros = {}
    for q in quadros:
        estrutura_quadros[q] = {
            'nome': nomes_quadros.get(q, q),
            'transicoes': []
        }
        transicoes_do_quadro = transicoes_por_quadro.get(q, [])
        for transicao in transicoes_do_quadro:
            origem = transicao['origem']
            destino = transicao['destino']
            # Filtrar apenas subtenentes do quadro PRACAS para a transiÃ§Ã£o ST->2T do COMP
            if q == 'COMP' and origem == 'ST' and destino == '2T':
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == 'PRACAS' and item.militar.posto_graduacao == 'ST'
                ]
            else:
                militares_desta_transicao = [
                    item for item in militares_aptos 
                    if item.militar.quadro == q and item.militar.posto_graduacao == origem
                ]
            estrutura_quadros[q]['transicoes'].append({
                'origem': origem,
                'destino': destino,
                'origem_nome': nomes_postos.get(origem, origem),
                'destino_nome': nomes_postos.get(destino, destino),
                'militares': militares_desta_transicao,
            })
    
    context = {
        'quadro': quadro,
        'militares_inaptos': militares_inaptos,
        'total_inaptos': len(militares_inaptos),
        'estrutura_quadros': estrutura_quadros,
    }
    
    # Garantir exibiÃ§Ã£o da transiÃ§Ã£o MJâ†’TC em todos os quadros de acesso
    for q in estrutura_quadros:
        transicoes = estrutura_quadros[q]['transicoes']
        existe = any(
            t['origem'] == 'MJ' and t['destino'] == 'TC'
            for t in transicoes
        )
        if not existe:
            # Buscar militares Major do quadro correspondente
            militares_mj_tc = [
                item for item in militares_aptos 
                if item.militar.quadro == q and item.militar.posto_graduacao == 'MJ'
            ]
            estrutura_quadros[q]['transicoes'].insert(0, {
                'origem': 'MJ',
                'destino': 'TC',
                'origem_nome': nomes_postos.get('MJ', 'MJ'),
                'destino_nome': nomes_postos.get('TC', 'TC'),
                'militares': militares_mj_tc,
            })
    
    return render(request, 'militares/quadro_acesso_detail.html', context)

@login_required
def gerar_quadro_acesso(request):
    """Gera um quadro de acesso Ãºnico por tipo e data, incluindo todos os postos"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        
        if not tipo:
            messages.error(request, 'O tipo de acesso Ã© obrigatÃ³rio.')
            return redirect('militares:gerar_quadro_acesso')
        
        # Se nÃ£o foi fornecida uma data, usar a data automÃ¡tica
        if not data_promocao:
            # Determinar o tipo baseado no quadro (OFICIAIS ou PRACAS)
            quadro_tipo = request.POST.get('quadro', 'OFICIAIS')
            data_promocao = calcular_proxima_data_promocao(tipo=quadro_tipo)
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:gerar_quadro_acesso')
        
        # Removida a validaÃ§Ã£o que bloqueava quadros para a mesma data/tipo
        # (permitir mÃºltiplos quadros na mesma data)
        
        # Criar um Ãºnico quadro que representarÃ¡ todos os postos
        try:
            # Obter a categoria selecionada
            categoria = request.POST.get('categoria', 'OFICIAIS')
            
            novo_quadro = QuadroAcesso.objects.create(
                tipo=tipo,
                categoria=categoria,
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                observacoes=f"Quadro de {tipo.lower()} para {categoria.lower()} - {data_promocao.strftime('%d/%m/%Y')} - Inclui todos os postos"
            )
            
            # Gerar o quadro com todos os postos
            sucesso, mensagem = novo_quadro.gerar_quadro_completo()
            
            if sucesso:
                if data_automatica:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
                else:
                    messages.success(request, f'Quadro de {novo_quadro.get_tipo_display().lower()} criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
                messages.success(request, mensagem)
                # Redirecionar para a view correta baseada na categoria
                if novo_quadro.categoria == 'PRACAS':
                    return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
                else:
                    return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            else:
                novo_quadro.delete()
                messages.error(request, f'Erro ao criar quadro: {mensagem}')
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:gerar_quadro_acesso')
    
    context = {
        'tipos': QuadroAcesso.TIPO_CHOICES,
        'categorias': [
            ('OFICIAIS', 'Oficiais'),
            ('PRACAS', 'PraÃ§as')
        ],
        'categoria_selecionada': request.POST.get('categoria', 'OFICIAIS') if request.method == 'POST' else 'OFICIAIS',
        'quadros_recentes': QuadroAcesso.objects.all().order_by('-data_criacao')[:10],
        'proxima_data_automatica': calcular_proxima_data_promocao(tipo='OFICIAIS'),
    }
    
    return render(request, 'militares/gerar_quadro_acesso.html', context)

@login_required
def regerar_quadro_acesso(request, pk):
    """Regera um quadro de acesso existente"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        sucesso, mensagem = quadro.gerar_quadro_automatico()
        
        if sucesso:
            messages.success(request, mensagem)
        else:
            messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def delete_quadro_acesso(request, pk):
    """Exclui um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        # Verificar se o quadro estÃ¡ homologado
        if quadro.status == 'HOMOLOGADO':
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir um quadro homologado. Deshomologize primeiro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Excluir todos os itens do quadro primeiro
        quadro.itemquadroacesso_set.all().delete()
        # Excluir o quadro
        quadro.delete()
        
        messages.success(request, 'Quadro de acesso excluÃ­do com sucesso!')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_confirm_delete.html', context)

@login_required
def adicionar_oficial_quadro_oficiais(request, pk):
    """Adiciona um oficial ao quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, 'Quadro nÃ£o encontrado!')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao')
        
        if not militar_id:
            messages.error(request, 'Militar nÃ£o selecionado!')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se o militar jÃ¡ estÃ¡ no quadro
            if quadro.itemquadroacesso_set.filter(militar=militar).exists():
                messages.error(request, f'O oficial {militar.nome_completo} jÃ¡ estÃ¡ no quadro.')
                return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Adicionar o militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao, pontuacao)
            
            messages.success(request, f'Oficial {militar.nome_completo} adicionado ao quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_oficiais(request, pk, militar_id):
    """Remove um militar do quadro de acesso de oficiais"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_acesso_list')
    
    # Verificar se o quadro Ã© de oficiais
    if quadro.categoria != 'OFICIAIS':
        messages.error(request, 'Este quadro nÃ£o Ã© de oficiais!')
        return redirect('militares:quadro_acesso_list')
    
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'Quadros homologados nÃ£o podem ser editados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se o militar estÃ¡ no quadro
        item = quadro.itemquadroacesso_set.filter(militar=militar).first()
        if not item:
            messages.error(request, f'O oficial {militar.nome_completo} nÃ£o estÃ¡ no quadro.')
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
        
        # Remover o militar
        quadro.remover_militar_manual(militar)
        
        messages.success(request, f'Oficial {militar.nome_completo} removido do quadro com sucesso!')
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
    except ValueError as e:
        messages.error(request, str(e))
    except Exception as e:
        messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_oficiais_elegiveis(request):
    """Busca oficiais elegÃ­veis para promoÃ§Ã£o"""
    if request.method == 'POST':
        form = BuscarOficiaisElegiveisForm(request.POST)
        if form.is_valid():
            data_promocao = form.cleaned_data['data_promocao']
            quadro = form.cleaned_data['quadro']
            posto_graduacao = form.cleaned_data['posto_graduacao']
            
            # Buscar oficiais elegÃ­veis
            oficiais_elegiveis = Militar.objects.oficiais_elegiveis_para_promocao(
                data_promocao=data_promocao,
                quadro=quadro,
                posto_graduacao=posto_graduacao
            )
            
            # Renderizar resultados
            context = {
                'oficiais_elegiveis': oficiais_elegiveis,
                'form': form,
            }
            return render(request, 'militares/buscar_oficiais_elegiveis.html', context)
    else:
        form = BuscarOficiaisElegiveisForm()
    
    context = {
        'form': form,
    }
    return render(request, 'militares/buscar_oficiais_elegiveis.html', context)

@login_required
def homologar_quadro_acesso(request, pk):
    """Homologa um quadro de acesso, solicitando confirmaÃ§Ã£o de senha e funÃ§Ã£o via modal"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        senha = request.POST.get('senha')
        funcao_id = request.POST.get('funcao_homologacao')
        
        # Verificar se a senha foi fornecida
        if not senha:
            messages.error(request, 'Senha Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a funÃ§Ã£o foi selecionada
        if not funcao_id:
            messages.error(request, 'FunÃ§Ã£o Ã© obrigatÃ³ria.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a senha estÃ¡ correta
        user = authenticate(username=request.user.username, password=senha)
        if user is None:
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar se a funÃ§Ã£o existe e pertence ao usuÃ¡rio
        try:
            funcao = UsuarioFuncao.objects.get(id=funcao_id, usuario=request.user)
        except UsuarioFuncao.DoesNotExist:
            messages.error(request, 'FunÃ§Ã£o invÃ¡lida.')
            return redirect('militares:quadro_acesso_list')
        
        # Verificar permissÃ£o de homologaÃ§Ã£o baseada na funÃ§Ã£o selecionada
        if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
            # Para quadros de oficiais, verificar se Ã© presidente da CPO
            comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
            if not comissao_cpo or not comissao_cpo.eh_presidente_por_funcao(request.user, funcao):
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                return redirect('militares:quadro_acesso_list')
        else:
            # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
            comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
            if not comissao_cpp or not comissao_cpp.eh_presidente_por_funcao(request.user, funcao):
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                return redirect('militares:quadro_acesso_list')
        
        # Homologar o quadro
        if quadro.status == 'ELABORADO':
            quadro.status = 'HOMOLOGADO'
            quadro.data_homologacao = timezone.now().date()
            quadro.homologado_por = request.user
            quadro.save()
            messages.success(request, 'Quadro de acesso homologado com sucesso!')
            return redirect('militares:quadro_acesso_list')
        else:
            messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
            return redirect('militares:quadro_acesso_list')

    # Se chegou aqui, redirecionar para a lista
    return redirect('militares:quadro_acesso_list')

@login_required
def deshomologar_quadro_acesso(request, pk):
    """Deshomologa um quadro de acesso (apenas pelo usuÃ¡rio que homologou)"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')

    if request.method == 'POST':
        if quadro.status == 'HOMOLOGADO':
            if quadro.homologado_por and quadro.homologado_por != request.user:
                messages.error(request, 'Apenas o usuÃ¡rio que homologou pode deshomologar este quadro.')
            else:
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.homologado_por = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
        else:
            messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')

    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def elaborar_quadro_acesso(request, pk):
    """Elabora um quadro de acesso nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        if quadro.status == 'NAO_ELABORADO':
            # Usar a lÃ³gica de geraÃ§Ã£o automÃ¡tica
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
        else:
            messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def quadro_acesso_edit(request, pk):
    """Edita um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        action = request.POST.get('action', 'salvar')
        
        if action == 'salvar':
            # EdiÃ§Ã£o bÃ¡sica do quadro
            try:
                data_promocao = request.POST.get('data_promocao')
                if data_promocao:
                    quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                
                status = request.POST.get('status')
                if status:
                    quadro.status = status
                
                motivo_nao_elaboracao = request.POST.get('motivo_nao_elaboracao')
                if motivo_nao_elaboracao:
                    quadro.motivo_nao_elaboracao = motivo_nao_elaboracao
                else:
                    quadro.motivo_nao_elaboracao = None
                
                quadro.observacoes = request.POST.get('observacoes', '')
                quadro.assinaturas.all().delete()
                quadro.save()
                
                messages.success(request, 'Quadro de acesso atualizado com sucesso!')
                
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_acesso_edit', pk=quadro.pk)
        
        elif action == 'regenerar':
            # Regenerar o quadro
            sucesso, mensagem = quadro.gerar_quadro_automatico()
            if sucesso:
                messages.success(request, mensagem)
            else:
                messages.error(request, f'Erro ao regenerar quadro: {mensagem}')
        
        elif action == 'homologar':
            # Verificar permissÃ£o de homologaÃ§Ã£o - apenas presidente da comissÃ£o pode homologar
            if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
                # Para quadros de oficiais, verificar se Ã© presidente da CPO
                comissao_cpo = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
                if not comissao_cpo or not comissao_cpo.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de oficiais. Apenas o presidente da CPO pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            else:
                # Para quadros de praÃ§as, verificar se Ã© presidente da CPP
                comissao_cpp = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
                if not comissao_cpp or not comissao_cpp.eh_presidente(request.user):
                    messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para homologar quadros de praÃ§as. Apenas o presidente da CPP pode homologar.')
                    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
            
            # Homologar o quadro
            if quadro.status == 'ELABORADO':
                quadro.status = 'HOMOLOGADO'
                quadro.data_homologacao = timezone.now().date()
                quadro.homologado_por = request.user
                quadro.save()
                messages.success(request, 'Quadro de acesso homologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros elaborados podem ser homologados.')
        
        elif action == 'deshomologar':
            # Deshomologar o quadro
            if quadro.status == 'HOMOLOGADO':
                quadro.status = 'ELABORADO'
                quadro.data_homologacao = None
                quadro.save()
                messages.success(request, 'Quadro de acesso deshomologado com sucesso!')
            else:
                messages.error(request, 'Apenas quadros homologados podem ser deshomologados.')
        
        elif action == 'elaborar':
            # Elaborar o quadro
            if quadro.status == 'NAO_ELABORADO':
                sucesso, mensagem = quadro.gerar_quadro_automatico()
                if sucesso:
                    messages.success(request, mensagem)
                else:
                    messages.error(request, f'Erro ao elaborar quadro: {mensagem}')
            else:
                messages.error(request, 'Apenas quadros nÃ£o elaborados podem ser elaborados.')
        
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_acesso_edit.html', context)

@login_required
def quadro_acesso_print(request, pk):
    """VersÃ£o para impressÃ£o do quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    context = {
        'quadro': quadro,
        'itens': quadro.itemquadroacesso_set.all().order_by('posicao'),
    }
    
    return render(request, 'militares/quadro_acesso_print.html', context)

@login_required
def marcar_nao_elaborado(request, pk):
    """Marca um quadro como nÃ£o elaborado"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        observacoes = request.POST.get('observacoes', '')
        
        quadro.status = 'NAO_ELABORADO'
        quadro.motivo_nao_elaboracao = motivo
        quadro.observacoes = observacoes
        quadro.save()
        
        # Limpar itens existentes
        quadro.itemquadroacesso_set.all().delete()
        
        messages.success(request, 'Quadro marcado como nÃ£o elaborado.')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

# Views para PromoÃ§Ãµes
@login_required
@requer_perm_promocoes_visualizar
def promocao_list(request):
    """Lista promoÃ§Ãµes"""
    # Filtros
    query = request.GET.get('q', '')
    criterio = request.GET.get('criterio', '')
    data_inicio = request.GET.get('data_inicio', '')
    data_fim = request.GET.get('data_fim', '')
    
    promocoes = Promocao.objects.all()
    
    # Aplicar filtros
    if query:
        promocoes = promocoes.filter(
            Q(militar__nome_completo__icontains=query) |
            Q(militar__nome_guerra__icontains=query) |
            Q(militar__matricula__icontains=query) |
            Q(numero_ato__icontains=query)
        )
    
    if criterio:
        promocoes = promocoes.filter(criterio=criterio)
    
    if data_inicio:
        promocoes = promocoes.filter(data_promocao__gte=data_inicio)
    
    if data_fim:
        promocoes = promocoes.filter(data_promocao__lte=data_fim)
    
    promocoes = promocoes.order_by('-data_promocao')
    
    # EstatÃ­sticas
    total_promocoes = Promocao.objects.count()
    promocoes_este_ano = Promocao.objects.filter(data_promocao__year=timezone.now().year).count()
    militares_promovidos = Promocao.objects.values('militar').distinct().count()
    promocoes_merecimento = Promocao.objects.filter(criterio='MERECIMENTO').count()
    
    # PaginaÃ§Ã£o
    paginator = Paginator(promocoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'promocoes': page_obj,
        'total_promocoes': total_promocoes,
        'promocoes_este_ano': promocoes_este_ano,
        'militares_promovidos': militares_promovidos,
        'promocoes_merecimento': promocoes_merecimento,
    }
    
    return render(request, 'militares/promocao_list.html', context)

@login_required
@requer_perm_promocoes_criar
def promocao_create(request):
    """Registra nova promoÃ§Ã£o"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')  # Novo campo
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        is_historica = request.POST.get('is_historica') == 'on'  # Novo campo
        
        if all([militar_id, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Se nÃ£o foi informado posto anterior, usar o atual do militar
            if not posto_anterior:
                posto_anterior = militar.posto_graduacao
            
            # Cria promoÃ§Ã£o
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            # SÃ³ atualiza o militar se nÃ£o for promoÃ§Ã£o histÃ³rica
            if not is_historica:
                # Capturar dados anteriores antes da promoÃ§Ã£o
                posto_anterior = militar.posto_graduacao
                quadro_anterior = militar.quadro
                
                # Atualizar posto e data de promoÃ§Ã£o
                militar.posto_graduacao = posto_novo
                militar.data_promocao_atual = data_promocao
                
                # Atribuir a prÃ³xima numeraÃ§Ã£o disponÃ­vel no novo posto
                nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
                
                # Reordenar os militares do posto anterior (preencher gap)
                militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
                
                militar.save()
                
                messages.success(
                    request, 
                    f'PromoÃ§Ã£o registrada com sucesso! {militar.nome_completo} recebeu a {nova_numeracao}Âª numeraÃ§Ã£o de antiguidade no posto de {militar.get_posto_graduacao_display()}. {militares_reordenados} militares foram reordenados no posto anterior.'
                )
            
            messages.success(request, f'PromoÃ§Ã£o registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    # Verificar se hÃ¡ um militar prÃ©-selecionado na URL
    militar_pre_selecionado = None
    militar_id = request.GET.get('militar')
    if militar_id:
        try:
            militar_pre_selecionado = Militar.objects.get(pk=militar_id)
        except Militar.DoesNotExist:
            pass
    
    context = {
        'militares': Militar.objects.filter(situacao='AT').order_by('nome_completo'),
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'militar_pre_selecionado': militar_pre_selecionado,
    }
    
    return render(request, 'militares/promocao_form.html', context)

@login_required
def promocao_historica_create(request):
    """Registra promoÃ§Ã£o histÃ³rica (nÃ£o atualiza o militar)"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar')
        posto_anterior = request.POST.get('posto_anterior')
        posto_novo = request.POST.get('posto_novo')
        criterio = request.POST.get('criterio')
        data_promocao = request.POST.get('data_promocao')
        data_publicacao = request.POST.get('data_publicacao')
        numero_ato = request.POST.get('numero_ato')
        observacoes = request.POST.get('observacoes')
        
        if all([militar_id, posto_anterior, posto_novo, criterio, data_promocao]):
            militar = get_object_or_404(Militar, pk=militar_id)
            
            # Cria promoÃ§Ã£o histÃ³rica (nÃ£o atualiza o militar)
            promocao = Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo=posto_novo,
                criterio=criterio,
                data_promocao=data_promocao,
                data_publicacao=data_publicacao or timezone.now().date(),
                numero_ato=numero_ato or f"ATO-HIST-{timezone.now().strftime('%Y%m%d%H%M%S')}",
                observacoes=observacoes
            )
            
            messages.success(request, f'PromoÃ§Ã£o histÃ³rica registrada com sucesso!')
            return redirect('militares:promocao_list')
    
    context = {
        'militares': Militar.objects.all().order_by('nome_completo'),  # Todos os militares, nÃ£o sÃ³ ativos
        'postos': POSTO_GRADUACAO_CHOICES,
        'criterios': Promocao.CRITERIO_CHOICES,
        'today': timezone.now().date().isoformat(),
        'is_historica': True,
    }
    
    return render(request, 'militares/promocao_form.html', context)

@login_required
@requer_perm_promocoes_admin
def promocao_delete(request, pk):
    promocao = get_object_or_404(Promocao, pk=pk)
    if request.method == 'POST':
        promocao.delete()
        messages.success(request, 'PromoÃ§Ã£o excluÃ­da com sucesso!')
        return redirect('militares:promocao_list')
    return render(request, 'militares/promocao_confirm_delete.html', {'promocao': promocao})

# Views para Vagas
@login_required
@requer_perm_vagas_visualizar
def vaga_list(request):
    """Quadro de FixaÃ§Ã£o de Vagas: mostra vagas do sistema separadas por quadro e permite inserir vagas manuais"""
    # Processa o formulÃ¡rio de vaga manual
    if request.method == 'POST':
        if 'vaga_manual' in request.POST:
            posto = request.POST.get('posto')
            quadro = request.POST.get('quadro')
            quantidade = request.POST.get('quantidade')
            justificativa = request.POST.get('justificativa')
            observacoes = request.POST.get('observacoes')
            if posto and quadro and quantidade and justificativa:
                try:
                    quantidade = int(quantidade)
                    if quantidade < 1:
                        quantidade = 1
                except ValueError:
                    quantidade = 1
                VagaManual.objects.create(
                    posto=posto,
                    quadro=quadro,
                    quantidade=quantidade,
                    justificativa=justificativa,
                    observacoes=observacoes or ''
                )
                messages.success(request, 'Vaga manual inserida com sucesso!')
                return redirect('vaga_list')
        
        # Processa atualizaÃ§Ã£o de vagas fixadas
        elif 'atualizar_vagas_fixadas' in request.POST:
            for key, value in request.POST.items():
                if key.startswith('vagas_fixadas_'):
                    # Extrai o ID da previsÃ£o de vaga
                    previsao_id = key.replace('vagas_fixadas_', '')
                    try:
                        previsao = PrevisaoVaga.objects.get(id=previsao_id)
                        vagas_fixadas = int(value) if value else 0
                        previsao.vagas_fixadas = vagas_fixadas
                        
                        # Busca observaÃ§Ãµes correspondentes
                        obs_key = f'observacoes_vagas_fixadas_{previsao_id}'
                        observacoes = request.POST.get(obs_key, '')
                        previsao.observacoes_vagas_fixadas = observacoes
                        
                        previsao.save()
                    except (PrevisaoVaga.DoesNotExist, ValueError):
                        continue
            
            messages.success(request, 'Vagas fixadas atualizadas com sucesso!')
            return redirect('vaga_list')
    
    # Busca previsÃµes de vagas por quadro (oficiais)
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        posto__in=['2T', '1T', 'CP', 'MJ', 'TC', 'CB'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Busca previsÃµes de vagas por quadro (praÃ§as)
    previsoes_pracas = PrevisaoVaga.objects.filter(
        posto__in=['ST', 'SGT', 'CB', 'SD'],
        ativo=True
    ).order_by('quadro', 'posto')
    
    # Organiza por quadro
    vagas_oficiais_por_quadro = {}
    vagas_pracas_por_quadro = {}
    
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_oficiais_por_quadro:
            vagas_oficiais_por_quadro[previsao.quadro] = []
        vagas_oficiais_por_quadro[previsao.quadro].append(previsao)
    
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_pracas_por_quadro:
            vagas_pracas_por_quadro[previsao.quadro] = []
        vagas_pracas_por_quadro[previsao.quadro].append(previsao)
    
    # Busca vagas manuais
    vagas_manuais = VagaManual.objects.all().order_by('-data_solicitacao')
    
    context = {
        'vagas_oficiais_por_quadro': vagas_oficiais_por_quadro,
        'vagas_pracas_por_quadro': vagas_pracas_por_quadro,
        'vagas_manuais': vagas_manuais,
        'quadros': [
            ('COMB', 'Quadro de Oficiais Bombeiros Militares Combatentes - QOBM/Comb.'),
            ('SAUDE', 'Quadro de Oficiais Bombeiros Militares de SaÃºde - QOBM/SaÃºde'),
            ('ENG', 'Quadro de Oficiais Bombeiros Militares Engenheiros - QOBM/Eng.'),
            ('COMP', 'Quadro de Oficiais Bombeiros Militares Complementar - QOBM/Comp.'),
        ]
    }
    
    return render(request, 'militares/vaga_list.html', context)

@login_required
@requer_perm_vagas_editar
def vaga_update(request, pk):
    """Atualiza vaga"""
    vaga = get_object_or_404(Vaga, pk=pk)
    
    if request.method == 'POST':
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        
        if efetivo_atual and efetivo_maximo:
            vaga.efetivo_atual = int(efetivo_atual)
            vaga.efetivo_maximo = int(efetivo_maximo)
            vaga.save()
            
            messages.success(request, f'Vaga atualizada com sucesso!')
            return redirect('militares:vaga_list')
    
    context = {
        'vaga': vaga,
    }
    
    return render(request, 'militares/vaga_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form(request, militar_pk):
    """FormulÃ¡rio de ficha de conceito com upload de documentos - redireciona para view especÃ­fica"""
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se Ã© oficial ou praÃ§a
    postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    is_oficial = militar.posto_graduacao in postos_oficiais
    
    if is_oficial:
        # Se Ã© oficial, usar a view genÃ©rica (que jÃ¡ funciona para oficiais)
        return ficha_conceito_form_oficiais(request, militar_pk)
    else:
        # Se Ã© praÃ§a, redirecionar para a view especÃ­fica de praÃ§as
        from .views_pracas import ficha_conceito_pracas_form
        return ficha_conceito_pracas_form(request, militar_pk)

from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_form_oficiais(request, militar_pk):
    """FormulÃ¡rio de ficha de conceito para oficiais com upload de documentos"""
    # Verificar permissÃ£o
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar fichas de conceito. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    
    militar = get_object_or_404(Militar, pk=militar_pk)
    
    # Verificar se jÃ¡ existe uma ficha para este militar
    ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
    ficha_existente_pracas = militar.fichaconceitopracas_set.first()
    
    if request.method == 'POST':
        if ficha_existente_oficiais:
            # Se jÃ¡ existe ficha de oficiais, atualizar
            form = FichaConceitoOficiaisForm(request.POST, request.FILES, instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se jÃ¡ existe ficha de praÃ§as, atualizar
            form = FichaConceitoPracasForm(request.POST, request.FILES, instance=ficha_existente_pracas, militar=militar)
        else:
            # Se nÃ£o existe, criar nova ficha baseada no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(request.POST, request.FILES, militar=militar)
            else:
                form = FichaConceitoPracasForm(request.POST, request.FILES, militar=militar)
        
        if form.is_valid():
            ficha = form.save(commit=False)
            ficha.militar = militar
            ficha.save()
            
            # Processar documentos se fornecidos
            documentos = request.FILES.getlist('documentos')
            for doc_file in documentos:
                Documento.objects.create(
                    militar=militar,
                    ficha_conceito=ficha,
                    tipo='OUTROS',
                    titulo=f"Documento: {doc_file.name}",
                    arquivo=doc_file
                )
            
            messages.success(request, 'Ficha de conceito salva com sucesso!')
            return redirect('militares:ficha_conceito_list')
        else:
            # Debug: mostrar erros do formulÃ¡rio
            print("Erros do formulÃ¡rio:", form.errors)
            messages.error(request, f'Erro ao salvar ficha de conceito: {form.errors}')
    else:
        if ficha_existente_oficiais:
            # Se jÃ¡ existe ficha de oficiais, carregar dados
            form = FichaConceitoOficiaisForm(instance=ficha_existente_oficiais, militar=militar)
        elif ficha_existente_pracas:
            # Se jÃ¡ existe ficha de praÃ§as, carregar dados
            form = FichaConceitoPracasForm(instance=ficha_existente_pracas, militar=militar)
        else:
            # Se nÃ£o existe, criar formulÃ¡rio vazio baseado no posto
            if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                form = FichaConceitoOficiaisForm(militar=militar)
            else:
                form = FichaConceitoPracasForm(militar=militar)
    
    context = {
        'form': form,
        'militar': militar,
        'ficha': ficha_existente_oficiais or ficha_existente_pracas,
        'documento_form': DocumentoForm(),
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_edit(request, pk):
    """Editar ficha de conceito"""
    # Verificar permissÃ£o
    if not can_edit_ficha_conceito(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar fichas de conceito. Apenas administradores, chefes da seÃ§Ã£o de promoÃ§Ãµes e diretores de gestÃ£o de pessoas podem editar.')
        return redirect('militares:ficha_conceito_list')
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        form_class = FichaConceitoOficiaisForm
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            form_class = FichaConceitoPracasForm
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = form_class(request.POST, instance=ficha, militar=ficha.militar)
        if form.is_valid():
            form.save()
            messages.success(request, 'Ficha de conceito atualizada com sucesso!')
            return redirect('militares:ficha_conceito_list')
    else:
        form = form_class(instance=ficha, militar=ficha.militar)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/ficha_conceito_form.html', context)

@login_required
@apenas_visualizacao_comissao
def ficha_conceito_detail(request, pk):
    """Detalhes da ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    tipo_ficha = None
    
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
        tipo_ficha = 'oficiais'
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
            tipo_ficha = 'pracas'
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    # Calcular pontos detalhados para exibiÃ§Ã£o
    if tipo_ficha == 'oficiais':
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': min(ficha.tempo_posto * 1.0, 5.0),
                'limite': 5.0,
                'descricao': 'Tempo de ServiÃ§o no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao + ficha.cursos_csbm,
                'pontos': min((ficha.cursos_especializacao * 2.5 + ficha.cursos_csbm * 4.0), 5.0),
                'limite': 5.0,
                'descricao': 'ConclusÃ£o de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho + ficha.cursos_cfo +
                         ficha.cursos_cao + ficha.cursos_instrutor_csbm),
                'pontos': min((ficha.cursos_cfsd * 0.5 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.0 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.5 + ficha.cursos_cfo * 1.75 +
                              ficha.cursos_cao * 3.0 + ficha.cursos_instrutor_csbm * 2.5), 10.0),
                'limite': 10.0,
                'descricao': 'Instrutor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_superior + ficha.cursos_civis_especializacao +
                         ficha.cursos_civis_mestrado + ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_superior * 1.5 + ficha.cursos_civis_especializacao * 2.0 +
                          ficha.cursos_civis_mestrado * 3.0 + ficha.cursos_civis_doutorado * 4.0),
                'limite': None,
                'descricao': 'ConclusÃ£o em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.5 + ficha.medalha_estadual * 0.25 +
                              ficha.medalha_cbmepi * 0.25), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e CondecoraÃ§Ãµes'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.25 + ficha.elogio_coletivo * 0.125), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 0.25 + ficha.punicao_detencao * 0.5 +
                           ficha.punicao_prisao * 1.0),
                'limite': None,
                'descricao': 'PuniÃ§Ãµes'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 0.5),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    else:  # praÃ§as
        pontos_detalhados = {
            'tempo_posto': {
                'valor': ficha.tempo_posto,
                'pontos': ficha.tempo_posto * 1.0,
                'limite': None,
                'descricao': 'Tempo de ServiÃ§o no Posto Atual'
            },
            'cursos_militares': {
                'valor': ficha.cursos_especializacao,
                'pontos': min((ficha.cursos_especializacao * 2.0), 4.0),
                'limite': 4.0,
                'descricao': 'ConclusÃ£o de Cursos Militares'
            },
            'instrutor': {
                'valor': (ficha.cursos_cfsd + ficha.cursos_chc + ficha.cursos_chsgt +
                         ficha.cursos_cas + ficha.cursos_cho),
                'pontos': min((ficha.cursos_cfsd * 0.50 + ficha.cursos_chc * 0.75 +
                              ficha.cursos_chsgt * 1.00 + ficha.cursos_cas * 1.25 +
                              ficha.cursos_cho * 1.50), 5.0),
                'limite': 5.0,
                'descricao': 'Monitor em Cursos Militares'
            },
            'cursos_civis': {
                'valor': (ficha.cursos_civis_tecnico + ficha.cursos_civis_superior + 
                         ficha.cursos_civis_especializacao + ficha.cursos_civis_mestrado + 
                         ficha.cursos_civis_doutorado),
                'pontos': (ficha.cursos_civis_tecnico * 1.75 + ficha.cursos_civis_superior * 3.00 +
                          ficha.cursos_civis_especializacao * 4.00 + ficha.cursos_civis_mestrado * 9.00 +
                          ficha.cursos_civis_doutorado * 15.00),
                'limite': None,
                'descricao': 'ConclusÃ£o em Cursos Civis'
            },
            'medalhas': {
                'valor': ficha.medalha_federal + ficha.medalha_estadual + ficha.medalha_cbmepi,
                'pontos': min((ficha.medalha_federal * 0.50 + ficha.medalha_estadual * 0.30 +
                              ficha.medalha_cbmepi * 0.20), 1.0),
                'limite': 1.0,
                'descricao': 'Medalhas e CondecoraÃ§Ãµes'
            },
            'elogios': {
                'valor': ficha.elogio_individual + ficha.elogio_coletivo,
                'pontos': min((ficha.elogio_individual * 0.15 + ficha.elogio_coletivo * 0.10), 0.25), 
                'limite': 0.25,
                'descricao': 'Elogios'
            },
            'punicoes': {
                'valor': ficha.punicao_repreensao + ficha.punicao_detencao + ficha.punicao_prisao,
                'pontos': -(ficha.punicao_repreensao * 1.0 + ficha.punicao_detencao * 2.0 +
                           ficha.punicao_prisao * 5.0),
                'limite': None,
                'descricao': 'PuniÃ§Ãµes'
            },
            'falta_aproveitamento': {
                'valor': ficha.falta_aproveitamento,
                'pontos': -(ficha.falta_aproveitamento * 10.0),
                'limite': None,
                'descricao': 'Falta de Aproveitamento em Cursos Militares'
            }
        }
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
        'pontos_detalhados': pontos_detalhados,
        'total_pontos': ficha.calcular_pontos(),
        'tipo_ficha': tipo_ficha,
    }
    
    response = render(request, 'militares/ficha_conceito_detail.html', context)
    response['Cache-Control'] = 'no-cache, no-store, must-revalidate'
    response['Pragma'] = 'no-cache'
    response['Expires'] = '0'
    return response

@login_required
def documento_upload(request, ficha_pk):
    """Upload de documentos para ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    ficha_tipo = None
    
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=ficha_pk)
        ficha_tipo = 'oficiais'
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=ficha_pk)
            ficha_tipo = 'pracas'
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        form = DocumentoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.militar = ficha.militar
            
            # Atribuir ao campo correto baseado no tipo de ficha
            if ficha_tipo == 'oficiais':
                documento.ficha_conceito_oficiais = ficha
            else:
                documento.ficha_conceito_pracas = ficha
            
            documento.save()
            
            messages.success(request, 'Documento enviado com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    else:
        form = DocumentoForm()
    
    # Buscar documentos relacionados Ã  ficha
    if ficha_tipo == 'oficiais':
        documentos = Documento.objects.filter(ficha_conceito_oficiais=ficha)
    else:
        documentos = Documento.objects.filter(ficha_conceito_pracas=ficha)
    
    context = {
        'form': form,
        'ficha': ficha,
        'militar': ficha.militar,
        'documentos': documentos,
    }
    
    return render(request, 'militares/documento_upload.html', context)

@login_required
def conferir_ficha(request, pk):
    """Conferir ficha de conceito"""
    # Tentar buscar em ambos os modelos
    ficha = None
    try:
        ficha = get_object_or_404(FichaConceitoOficiais, pk=pk)
    except:
        try:
            ficha = get_object_or_404(FichaConceitoPracas, pk=pk)
        except:
            messages.error(request, 'Ficha de conceito nÃ£o encontrada.')
            return redirect('militares:ficha_conceito_list')
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar']:
            # Atualiza apenas as observaÃ§Ãµes, jÃ¡ que nÃ£o hÃ¡ campo status
            ficha.observacoes = observacoes
            ficha.save()
            
            messages.success(request, f'Ficha {acao}da com sucesso!')
            return redirect('militares:militar_detail', pk=ficha.militar.pk)
    
    context = {
        'ficha': ficha,
        'militar': ficha.militar,
    }
    
    return render(request, 'militares/conferir_ficha.html', context)

@login_required
def conferir_documento(request, pk):
    """Conferir documento"""
    documento = get_object_or_404(Documento, pk=pk)
    
    if request.method == 'POST':
        acao = request.POST.get('acao')
        observacoes = request.POST.get('observacoes', '')
        
        if acao in ['aprovar', 'rejeitar', 'arquivar']:
            documento.status = acao.upper()
            documento.conferido_por = request.user
            documento.data_conferencia = timezone.now()
            documento.observacoes = observacoes
            documento.save()
            
            messages.success(request, f'Documento {acao}do com sucesso!')
            return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/conferir_documento.html', context)

@login_required
@requer_perm_promocoes_visualizar
def promocao_detail(request, pk):
    """Detalhes da promoÃ§Ã£o"""
    promocao = get_object_or_404(Promocao, pk=pk)
    
    context = {
        'promocao': promocao,
    }
    
    return render(request, 'militares/promocao_detail.html', context)

@login_required
def estatisticas(request):
    """EstatÃ­sticas do sistema"""
    # EstatÃ­sticas gerais
    total_militares = Militar.objects.count()
    militares_ativos = Militar.objects.filter(situacao='AT').count()
    
    # Por quadro
    estatisticas_quadro = Militar.objects.filter(situacao='AT').values('quadro').annotate(
        total=Count('id')
    ).order_by('quadro')
    
    # Por posto
    estatisticas_posto = Militar.objects.filter(situacao='AT').values('posto_graduacao').annotate(
        total=Count('id')
    ).order_by('posto_graduacao')
    
    # Fichas de conceito
    total_fichas = FichaConceitoOficiais.objects.count() + FichaConceitoPracas.objects.count()
    fichas_aprovadas = 0  # Removido filtro por status que nÃ£o existe
    fichas_pendentes = 0  # Removido filtro por status que nÃ£o existe
    
    # Documentos
    total_documentos = Documento.objects.count()
    documentos_aprovados = Documento.objects.filter(status='APROVADO').count()
    documentos_pendentes = Documento.objects.filter(status='PENDENTE').count()
    
    # EstatÃ­sticas dos quadros de acesso
    total_quadros_acesso = QuadroAcesso.objects.count()
    if total_quadros_acesso > 0:
        estatisticas_quadros_acesso = {
            'total': total_quadros_acesso,
            'elaborados': QuadroAcesso.objects.filter(status='ELABORADO').count(),
            'homologados': QuadroAcesso.objects.filter(status='HOMOLOGADO').count(),
            'nao_elaborados': QuadroAcesso.objects.filter(status='NAO_ELABORADO').count(),
            'em_elaboracao': QuadroAcesso.objects.filter(status='EM_ELABORACAO').count(),
            'militares_aptos': sum([q.itemquadroacesso_set.count() for q in QuadroAcesso.objects.filter(status='ELABORADO')]),
            'status': list(QuadroAcesso.objects.values('status').annotate(total=Count('id'))),
            'tipo': list(QuadroAcesso.objects.values('tipo').annotate(total=Count('id'))),
            'categoria': list(QuadroAcesso.objects.values('categoria').annotate(total=Count('id'))),
        }
    else:
        estatisticas_quadros_acesso = None
    
    context = {
        'total_militares': total_militares,
        'militares_ativos': militares_ativos,
        'estatisticas_quadro': estatisticas_quadro,
        'estatisticas_posto': estatisticas_posto,
        'total_fichas': total_fichas,
        'fichas_aprovadas': fichas_aprovadas,
        'fichas_pendentes': fichas_pendentes,
        'total_documentos': total_documentos,
        'documentos_aprovados': documentos_aprovados,
        'documentos_pendentes': documentos_pendentes,
        'estatisticas_quadros_acesso': estatisticas_quadros_acesso,
    }
    
    return render(request, 'militares/estatisticas.html', context)

def register(request):
    """Registro de usuÃ¡rio"""
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Conta criada com sucesso! FaÃ§a login para continuar.')
            return redirect('login')
    else:
        form = UserRegistrationForm()
    
    return render(request, 'registration/register.html', {'form': form})

def intersticio_list(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar interstÃ­cios ativos
    intersticios = list(Intersticio.objects.filter(ativo=True))
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    return render(request, 'militares/intersticio_list.html', {'intersticios': intersticios_ordenados})

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_manage(request):
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar todos os interstÃ­cios
    intersticios = list(Intersticio.objects.all())
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    intersticios = [i for i in intersticios if i.quadro != 'PRACAS' or i.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    intersticios_ordenados = sorted(intersticios, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for inter in intersticios_ordenados:
            anos = request.POST.get(f'anos_{inter.id}', '').strip()
            meses = request.POST.get(f'meses_{inter.id}', '').strip()
            try:
                inter.tempo_minimo_anos = int(anos) if anos.isdigit() else 0
                inter.tempo_minimo_meses = int(meses) if meses.isdigit() else 0
                inter.save()
            except Exception as e:
                messages.error(request, f'Erro ao salvar {inter}: {e}')
        messages.success(request, 'InterstÃ­cios atualizados com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticios': intersticios_ordenados,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/intersticio_manage.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_create(request):
    """Criar novo interstÃ­cio"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        anos = request.POST.get('novo_anos', '0')
        meses = request.POST.get('novo_meses', '0')
        
        try:
            # Verificar se jÃ¡ existe um interstÃ­cio para este quadro/posto
            if Intersticio.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'JÃ¡ existe um interstÃ­cio para este quadro e posto!')
            else:
                Intersticio.objects.create(
                    quadro=quadro,
                    posto=posto,
                    tempo_minimo_anos=int(anos),
                    tempo_minimo_meses=int(meses),
                    ativo=True
                )
                messages.success(request, 'InterstÃ­cio criado com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar interstÃ­cio: {e}')
    
    return redirect('militares:intersticio_manage')

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def intersticio_delete(request, pk):
    """Excluir interstÃ­cio"""
    intersticio = get_object_or_404(Intersticio, pk=pk)
    
    if request.method == 'POST':
        intersticio.delete()
        messages.success(request, 'InterstÃ­cio excluÃ­do com sucesso!')
        return redirect('militares:intersticio_manage')
    
    context = {
        'intersticio': intersticio,
    }
    
    return render(request, 'militares/intersticio_confirm_delete.html', context)

@login_required
def marcar_cursos_inerentes(request, militar_pk):
    """Marca automaticamente os cursos inerentes ao quadro do militar"""
    if request.method == 'POST':
        militar = get_object_or_404(Militar, pk=militar_pk)
        militar.marcar_cursos_inerentes()
        return JsonResponse({'success': True, 'message': 'Cursos inerentes marcados com sucesso!'})
    return JsonResponse({'success': False, 'message': 'MÃ©todo nÃ£o permitido'}, status=405)

@login_required
def relatorio_requisitos_quadro(request, pk):
    """RelatÃ³rio detalhado dos requisitos dos militares para um quadro de acesso"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    # Buscar militares candidatos para o quadro especÃ­fico
    # Definir postos baseado no tipo de quadro
    if quadro.tipo == 'MERECIMENTO':
        # Para quadro de merecimento: incluir TC apenas para COMB (TCâ†’CB), excluir subtenentes (ST)
        postos = ['2T', '1T', 'CP', 'MJ', 'TC']
    else:
        # Para quadro de antiguidade: incluir todos os postos
        postos = ['ST', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    
    # Buscar militares candidatos baseado no tipo de quadro
    militares_candidatos = []
    
    # Para quadros de merecimento, buscar apenas militares com ficha de conceito
    if quadro.tipo == 'MERECIMENTO':
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        ).filter(
            posto_graduacao__in=postos
        )
    else:
        # Para quadros de antiguidade, buscar todos os militares ativos
        militares_candidatos = Militar.objects.filter(
            situacao='AT'
        ).filter(
            posto_graduacao__in=postos
        )
    
    # Debug: imprimir quantidade de candidatos encontrados
    print(f"DEBUG: Encontrados {len(militares_candidatos)} militares candidatos para o quadro {quadro.tipo}")
    
    relatorio = []
    for militar in militares_candidatos:
        # Validar cada requisito individualmente
        tem_ficha = militar.fichaconceitooficiais_set.exists() or militar.fichaconceitopracas_set.exists()
        
        apto_intersticio = quadro._validar_intersticio_minimo(militar, quadro.data_promocao)
        motivo_intersticio = ""
        if not apto_intersticio:
            motivo_intersticio = "InterstÃ­cio insuficiente atÃ© a data da promoÃ§Ã£o"
        
        apto_saude = quadro._validar_inspecao_saude(militar)
        motivo_saude = ""
        if not apto_saude:
            motivo_saude = "InspeÃ§Ã£o de saÃºde vencida ou nÃ£o realizada"
        
        apto_cursos = quadro._validar_cursos_inerentes(militar)
        motivo_cursos = ""
        if not apto_cursos:
            motivo_cursos = "Cursos inerentes insuficientes para o posto subsequente"
        
        # Status geral
        apto_geral = tem_ficha and apto_intersticio and apto_saude and apto_cursos
        
        relatorio.append({
            'militar': militar,
            'tem_ficha': tem_ficha,
            'apto_intersticio': apto_intersticio,
            'motivo_intersticio': motivo_intersticio,
            'apto_saude': apto_saude,
            'motivo_saude': motivo_saude,
            'apto_cursos': apto_cursos,
            'motivo_cursos': motivo_cursos,
            'apto_geral': apto_geral,
            'tempo_no_posto': militar.tempo_posto_atual(),
            'data_inspecao': militar.data_inspecao_saude,
            'validade_inspecao': militar.data_validade_inspecao_saude,
        })
    
    # Ordenar por status (aptos primeiro) e depois por nome
    relatorio.sort(key=lambda x: (not x['apto_geral'], x['militar'].nome_completo))
    
    context = {
        'quadro': quadro,
        'relatorio': relatorio,
        'total_candidatos': len(relatorio),
        'total_aptos': sum(1 for r in relatorio if r['apto_geral']),
        'total_inaptos': sum(1 for r in relatorio if not r['apto_geral']),
    }
    
    return render(request, 'militares/relatorio_requisitos_quadro.html', context)

@login_required
def test_template(request):
    """View de teste para verificar se o problema persiste"""
    quadros = QuadroAcesso.objects.all()
    
    # Calcular estatÃ­sticas
    total_quadros = quadros.count()
    elaborados = quadros.filter(status='ELABORADO').count()
    nao_elaborados = quadros.filter(status='NAO_ELABORADO').count()
    em_elaboracao = quadros.filter(status='EM_ELABORACAO').count()
    
    context = {
        'estatisticas': {
            'total': total_quadros,
            'elaborados': elaborados,
            'nao_elaborados': nao_elaborados,
            'em_elaboracao': em_elaboracao,
        }
    }
    
    return render(request, 'militares/simple_test.html', context)

class RelatorioAptosPromocaoForm(forms.Form):
    tipo = forms.ChoiceField(choices=[('ANTIGUIDADE', 'Antiguidade'), ('MERECIMENTO', 'Merecimento')], label="Tipo de Quadro de Acesso")
    data_promocao = forms.DateField(label="Data prevista para promoÃ§Ã£o", widget=forms.DateInput(attrs={'type': 'date'}))

@login_required
def relatorio_aptos_promocao(request):
    QUADROS = [
        ('COMB', 'Combatente'),
        ('SAUDE', 'SaÃºde'),
        ('ENG', 'Engenharia'),
        ('COMP', 'Complementar'),
    ]
    POSTOS = [
        ('2T', '2Âº Tenente'),
        ('1T', '1Âº Tenente'),
        ('CP', 'CapitÃ£o'),
        ('MJ', 'Major'),
        ('TC', 'Tenente-Coronel'),
        ('CB', 'Coronel'),
    ]
    relatorio = []
    form = RelatorioAptosPromocaoForm(request.GET or None)
    if form.is_valid():
        tipo = form.cleaned_data['tipo']
        data_promocao = form.cleaned_data['data_promocao']
        for cod_quadro, nome_quadro in QUADROS:
            quadro_data = {'nome': nome_quadro, 'postos': []}
            for cod_posto, nome_posto in POSTOS:
                militares = Militar.objects.filter(
                    quadro=cod_quadro,
                    posto_graduacao=cod_posto,
                    situacao='AT'
                ).filter(
                    Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
                ).distinct()
                aptos = []
                for militar in militares:
                    # Usa as regras jÃ¡ implementadas no modelo QuadroAcesso
                    dummy_quadro = QuadroAcesso(tipo=tipo, categoria='OFICIAIS' if cod_quadro in ['COMB', 'SAUDE', 'ENG', 'COMP'] else 'PRACAS', data_promocao=data_promocao)
                    apto, _ = dummy_quadro.validar_requisitos_quadro_acesso(militar, data_promocao)
                    if apto:
                        aptos.append(militar)
                quadro_data['postos'].append({
                    'nome': nome_posto,
                    'aptos': aptos,
                })
            relatorio.append(quadro_data)
    context = {
        'form': form,
        'relatorio': relatorio,
        'form_submitted': form.is_valid(),
        'tipo': form.cleaned_data['tipo'] if form.is_valid() else None,
        'data_promocao': form.cleaned_data['data_promocao'] if form.is_valid() else None,
    }
    return render(request, 'militares/relatorio_aptos_promocao.html', context)

@login_required
def test_quadro_simple(request):
    """View de teste muito simples para verificar se o problema Ã© especÃ­fico da pÃ¡gina de quadros"""
    return render(request, 'militares/simple_test.html', {
        'estatisticas': {
            'total': 0,
            'elaborados': 0,
            'nao_elaborados': 0,
            'em_elaboracao': 0,
        }
    })

@login_required
def criar_quadro_manual(request):
    """Cria um quadro de acesso manual"""
    if request.method == 'POST':
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not data_promocao:
            messages.error(request, 'A data de promoÃ§Ã£o Ã© obrigatÃ³ria.')
            return redirect('militares:criar_quadro_manual')
        
        try:
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
            return redirect('militares:criar_quadro_manual')
        
        # Verificar se jÃ¡ existe um quadro manual para esta data (permitir mÃºltiplos quadros)
        # quadro_existente = QuadroAcesso.objects.filter(
        #     tipo='MANUAL',
        #     data_promocao=data_promocao
        # ).first()
        
        # if quadro_existente:
        #     messages.warning(request, f'JÃ¡ existe um quadro manual para a data {data_promocao.strftime("%d/%m/%Y")}.')
        #     return redirect('militares:quadro_acesso_detail', pk=quadro_existente.pk)
        
        # Criar o quadro manual
        try:
            novo_quadro = QuadroAcesso.objects.create(
                tipo='MANUAL',
                data_promocao=data_promocao,
                status='EM_ELABORACAO',
                is_manual=True,
                criterio_ordenacao_manual=request.POST.get('criterio_ordenacao', 'MANUAL'),
                observacoes=observacoes or f"Quadro manual para {data_promocao.strftime('%d/%m/%Y')}"
            )
            
            messages.success(request, f'Quadro manual criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            # Redirecionar para a view correta baseada na categoria
            if novo_quadro.categoria == 'PRACAS':
                return redirect('militares:quadro_acesso_pracas_detail', pk=novo_quadro.pk)
            else:
                return redirect('militares:quadro_acesso_detail', pk=novo_quadro.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro manual: {str(e)}')
        
        return redirect('militares:criar_quadro_manual')
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
    }
    
    return render(request, 'militares/criar_quadro_manual.html', context)

@login_required
def adicionar_militar_quadro_manual(request, pk):
    """Adiciona um militar ao quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares adicionados.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        posicao = request.POST.get('posicao')
        pontuacao = request.POST.get('pontuacao', 0)
        
        if not militar_id:
            messages.error(request, 'Selecione um militar.')
            return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Converter posiÃ§Ã£o para inteiro se fornecida
            posicao_int = None
            if posicao:
                try:
                    posicao_int = int(posicao)
                except ValueError:
                    messages.error(request, 'PosiÃ§Ã£o deve ser um nÃºmero inteiro.')
                    return redirect('militares:adicionar_militar_quadro_manual', pk=quadro.pk)
            
            # Converter pontuaÃ§Ã£o para decimal
            try:
                pontuacao_decimal = float(pontuacao)
            except ValueError:
                pontuacao_decimal = 0
            
            # Adicionar militar ao quadro
            quadro.adicionar_militar_manual(militar, posicao_int, pontuacao_decimal)
            
            messages.success(request, f'Militar {militar.nome_completo} adicionado ao quadro com sucesso!')
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao adicionar militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def remover_militar_quadro_manual(request, pk, militar_id):
    """Remove um militar do quadro manual"""
    try:
        quadro = QuadroAcesso.objects.get(pk=pk)
    except QuadroAcesso.DoesNotExist:
        messages.error(request, f'Quadro de acesso com ID {pk} nÃ£o encontrado. O quadro pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        return redirect('militares:quadro_acesso_list')
    
    if not quadro.is_manual:
        messages.error(request, 'Apenas quadros manuais podem ter militares removidos.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        try:
            militar = Militar.objects.get(pk=militar_id)
            quadro.remover_militar_manual(militar)
            messages.success(request, f'Militar {militar.nome_completo} removido do quadro com sucesso!')
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
        except ValueError as e:
            messages.error(request, str(e))
        except Exception as e:
            messages.error(request, f'Erro ao remover militar: {str(e)}')
    
    return redirect('militares:quadro_acesso_detail', pk=quadro.pk)

@login_required
def buscar_militares_ajax(request):
    """Busca militares para adicionar ao quadro manual via AJAX"""
    if request.method == 'GET':
        termo = request.GET.get('termo', '')
        if len(termo) < 2:
            return JsonResponse({'militares': []})
        
        militares = Militar.objects.filter(
            situacao='AT',
            nome_completo__icontains=termo
        ).values('id', 'nome_completo', 'posto_graduacao', 'quadro', 'matricula')[:10]
        
        return JsonResponse({'militares': list(militares)})
    
    return JsonResponse({'militares': []})

@login_required
def buscar_pontuacao_militar(request, militar_id):
    """Retorna a pontuaÃ§Ã£o da ficha de conceito do militar"""
    from militares.models import Militar
    try:
        militar = Militar.objects.get(pk=militar_id)
        ficha = militar.fichaconceitooficiais_set.first() or militar.fichaconceitopracas_set.first()
        pontuacao = ficha.pontos if ficha else 0
        return JsonResponse({'pontuacao': float(pontuacao)})
    except Militar.DoesNotExist:
        return JsonResponse({'pontuacao': 0})

@login_required
def gerar_fichas_conceito_todos(request):
    """Gera fichas de conceito para todos os militares cadastrados que ainda nÃ£o possuem"""
    if request.method == 'POST':
        # Verificar se estÃ¡ sendo chamado da pÃ¡gina de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas oficiais ativos
            militares_ativos = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            tipo_militar = "oficiais"
        else:
            # Buscar todos os militares ativos
            militares_ativos = Militar.objects.filter(situacao='AT')
            tipo_militar = "militares"
        
        # Buscar militares que nÃ£o possuem ficha de conceito
        militares_sem_ficha = militares_ativos.exclude(
            Q(fichaconceitooficiais__isnull=False) | Q(fichaconceitopracas__isnull=False)
        )
        
        fichas_criadas = 0
        militares_processados = 0
        
        for militar in militares_sem_ficha:
            # Verificar se jÃ¡ existe ficha para este militar (dupla verificaÃ§Ã£o)
            ficha_existente_oficiais = militar.fichaconceitooficiais_set.first()
            ficha_existente_pracas = militar.fichaconceitopracas_set.first()
            
            if not ficha_existente_oficiais and not ficha_existente_pracas:
                # Determinar qual tipo de ficha criar baseado no posto
                if militar.posto_graduacao in ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']:
                    # Criar ficha de oficiais
                    ficha = FichaConceitoOficiais.objects.create(
                        militar=militar,
                    )
                else:
                    # Criar ficha de praÃ§as
                    ficha = FichaConceitoPracas.objects.create(
                        militar=militar,
                    )
                fichas_criadas += 1
            
            militares_processados += 1
        
        # Mensagens informativas
        if fichas_criadas > 0:
            messages.success(request, f'âœ… Foram criadas {fichas_criadas} fichas de conceito com tempo de serviÃ§o no posto para {tipo_militar} que nÃ£o possuÃ­am.')
        else:
            messages.info(request, f'â„¹ï¸ Todos os {tipo_militar} ativos jÃ¡ possuem fichas de conceito.')
        
        if militares_processados > 0:
            messages.info(request, f'ğŸ“Š Processados {militares_processados} {tipo_militar} ativos.')
        
        # InformaÃ§Ã£o adicional sobre militares que jÃ¡ tinham fichas
        militares_com_ficha = militares_ativos.count() - militares_sem_ficha.count()
        if militares_com_ficha > 0:
            messages.info(request, f'ğŸ”’ {militares_com_ficha} {tipo_militar} jÃ¡ possuÃ­am fichas de conceito e nÃ£o foram alterados.')
    
    return redirect('militares:ficha_conceito_list')

@login_required
@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def limpar_pontos_fichas_conceito(request):
    """Limpa os pontos das fichas de conceito, mantendo apenas o tempo no posto"""
    if request.method == 'POST':
        # Verificar se estÃ¡ sendo chamado da pÃ¡gina de oficiais
        is_oficiais = request.POST.get('is_oficiais', False)
        
        if is_oficiais:
            # Filtrar apenas fichas de oficiais
            oficiais = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
            )
            fichas = FichaConceitoOficiais.objects.filter(militar__in=oficiais)
            tipo_militar = "oficiais"
        else:
            # Buscar todas as fichas de conceito
            fichas_oficiais = FichaConceitoOficiais.objects.all()
            fichas_pracas = FichaConceitoPracas.objects.all()
            fichas = list(fichas_oficiais) + list(fichas_pracas)
            tipo_militar = "militares"
        
        fichas_limpas = 0
        
        for ficha in fichas:
            # Salvar o tempo no posto atual
            tempo_posto_atual = ficha.militar.tempo_posto_atual()
            
            # Atualizar diretamente no banco para evitar chamar o mÃ©todo save()
            if isinstance(ficha, FichaConceitoOficiais):
                FichaConceitoOficiais.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            else:
                FichaConceitoPracas.objects.filter(pk=ficha.pk).update(
                    # Limpar todos os campos de pontos
                    cursos_especializacao=0,
                    cursos_csbm=0,
                    cursos_cfsd=0,
                    cursos_chc=0,
                    cursos_chsgt=0,
                    cursos_cas=0,
                    cursos_cho=0,
                    cursos_cfo=0,
                    cursos_cao=0,
                    cursos_instrutor_csbm=0,
                    cursos_civis_superior=0,
                    cursos_civis_especializacao=0,
                    cursos_civis_mestrado=0,
                    cursos_civis_doutorado=0,
                    medalha_federal=0,
                    medalha_estadual=0,
                    medalha_cbmepi=0,
                    elogio_individual=0,
                    elogio_coletivo=0,
                    punicao_repreensao=0,
                    punicao_detencao=0,
                    punicao_prisao=0,
                    falta_aproveitamento=0,
                    # Atualizar o tempo no posto para o valor atual
                    tempo_posto=tempo_posto_atual,
                    # Recalcular os pontos (apenas tempo no posto)
                    pontos=tempo_posto_atual * 1.0,  # 1.0 ponto por ano no posto
                )
            fichas_limpas += 1
        
        if fichas_limpas > 0:
            messages.success(request, f'âœ… Foram limpas {fichas_limpas} fichas de conceito de {tipo_militar}. Apenas o tempo no posto foi mantido.')
        else:
            messages.info(request, f'â„¹ï¸ Nenhuma ficha de conceito de {tipo_militar} encontrada para limpeza.')
    
    return redirect('militares:ficha_conceito_list')

@login_required
@requer_perm_vagas_criar
def vaga_create(request):
    """Cria uma nova vaga"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        efetivo_atual = request.POST.get('efetivo_atual')
        efetivo_maximo = request.POST.get('efetivo_maximo')
        if posto and quadro and efetivo_maximo:
            vaga = Vaga(
                posto=posto,
                quadro=quadro,
                efetivo_atual=efetivo_atual or 0,
                efetivo_maximo=efetivo_maximo
            )
            vaga.save()
            messages.success(request, 'Vaga criada com sucesso!')
            return redirect('militares:vaga_list')
        else:
            messages.error(request, 'Preencha todos os campos obrigatÃ³rios.')
    # Para GET, exibe o mesmo modal, mas normalmente sÃ³ Ã© chamado via POST
    return redirect('militares:vaga_list')

# Views para PrevisÃ£o de Vagas
def previsao_vaga_list(request):
    """Lista todas as previsÃµes de vagas organizadas por quadro"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar previsÃµes de vagas ativas
    previsoes = list(PrevisaoVaga.objects.filter(ativo=True))
    
    # Calcular efetivo atual baseado nos militares cadastrados
    for previsao in previsoes:
        # Subtenentes estÃ£o cadastrados como COMP mas contam para PRACAS
        if previsao.posto == 'ST' and previsao.quadro == 'PRACAS':
            # Contar ST cadastrados como COMP (quadro de origem)
            efetivo_atual = Militar.objects.filter(
                posto_graduacao='ST',
                quadro='COMP',  # ST estÃ£o cadastrados como COMP
                situacao='AT'   # Apenas militares ativos
            ).count()
        else:
            # Para outros postos, contar normalmente
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'  # Apenas militares ativos
            ).count()
        
        previsao.efetivo_atual = efetivo_atual
        previsao.save()  # Isso vai recalcular vagas_disponiveis automaticamente
    
    # Remover previsÃµes de vaga de ST em quadros que nÃ£o sejam PRACAS
    previsoes = [p for p in previsoes if not (p.posto == 'ST' and p.quadro != 'PRACAS')]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    # Calcular estatÃ­sticas gerais
    total_efetivo_atual = sum(p.efetivo_atual for p in previsoes_ordenadas)
    total_efetivo_previsto = sum(p.efetivo_previsto for p in previsoes_ordenadas)
    total_vagas_disponiveis = sum(p.vagas_disponiveis for p in previsoes_ordenadas)
    
    context = {
        'previsoes': previsoes_ordenadas,
        'total_efetivo_atual': total_efetivo_atual,
        'total_efetivo_previsto': total_efetivo_previsto,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/previsao_vaga_list.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_manage(request):
    """Gerenciar previsÃµes de vagas"""
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Definir a hierarquia dos quadros
    hierarquia_quadros = {
        'COMB': 1,    # Combatente
        'SAUDE': 2,   # SaÃºde
        'ENG': 3,     # Engenheiro
        'COMP': 4,    # Complementar
        'PRACAS': 5,  # PraÃ§as
    }
    
    # Buscar todas as previsÃµes de vagas
    previsoes = list(PrevisaoVaga.objects.all())
    
    # Filtrar apenas postos de praÃ§as no quadro de praÃ§as
    postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    previsoes = [p for p in previsoes if p.quadro != 'PRACAS' or p.posto in postos_pracas]
    
    # Ordenar por quadro primeiro, depois por posto (hierarquia)
    previsoes_ordenadas = sorted(previsoes, key=lambda x: (
        hierarquia_quadros.get(x.quadro, 999),
        hierarquia_postos.get(x.posto, 999)
    ))
    
    if request.method == 'POST':
        for previsao in previsoes_ordenadas:
            efetivo_atual = request.POST.get(f'efetivo_atual_{previsao.id}', '').strip()
            efetivo_previsto = request.POST.get(f'efetivo_previsto_{previsao.id}', '').strip()
            try:
                previsao.efetivo_atual = int(efetivo_atual) if efetivo_atual.isdigit() else 0
                previsao.efetivo_previsto = int(efetivo_previsto) if efetivo_previsto.isdigit() else 0
                previsao.save()
                # Recarregar o objeto do banco para verificar se o cÃ¡lculo foi aplicado
                previsao.refresh_from_db()
                print(f"[DEBUG] PrevisaoVaga ID {previsao.id} | Atual: {previsao.efetivo_atual} | Previsto: {previsao.efetivo_previsto} | Vagas DisponÃ­veis: {previsao.vagas_disponiveis}")
            except Exception as e:
                messages.error(request, f'Erro ao salvar {previsao}: {e}')
        messages.success(request, 'PrevisÃµes de vagas atualizadas com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsoes': previsoes_ordenadas,
        'quadros': QUADRO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
    }
    return render(request, 'militares/previsao_vaga_manage.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_create(request):
    """Criar nova previsÃ£o de vaga"""
    if request.method == 'POST':
        quadro = request.POST.get('novo_quadro')
        posto = request.POST.get('novo_posto')
        efetivo_atual = request.POST.get('novo_efetivo_atual', '0')
        efetivo_previsto = request.POST.get('novo_efetivo_previsto', '0')
        
        try:
            # Verificar se jÃ¡ existe uma previsÃ£o para este quadro/posto
            if PrevisaoVaga.objects.filter(quadro=quadro, posto=posto).exists():
                messages.error(request, 'JÃ¡ existe uma previsÃ£o de vaga para este quadro e posto!')
            else:
                PrevisaoVaga.objects.create(
                    quadro=quadro,
                    posto=posto,
                    efetivo_atual=int(efetivo_atual),
                    efetivo_previsto=int(efetivo_previsto),
                    ativo=True
                )
                messages.success(request, 'PrevisÃ£o de vaga criada com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao criar previsÃ£o de vaga: {e}')
    
    return redirect('militares:previsao_vaga_manage')

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_delete(request, pk):
    """Excluir previsÃ£o de vaga"""
    previsao = get_object_or_404(PrevisaoVaga, pk=pk)
    
    if request.method == 'POST':
        previsao.delete()
        messages.success(request, 'PrevisÃ£o de vaga excluÃ­da com sucesso!')
        return redirect('militares:previsao_vaga_manage')
    
    context = {
        'previsao': previsao,
    }
    
    return render(request, 'militares/previsao_vaga_confirm_delete.html', context)

@user_passes_test(lambda u: u.is_superuser or u.is_staff)
def previsao_vaga_delete_ajax(request, pk):
    """Excluir previsÃ£o de vaga via AJAX"""
    if request.method == 'POST':
        try:
            previsao = PrevisaoVaga.objects.get(pk=pk)
            previsao.delete()
            return JsonResponse({'success': True})
        except PrevisaoVaga.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'PrevisÃ£o de vaga nÃ£o encontrada'})
        except Exception as e:
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'MÃ©todo nÃ£o permitido'})

@login_required
@requer_perm_documentos_excluir
def documento_delete(request, pk):
    """Excluir documento"""
    try:
        documento = Documento.objects.get(pk=pk)
    except Documento.DoesNotExist:
        messages.error(request, f'Documento com ID {pk} nÃ£o encontrado. O documento pode ter sido excluÃ­do anteriormente ou o ID estÃ¡ incorreto.')
        # Redirecionar para a lista de militares se nÃ£o conseguir identificar o militar
        return redirect('militares:militar_list')
    
    if request.method == 'POST':
        nome_arquivo = documento.filename()
        militar_pk = documento.militar.pk
        documento.delete()
        messages.success(request, f'Documento "{nome_arquivo}" excluÃ­do com sucesso!')
        return redirect('militares:militar_detail', pk=militar_pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
    }
    
    return render(request, 'militares/documento_confirm_delete.html', context)

@login_required
def assinar_documentos_quadro(request, pk):
    """PÃ¡gina para assinar documentos de um quadro de acesso"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Buscar militares do quadro
    militares_quadro = []
    if quadro.status in ['ELABORADO', 'HOMOLOGADO']:
        militares_quadro = quadro.itemquadroacesso_set.all().order_by('posicao')
    
    # Buscar documentos pendentes de assinatura
    documentos_pendentes = Documento.objects.filter(
        militar__in=[item.militar for item in militares_quadro],
        status='PENDENTE'
    ).order_by('militar__nome_completo', 'data_upload')
    
    # Criar lista de documentos com informaÃ§Ãµes do militar e posiÃ§Ã£o
    documentos_com_info = []
    militares_sem_documentos = []
    
    for item in militares_quadro:
        documentos_militar = documentos_pendentes.filter(militar=item.militar)
        if documentos_militar.exists():
            for doc in documentos_militar:
                documentos_com_info.append({
                    'documento': doc,
                    'militar': item.militar,
                    'posicao': item.posicao,
                    'item_quadro': item
                })
        else:
            militares_sem_documentos.append(item)
    
    context = {
        'quadro': quadro,
        'militares_quadro': militares_quadro,
        'documentos_pendentes': documentos_pendentes,
        'documentos_com_info': documentos_com_info,
        'militares_sem_documentos': militares_sem_documentos,
        'total_documentos_pendentes': documentos_pendentes.count(),
    }
    
    return render(request, 'militares/assinar_documentos_quadro.html', context)

@login_required
def assinar_documento(request, pk):
    """Assinar documento com confirmaÃ§Ã£o de senha"""
    documento = get_object_or_404(Documento, pk=pk)
    
    # Buscar funÃ§Ãµes do usuÃ¡rio para seleÃ§Ã£o
    from militares.models import UsuarioFuncao
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
    
    # FunÃ§Ã£o atual selecionada (da sessÃ£o ou primeira disponÃ­vel)
    funcao_atual = request.session.get('funcao_atual_nome', '')
    if not funcao_atual and funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes_assinatura', '')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'documento': documento,
                'militar': documento.militar,
                'funcoes_usuario': funcoes_usuario,
                'funcao_atual': funcao_atual,
            }
            return render(request, 'militares/assinar_documento.html', context)
        
        # Assinar o documento
        documento.status = 'ASSINADO'
        documento.assinado_por = request.user
        documento.data_assinatura = timezone.now()
        documento.observacoes_assinatura = observacoes
        documento.funcao_assinatura = funcao_assinatura
        documento.save()
        
        messages.success(request, f'Documento "{documento.titulo}" assinado com sucesso!')
        return redirect('militares:militar_detail', pk=documento.militar.pk)
    
    context = {
        'documento': documento,
        'militar': documento.militar,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
    }
    
    return render(request, 'militares/assinar_documento.html', context)

@login_required
def assinar_quadro_acesso(request, pk):
    """Assinar quadro de acesso com confirmaÃ§Ã£o de senha"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    
    # Buscar comissÃ£o relacionada ao quadro
    if quadro.tipo in ['ANTIGUIDADE', 'MERECIMENTO']:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPO')
    else:
        comissao = ComissaoPromocao.get_comissao_ativa_por_tipo('CPP')
    membros_comissao = comissao.membros.filter(ativo=True).select_related('militar', 'usuario').order_by('tipo', 'militar__nome_completo') if comissao else []
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        membro_id = request.POST.get('membro_id')
        membro = membros_comissao.filter(id=membro_id).first() if membro_id else None
        
        # Verificar senha do usuÃ¡rio selecionado
        if not membro or not membro.usuario or not membro.usuario.check_password(senha):
            messages.error(request, 'Senha incorreta ou membro invÃ¡lido. Tente novamente.')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Verificar se jÃ¡ existe uma assinatura deste membro para este tipo
        assinatura_existente = AssinaturaQuadroAcesso.objects.filter(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'Este membro jÃ¡ assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
                'membros_comissao': membros_comissao,
            }
            return render(request, 'militares/assinar_quadro_acesso.html', context)
        
        # Obter funÃ§Ã£o atual do membro
        if membro.cargo:
            funcao_atual = f"{membro.get_tipo_display()} - {membro.cargo.nome}"
        else:
            funcao_atual = membro.get_tipo_display()
        
        # Se nÃ£o conseguir obter funÃ§Ã£o do membro, tentar buscar funÃ§Ã£o ativa do usuÃ¡rio
        if not funcao_atual or funcao_atual == " - ":
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=membro.usuario,
                status='ATIVO'
            ).first()
            
            if funcao_usuario:
                funcao_atual = funcao_usuario.cargo_funcao.nome
            else:
                funcao_atual = "UsuÃ¡rio do Sistema"
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroAcesso.objects.create(
            quadro_acesso=quadro,
            assinado_por=membro.usuario,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura,
            funcao_assinatura=funcao_atual
        )
        
        messages.success(request, f'Quadro de acesso assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'membros_comissao': membros_comissao,
    }
    
    return render(request, 'militares/assinar_quadro_acesso.html', context)

@login_required
def retirar_assinatura_quadro_acesso(request, pk, assinatura_pk):
    """Retirar assinatura do quadro de acesso - apenas antes da homologaÃ§Ã£o"""
    quadro = get_object_or_404(QuadroAcesso, pk=pk)
    assinatura = get_object_or_404(AssinaturaQuadroAcesso, pk=assinatura_pk, quadro_acesso=quadro)
    
    # Verificar se o quadro jÃ¡ foi homologado
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'NÃ£o Ã© possÃ­vel retirar assinaturas de um quadro jÃ¡ homologado.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    # Verificar se o usuÃ¡rio Ã© o autor da assinatura ou tem permissÃ£o administrativa
    if assinatura.assinado_por != request.user and not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'VocÃª sÃ³ pode retirar suas prÃ³prias assinaturas.')
        return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_quadro_acesso.html', context)
        
        # Verificar se a assinatura Ã© de aprovaÃ§Ã£o e se hÃ¡ outras assinaturas de aprovaÃ§Ã£o
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = quadro.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se nÃ£o hÃ¡ outras aprovaÃ§Ãµes, voltar o status do quadro para EM_ELABORACAO
                quadro.status = 'EM_ELABORACAO'
                quadro.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a pÃ¡gina de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:quadro_acesso_detail', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_quadro_acesso.html', context)

# ============================================================================
# VIEWS DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS
# ============================================================================

@login_required
@requer_perm_comissao_visualizar
def comissao_list(request):
    """Lista todas as comissÃµes de promoÃ§Ã£o de oficiais"""
    # PermissÃ£o especial para funÃ§Ãµes administrativas
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    if funcoes_ativas.exists() or request.user.is_superuser or request.user.is_staff:
        comissoes = ComissaoPromocao.objects.all()
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                comissoes = ComissaoPromocao.objects.all()
            elif tem_cpo:
                comissoes = ComissaoPromocao.objects.filter(tipo='CPO')
            elif tem_cpp:
                comissoes = ComissaoPromocao.objects.filter(tipo='CPP')
            else:
                comissoes = ComissaoPromocao.objects.none()
        else:
            comissoes = ComissaoPromocao.objects.none()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        comissoes = comissoes.filter(status=status)
    
    # Busca
    busca = request.GET.get('busca')
    if busca:
        comissoes = comissoes.filter(
            models.Q(nome__icontains=busca) |
            models.Q(observacoes__icontains=busca)
        )
    
    context = {
        'comissoes': comissoes,
        'status_choices': ComissaoPromocao.STATUS_CHOICES,
    }
    return render(request, 'militares/comissao/list.html', context)

@login_required
@requer_perm_comissao_visualizar
def comissao_detail(request, pk):
    """Detalhes de uma comissÃ£o de promoÃ§Ã£o de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    # Buscar quadros de acesso relacionados Ã  comissÃ£o
    if comissao.tipo == 'CPO':
        # Para comissÃ£o de oficiais, buscar quadros de oficiais
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='OFICIAIS'
        ).order_by('-data_promocao')
    else:
        # Para comissÃ£o de praÃ§as, buscar quadros de praÃ§as
        quadros_acesso_base = QuadroAcesso.objects.filter(
            categoria='PRACAS'
        ).order_by('-data_promocao')
    
    # Aplicar slice para mostrar apenas os Ãºltimos 10 quadros
    quadros_acesso = quadros_acesso_base[:10]
    
    # Buscar quadros de fixaÃ§Ã£o de vagas relacionados Ã  comissÃ£o
    if comissao.tipo == 'CPO':
        # Para comissÃ£o de oficiais, buscar quadros de oficiais
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='OFICIAIS'
        ).order_by('-data_promocao')[:10]  # Ãšltimos 10 quadros
    else:
        # Para comissÃ£o de praÃ§as, buscar quadros de praÃ§as
        quadros_fixacao_vagas = QuadroFixacaoVagas.objects.filter(
            tipo='PRACAS'
        ).order_by('-data_promocao')[:10]  # Ãšltimos 10 quadros
    
    # Buscar quadros de acesso por merecimento e suas fichas de conceito
    quadros_merecimento = quadros_acesso_base.filter(tipo='MERECIMENTO')
    fichas_conceito_merecimento = {}
    
    for quadro in quadros_merecimento:
        militares_quadro = []
        for item in quadro.itemquadroacesso_set.all().order_by('posicao'):
            militar = item.militar
            # Buscar ficha de conceito do militar
            if comissao.tipo == 'CPO':
                ficha = militar.fichaconceitooficiais_set.first()
            else:
                ficha = militar.fichaconceitopracas_set.first()
            
            if ficha:
                militares_quadro.append({
                    'militar': militar,
                    'ficha': ficha,
                    'posicao': item.posicao,
                    'pontuacao': item.pontuacao
                })
        
        if militares_quadro:
            fichas_conceito_merecimento[quadro] = militares_quadro
    
    # Buscar votos da comissÃ£o
    votos_comissao = VotoDeliberacao.objects.filter(
        deliberacao__sessao__comissao=comissao
    ).select_related(
        'deliberacao__sessao',
        'membro__militar'
    ).order_by('-data_registro')[:10]  # Ãšltimos 10 votos
    
    # Calcular estatÃ­sticas dos votos
    total_votos = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao).count()
    votos_favor = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='FAVOR').count()
    votos_contra = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='CONTRA').count()
    votos_abstencao = VotoDeliberacao.objects.filter(deliberacao__sessao__comissao=comissao, voto='ABSTENCAO').count()
    
    context = {
        'comissao': comissao,
        'membros': comissao.membros.all(),
        'sessoes': comissao.sessoes.all()[:5],  # Ãšltimas 5 sessÃµes
        'quadros_acesso': quadros_acesso,
        'quadros_fixacao_vagas': quadros_fixacao_vagas,
        'fichas_conceito_merecimento': fichas_conceito_merecimento,
        'votos_comissao': votos_comissao,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
    }
    return render(request, 'militares/comissao/detail.html', context)

@login_required
@requer_gerenciamento_comissoes
def comissao_create(request):
    """Criar nova comissÃ£o de promoÃ§Ã£o de oficiais"""
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST)
        if form.is_valid():
            nova_comissao = form.save(commit=False)
            # Inativar comissÃ£o ativa do mesmo tipo
            comissao_ativa = ComissaoPromocao.objects.filter(tipo=nova_comissao.tipo, status='ATIVA').first()
            if comissao_ativa:
                comissao_ativa.status = 'INATIVA'
                comissao_ativa.save()
            nova_comissao.status = 'ATIVA'
            nova_comissao.save()
            messages.success(request, 'ComissÃ£o criada com sucesso!')
            return redirect('militares:comissao_detail', pk=nova_comissao.pk)
    else:
        form = ComissaoPromocaoForm()
    context = {
        'form': form,
        'title': 'Nova ComissÃ£o de PromoÃ§Ãµes',
    }
    return render(request, 'militares/comissao/form.html', context)

@login_required
@requer_perm_comissao_editar
def comissao_update(request, pk):
    """Editar comissÃ£o de promoÃ§Ã£o de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    if request.method == 'POST':
        form = ComissaoPromocaoForm(request.POST, instance=comissao)
        if form.is_valid():
            form.save()
            messages.success(request, 'ComissÃ£o atualizada com sucesso!')
            return redirect('militares:comissao_detail', pk=comissao.pk)
    else:
        form = ComissaoPromocaoForm(instance=comissao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Editar ComissÃ£o de PromoÃ§Ã£o de Oficiais',
    }
    return render(request, 'militares/comissao/form.html', context)

@login_required
@login_required
@requer_perm_comissao_excluir
def comissao_delete(request, pk):
    """Excluir comissÃ£o de promoÃ§Ã£o de oficiais"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar permissÃµes
    def tem_permissao_exclusao(user):
        # SuperusuÃ¡rios e staff sempre podem excluir
        if user.is_superuser or user.is_staff:
            return True
        
        # Verificar se usuÃ¡rio tem funÃ§Ã£o de Diretor de GestÃ£o de Pessoas
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=['Diretor de GestÃ£o de Pessoas', 'Administrador do Sistema', 'Administrador']
        )
        return funcoes_especiais.exists()
    
    if not tem_permissao_exclusao(request.user):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir comissÃµes.')
        return redirect('militares:comissao_list')
    
    # Verificar se a comissÃ£o tem sessÃµes
    if comissao.sessoes.exists():
        messages.error(request, 'NÃ£o Ã© possÃ­vel excluir uma comissÃ£o que possui sessÃµes. Apenas ediÃ§Ã£o Ã© permitida.')
        return redirect('militares:comissao_detail', pk=pk)
    
    # Verificar se a comissÃ£o tem membros
    if comissao.membros.exists():
        messages.error(request, 'NÃ£o Ã© possÃ­vel excluir uma comissÃ£o que possui membros. Apenas ediÃ§Ã£o Ã© permitida.')
        return redirect('militares:comissao_detail', pk=pk)
    
    if request.method == 'POST':
        comissao.delete()
        messages.success(request, 'ComissÃ£o excluÃ­da com sucesso!')
        return redirect('militares:comissao_list')
    
    context = {
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/delete.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_list(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Definir a hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar membros e ordenar por hierarquia
    membros = list(comissao.membros.all())
    
    # Ordenar por tipo primeiro, depois por hierarquia de posto
    membros.sort(key=lambda x: (
        x.tipo,  # Primeiro por tipo (EFETIVO, NATO, SUPLENTE)
        hierarquia_postos.get(x.militar.posto_graduacao, 999),  # Depois por hierarquia
        x.militar.nome_completo  # Por Ãºltimo por nome
    ))
    
    # Calcular contagens para estatÃ­sticas usando list comprehension
    membros_ativos_count = sum(1 for membro in membros if membro.ativo)
    membros_com_usuario_count = sum(1 for membro in membros if membro.usuario is not None)
    membros_sem_usuario_count = sum(1 for membro in membros if membro.usuario is None)
    
    context = {
        'comissao': comissao,
        'membros': membros,
        'membros_ativos_count': membros_ativos_count,
        'membros_com_usuario_count': membros_com_usuario_count,
        'membros_sem_usuario_count': membros_sem_usuario_count,
        'title': 'Membros da ComissÃ£o',
    }
    return render(request, 'militares/comissao/membros/list.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_add(request, comissao_pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar funÃ§Ã£o atual do usuÃ¡rio
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma funÃ§Ã£o selecionada. Selecione uma funÃ§Ã£o primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'FunÃ§Ã£o atual nÃ£o encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            membro.comissao = comissao
            # Definir o usuÃ¡rio automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # VerificaÃ§Ã£o de duplicidade
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exists()
            if existe:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })

            try:
                membro.save()
                messages.success(request, 'Membro adicionado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'funcao_atual': funcao_atual,
                    'title': 'Adicionar Membro',
                })
    else:
        form = MembroComissaoForm(comissao_tipo=comissao.tipo)
        
        # Filtrar militares baseado no tipo de comissÃ£o
        if comissao.tipo == 'CPO':  # ComissÃ£o de PromoÃ§Ã£o de Oficiais
            # Membros de comissÃ£o podem adicionar oficiais
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
                
        elif comissao.tipo == 'CPP':  # ComissÃ£o de PromoÃ§Ãµes de PraÃ§as
            # Membros de comissÃ£o podem adicionar oficiais (membros da comissÃ£o sÃ£o sempre oficiais)
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
    
    context = {
        'form': form,
        'comissao': comissao,
        'funcao_atual': funcao_atual,
        'title': 'Adicionar Membro',
    }
    return render(request, 'militares/comissao/membros/form.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_update(request, comissao_pk, pk):
    """Editar membro da comissÃ£o"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro nÃ£o encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    # Verificar funÃ§Ã£o atual do usuÃ¡rio
    funcao_atual_id = request.session.get('funcao_atual_id')
    if not funcao_atual_id:
        messages.error(request, 'Nenhuma funÃ§Ã£o selecionada. Selecione uma funÃ§Ã£o primeiro.')
        return redirect('militares:selecionar_funcao')
    
    try:
        funcao_atual = UsuarioFuncao.objects.get(
            id=funcao_atual_id,
            usuario=request.user,
            status='ATIVO'
        )
    except UsuarioFuncao.DoesNotExist:
        messages.error(request, 'FunÃ§Ã£o atual nÃ£o encontrada ou inativa.')
        return redirect('militares:selecionar_funcao')
    
    if request.method == 'POST':
        form = MembroComissaoForm(request.POST, instance=membro, comissao_tipo=comissao.tipo)
        if form.is_valid():
            membro = form.save(commit=False)
            # Definir o usuÃ¡rio automaticamente baseado no militar selecionado
            if membro.militar and membro.militar.user:
                membro.usuario = membro.militar.user

            # VerificaÃ§Ã£o de duplicidade (excluindo o prÃ³prio membro sendo editado)
            tipo = form.cleaned_data.get('tipo')
            existe = MembroComissao.objects.filter(
                comissao=comissao,
                militar=membro.militar,
                tipo=tipo
            ).exclude(pk=membro.pk).exists()
            if existe:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da ComissÃ£o',
                })

            try:
                membro.save()
                messages.success(request, 'Membro atualizado com sucesso!')
                return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
            except IntegrityError:
                messages.error(request, 'JÃ¡ existe um membro com esse militar e tipo nesta comissÃ£o!')
                return render(request, 'militares/comissao/membros/form.html', {
                    'form': form,
                    'comissao': comissao,
                    'membro': membro,
                    'funcao_atual': funcao_atual,
                    'title': 'Editar Membro da ComissÃ£o',
                })
    else:
        form = MembroComissaoForm(instance=membro, comissao_tipo=comissao.tipo)
        
        # Filtrar militares baseado no tipo de comissÃ£o
        if comissao.tipo == 'CPO':  # ComissÃ£o de PromoÃ§Ã£o de Oficiais
            # Membros de comissÃ£o podem editar oficiais
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
                
        elif comissao.tipo == 'CPP':  # ComissÃ£o de PromoÃ§Ã£o de PraÃ§as
            # Membros de comissÃ£o podem editar oficiais (membros da comissÃ£o sÃ£o sempre oficiais)
            form.fields['militar'].queryset = Militar.objects.filter(
                situacao='AT',
                posto_graduacao__in=['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS']  # Oficiais
            ).order_by('nome_completo')
    
    context = {
        'form': form,
        'comissao': comissao,
        'membro': membro,
        'funcao_atual': funcao_atual,
        'title': 'Editar Membro da ComissÃ£o',
    }
    return render(request, 'militares/comissao/membros/form.html', context)

@login_required
@comissao_acesso_total
def membro_comissao_delete(request, comissao_pk, pk):
    """Remover membro da comissÃ£o"""
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
        membro = MembroComissao.objects.get(pk=pk, comissao=comissao)
    except (ComissaoPromocao.DoesNotExist, MembroComissao.DoesNotExist):
        messages.error(request, 'Membro nÃ£o encontrado.')
        return redirect('militares:comissao_detail', pk=comissao_pk)
    
    if request.method == 'POST':
        membro.delete()
        messages.success(request, 'Membro removido com sucesso!')
        return redirect('militares:membro_comissao_list', comissao_pk=comissao.pk)
    
    context = {
        'comissao': comissao,
        'membro': membro,
    }
    return render(request, 'militares/comissao/membros/delete.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_list(request):
    """Lista sessÃµes de uma comissÃ£o"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'ComissÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    sessoes = comissao.sessoes.all()
    
    # Filtros
    status = request.GET.get('status')
    if status:
        sessoes = sessoes.filter(status=status)
    
    tipo = request.GET.get('tipo')
    if tipo:
        sessoes = sessoes.filter(tipo=tipo)
    
    context = {
        'comissao': comissao,
        'sessoes': sessoes,
        'status_choices': SessaoComissao.STATUS_CHOICES,
        'tipo_choices': SessaoComissao.TIPO_CHOICES,
    }
    return render(request, 'militares/comissao/sessoes/list.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_detail(request, pk):
    """Detalhes de uma sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    # FunÃ§Ã£o para normalizar texto
    def normalizar(texto):
        if not texto:
            return ''
        return unicodedata.normalize('NFKD', texto).encode('ASCII', 'ignore').decode('ASCII').upper()
    
    # Verificar se a pauta Ã© sobre aprovaÃ§Ã£o de quadro de acesso (singular/plural, ignorando acentos e case)
    pauta_aprovacao_quadro = False
    quadros_acesso_sessao = []
    pauta_normalizada = normalizar(sessao.pauta)
    if (
        'APROVACAO DE QUADRO DE ACESSO' in pauta_normalizada or
        'APROVACAO DE QUADROS DE ACESSO' in pauta_normalizada or
        'APROVACAO DE QUADROS DE ACESSOS' in pauta_normalizada
    ):
        pauta_aprovacao_quadro = True
        # Buscar quadros de acesso da comissÃ£o especÃ­fica
        if comissao.tipo == 'CPO':
            quadros_acesso_sessao = QuadroAcesso.objects.filter(
                categoria='OFICIAIS',
                status__in=['ELABORADO', 'HOMOLOGADO', 'ASSINADO']
            ).order_by('-data_promocao')
        else:
            quadros_acesso_sessao = QuadroAcesso.objects.filter(
                categoria='PRACAS',
                status__in=['ELABORADO', 'HOMOLOGADO', 'ASSINADO']
            ).order_by('-data_promocao')
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all(),
        'user_membro': user_membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'votos_sessao': VotoDeliberacao.objects.filter(deliberacao__sessao=sessao).select_related('membro__militar', 'deliberacao').order_by('deliberacao__numero', 'membro__militar__nome_completo'),
        'pauta_aprovacao_quadro': pauta_aprovacao_quadro,
        'quadros_acesso_sessao': quadros_acesso_sessao,
    }
    return render(request, 'militares/comissao/sessoes/detail.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_create(request):
    """Criar nova sessÃ£o"""
    comissao_pk = request.GET.get('comissao')
    if not comissao_pk:
        messages.error(request, 'ComissÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=comissao_pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES)
        if form.is_valid():
            sessao = form.save(commit=False)
            sessao.comissao = comissao
            sessao.save()
            
            # Criar registros de presenÃ§a para todos os membros
            for membro in comissao.membros.filter(ativo=True):
                PresencaSessao.objects.create(
                    sessao=sessao,
                    membro=membro,
                    presente=False
                )
            
            # Criar documento se fornecido
            documento_titulo = form.cleaned_data.get('documento_titulo')
            documento_tipo = form.cleaned_data.get('documento_tipo')
            documento_arquivo = form.cleaned_data.get('documento_arquivo')
            documento_descricao = form.cleaned_data.get('documento_descricao')
            
            if documento_titulo and documento_tipo and documento_arquivo:
                documento = DocumentoSessao.objects.create(
                    sessao=sessao,
                    tipo=documento_tipo,
                    titulo=documento_titulo,
                    descricao=documento_descricao,
                    arquivo=documento_arquivo,
                    upload_por=request.user
                )
                messages.success(request, f'SessÃ£o criada com sucesso! Documento "{documento.titulo}" anexado.')
            else:
                messages.success(request, 'SessÃ£o criada com sucesso!')
            
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = SessaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'title': 'Nova SessÃ£o da ComissÃ£o',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)

@login_required
@comissao_acesso_total
def sessao_comissao_update(request, pk):
    """Editar sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = SessaoComissaoForm(request.POST, request.FILES, instance=sessao)
        if form.is_valid():
            try:
                # Salvar a sessÃ£o
                sessao_atualizada = form.save()
                
                # Processar documento se fornecido
                documento_titulo = form.cleaned_data.get('documento_titulo')
                documento_tipo = form.cleaned_data.get('documento_tipo')
                documento_arquivo = form.cleaned_data.get('documento_arquivo')
                documento_descricao = form.cleaned_data.get('documento_descricao')
                
                if documento_titulo and documento_tipo and documento_arquivo:
                    # Criar ou atualizar documento da sessÃ£o
                    documento_sessao, created = DocumentoSessao.objects.get_or_create(
                        sessao=sessao_atualizada,
                        defaults={
                            'tipo': documento_tipo,
                            'titulo': documento_titulo,
                            'descricao': documento_descricao or '',
                            'arquivo': documento_arquivo,
                            'upload_por': request.user,
                        }
                    )
                    
                    if not created:
                        # Atualizar documento existente
                        documento_sessao.tipo = documento_tipo
                        documento_sessao.titulo = documento_titulo
                        documento_sessao.descricao = documento_descricao or ''
                        documento_sessao.arquivo = documento_arquivo
                        documento_sessao.save()
                
                messages.success(request, 'SessÃ£o atualizada com sucesso!')
                return redirect('militares:sessao_comissao_detail', pk=sessao_atualizada.pk)
            except Exception as e:
                messages.error(request, f'Erro ao salvar sessÃ£o: {str(e)}')
        else:
            # Log dos erros de validaÃ§Ã£o para debug
            print("Erros de validaÃ§Ã£o do formulÃ¡rio:")
            for field, errors in form.errors.items():
                print(f"Campo {field}: {errors}")
            
            # Criar mensagem de erro mais especÃ­fica
            error_messages = []
            for field, errors in form.errors.items():
                field_name = form.fields[field].label if field in form.fields else field
                for error in errors:
                    error_messages.append(f"{field_name}: {error}")
            
            if error_messages:
                messages.error(request, f'Erro ao atualizar sessÃ£o: {"; ".join(error_messages)}')
            else:
                messages.error(request, 'Erro ao atualizar sessÃ£o. Verifique os dados informados.')
    else:
        form = SessaoComissaoForm(instance=sessao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Editar SessÃ£o da ComissÃ£o',
    }
    return render(request, 'militares/comissao/sessoes/form.html', context)

@login_required
def presenca_sessao_update(request, sessao_pk):
    """Atualizar presenÃ§as de uma sessÃ£o"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        # Obter todos os membros da comissÃ£o
        membros = comissao.membros.all()
        
        for membro in membros:
            # Verificar se o membro estÃ¡ presente
            presente = request.POST.get(f'presenca_{membro.pk}') == '1'
            
            # Obter ou criar presenÃ§a
            presenca, created = PresencaSessao.objects.get_or_create(
                sessao=sessao,
                membro=membro,
                defaults={'presente': presente}
            )
            
            # Atualizar presenÃ§a
            presenca.presente = presente
            presenca.save()
            
            # Debug: imprimir informaÃ§Ãµes
            print(f"Membro: {membro.militar.nome_completo}, Presente: {presente}, POST data: {request.POST.get(f'presenca_{membro.pk}')}")
        
        # Debug: imprimir todos os dados POST
        print("POST data:", request.POST)
        print("Total de presenÃ§as salvas:", sessao.presencas.filter(presente=True).count())
        
        messages.success(request, 'PresenÃ§as atualizadas com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Obter membros da comissÃ£o
    membros = comissao.membros.all()
    
    # Obter presenÃ§as existentes
    presencas_existentes = set(sessao.presencas.filter(presente=True).values_list('membro_id', flat=True))
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'membros': membros,
        'presencas_existentes': presencas_existentes,
    }
    return render(request, 'militares/comissao/sessoes/presenca_form.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_create(request):
    """Criar nova deliberaÃ§Ã£o"""
    sessao_pk = request.GET.get('sessao')
    resultado = request.GET.get('resultado')
    
    if not sessao_pk:
        messages.error(request, 'SessÃ£o nÃ£o especificada.')
        return redirect('militares:comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Se o parÃ¢metro resultado estiver presente, redirecionar para a pÃ¡gina de resultados
    if resultado:
        return redirect('militares:deliberacao_comissao_resultado', sessao_pk=sessao.pk)
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST)
        if form.is_valid():
            deliberacao = form.save(commit=False)
            deliberacao.sessao = sessao
            deliberacao.save()
            
            messages.success(request, 'DeliberaÃ§Ã£o criada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm()
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'title': 'Nova DeliberaÃ§Ã£o',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_update(request, pk):
    """Editar deliberaÃ§Ã£o"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'DeliberaÃ§Ã£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    if request.method == 'POST':
        form = DeliberacaoComissaoForm(request.POST, instance=deliberacao)
        if form.is_valid():
            form.save()
            messages.success(request, 'DeliberaÃ§Ã£o atualizada com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    else:
        form = DeliberacaoComissaoForm(instance=deliberacao)
    
    context = {
        'form': form,
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'title': 'Editar DeliberaÃ§Ã£o',
    }
    return render(request, 'militares/comissao/deliberacoes/form.html', context)

@login_required
@comissao_acesso_total
def voto_deliberacao_create(request, deliberacao_pk):
    """Registrar voto do usuÃ¡rio logado em uma deliberaÃ§Ã£o"""
    try:
        deliberacao = DeliberacaoComissao.objects.get(pk=deliberacao_pk)
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except DeliberacaoComissao.DoesNotExist:
        messages.error(request, 'DeliberaÃ§Ã£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio logado Ã© membro da comissÃ£o
    membro_usuario = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    if not membro_usuario:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se o membro estava presente na sessÃ£o
    presenca = sessao.presencas.filter(membro=membro_usuario, presente=True).first()
    if not presenca:
        messages.error(request, 'VocÃª nÃ£o estava presente nesta sessÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se jÃ¡ votou
    voto_existente = deliberacao.votos.filter(membro=membro_usuario).first()
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar o voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Validar senha do usuÃ¡rio
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Obter dados do voto
        voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        
        if not voto:
            messages.error(request, 'VocÃª deve escolher uma opÃ§Ã£o de voto.')
            context = {
                'comissao': comissao,
                'sessao': sessao,
                'deliberacao': deliberacao,
                'membro_usuario': membro_usuario,
                'voto_existente': voto_existente,
            }
            return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)
        
        # Criar ou atualizar voto
        if voto_existente:
            voto_existente.voto = voto
            voto_existente.voto_proferido = voto_proferido
            voto_existente.save()
        else:
            voto_existente = VotoDeliberacao.objects.create(
                deliberacao=deliberacao,
                membro=membro_usuario,
                voto=voto,
                voto_proferido=voto_proferido
            )
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        if voto_existente:
            messages.success(request, f'âœ… Voto atualizado com sucesso!')
        else:
            messages.success(request, f'âœ… Voto registrado com sucesso!')
        
        # Redirecionar de volta para o formulÃ¡rio de voto para mostrar os dados atualizados
        return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
    
    # Criar formulÃ¡rio para o voto proferido com CKEditor
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                    'class': 'ckeditor5',
                    'data-config-name': 'voto_proferido_config'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto_existente.voto_proferido if voto_existente else ''
    })
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacao': deliberacao,
        'membro_usuario': membro_usuario,
        'voto_existente': voto_existente,
        'form': form,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_form.html', context)

@login_required
def voto_deliberacao_editor_popup(request, deliberacao_pk):
    """Editor de voto em modal/popup similar ao editor de atas"""
    deliberacao = get_object_or_404(DeliberacaoComissao, pk=deliberacao_pk)
    sessao = deliberacao.sessao
    comissao = sessao.comissao
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro_usuario = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    if not membro_usuario:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    
    # Verificar se jÃ¡ existe um voto para este membro
    voto_existente = VotoDeliberacao.objects.filter(
        deliberacao=deliberacao,
        membro=membro_usuario
    ).first()
    
    if request.method == 'POST':
        # Processar dados do formulÃ¡rio
        voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        senha_votante = request.POST.get('senha_votante')
        
        # ValidaÃ§Ãµes
        if not senha_votante:
            return JsonResponse({'success': False, 'error': 'Senha Ã© obrigatÃ³ria para confirmar o voto.'})
        
        if not request.user.check_password(senha_votante):
            return JsonResponse({'success': False, 'error': 'Senha incorreta. Tente novamente.'})
        
        if not voto:
            return JsonResponse({'success': False, 'error': 'VocÃª deve escolher uma opÃ§Ã£o de voto.'})
        
        # Criar ou atualizar voto
        if voto_existente:
            voto_existente.voto = voto
            voto_existente.voto_proferido = voto_proferido
            voto_existente.save()
        else:
            voto_existente = VotoDeliberacao.objects.create(
                deliberacao=deliberacao,
                membro=membro_usuario,
                voto=voto,
                voto_proferido=voto_proferido
            )
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        return JsonResponse({
            'success': True, 
            'message': 'Voto salvo com sucesso!',
            'voto_id': voto_existente.pk,
            'redirect_url': f'/militares/meus-votos/{voto_existente.pk}/visualizar/'
        })
    
    # Preparar dados para o template
    context = {
        'deliberacao': deliberacao,
        'sessao': sessao,
        'comissao': comissao,
        'membro_usuario': membro_usuario,
        'voto_existente': voto_existente,
    }
    
    return render(request, 'militares/comissao/deliberacoes/voto_editor_popup.html', context)

@login_required
def comissao_pdf(request, pk):
    """Gerar PDF da comissÃ£o de promoÃ§Ã£o de oficiais"""
    from reportlab.platypus import SimpleDocTemplate, Image, Spacer, Paragraph
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('comissao_list')
    
    # Criar o PDF
    response = HttpResponse(content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="comissao_promocao_{pk}.pdf"'
    
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    
    story = []
    
    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))
    
    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        f"{comissao.get_tipo_display().upper()} - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 Terreo - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # InformaÃ§Ãµes da comissÃ£o
    story.append(Paragraph(f"<b>Nome:</b> {comissao.nome}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Data de CriaÃ§Ã£o:</b> {comissao.data_criacao.strftime('%d/%m/%Y')}", style_bold))
    story.append(Spacer(1, 6))
    story.append(Paragraph(f"<b>Status:</b> {comissao.get_status_display()}", style_bold))
    story.append(Spacer(1, 6))
    
    if comissao.data_termino:
        story.append(Paragraph(f"<b>Data de TÃ©rmino:</b> {comissao.data_termino.strftime('%d/%m/%Y')}", style_bold))
        story.append(Spacer(1, 6))
    
    story.append(Spacer(1, 12))
    
    # Obter todos os membros ativos ordenados por tipo (presidente, membros, secretÃ¡rio)
    membros_ativos = comissao.membros.filter(ativo=True).order_by(
        'tipo'  # PRESIDENTE, EFETIVO, NATO, SECRETARIO
    )
    
    # Presidente
    presidente = membros_ativos.filter(tipo='PRESIDENTE').first()
    if presidente:
        story.append(Paragraph("<b>PRESIDENTE:</b>", style_bold))
        story.append(Paragraph(f"{presidente.militar.get_posto_graduacao_display()} {presidente.militar.get_quadro_display()} {presidente.militar.nome_completo} - {presidente.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Natos
    membros_natos = membros_ativos.filter(tipo='NATO')
    if membros_natos:
        story.append(Paragraph("<b>MEMBROS NATOS:</b>", style_bold))
        for membro in membros_natos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # Membros Efetivos
    membros_efetivos = membros_ativos.filter(tipo='EFETIVO')
    if membros_efetivos:
        story.append(Paragraph("<b>MEMBROS EFETIVOS:</b>", style_bold))
        for membro in membros_efetivos:
            story.append(Paragraph(f"{membro.militar.get_posto_graduacao_display()} {membro.militar.get_quadro_display()} {membro.militar.nome_completo} - {membro.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # SecretÃ¡rio
    secretario = membros_ativos.filter(tipo='SECRETARIO').first()
    if secretario:
        story.append(Paragraph("<b>SECRETÃRIO:</b>", style_bold))
        story.append(Paragraph(f"{secretario.militar.get_posto_graduacao_display()} {secretario.militar.get_quadro_display()} {secretario.militar.nome_completo} - {secretario.cargo.nome}", style_center))
        story.append(Spacer(1, 8))
    
    # ObservaÃ§Ãµes
    if comissao.observacoes:
        story.append(Spacer(1, 12))
        story.append(Paragraph("<b>OBSERVAÃ‡Ã•ES:</b>", style_bold))
        story.append(Paragraph(comissao.observacoes, style_center))
    
    # Gerar o PDF
    doc.build(story)
    pdf = buffer.getvalue()
    buffer.close()
    
    response.write(pdf)
    return response

@login_required
def comissao_encerrar(request, pk):
    try:
        comissao = ComissaoPromocao.objects.get(pk=pk)
    except ComissaoPromocao.DoesNotExist:
        messages.error(request, 'ComissÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    if comissao.status == 'INATIVA':
        messages.info(request, 'Esta comissÃ£o jÃ¡ estÃ¡ inativa.')
    else:
        comissao.status = 'INATIVA'
        comissao.save()
        messages.success(request, 'ComissÃ£o encerrada com sucesso!')
    return redirect('militares:comissao_list')

@login_required
def documento_sessao_create(request):
    """Upload de documento para uma sessÃ£o"""
    sessao_pk = request.GET.get('sessao')
    if not sessao_pk:
        messages.error(request, 'SessÃ£o nÃ£o especificada.')
        return redirect('militares:sessao_comissao_list')
    
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_list')
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES)
        if form.is_valid():
            documento = form.save(commit=False)
            documento.sessao = sessao
            documento.upload_por = request.user
            documento.save()
            messages.success(request, f'Documento "{documento.titulo}" enviado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        else:
            messages.error(request, 'Erro ao enviar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm()
    
    context = {
        'form': form,
        'sessao': sessao,
        'title': 'Enviar Documento',
        'action': 'create',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)

@login_required
def documento_sessao_update(request, pk):
    """Editar documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    if request.method == 'POST':
        form = DocumentoSessaoForm(request.POST, request.FILES, instance=documento)
        if form.is_valid():
            form.save()
            messages.success(request, f'Documento "{documento.titulo}" atualizado com sucesso!')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
        else:
            messages.error(request, 'Erro ao atualizar documento. Verifique os dados.')
    else:
        form = DocumentoSessaoForm(instance=documento)
    
    context = {
        'form': form,
        'documento': documento,
        'sessao': documento.sessao,
        'title': 'Editar Documento',
        'action': 'update',
    }
    
    return render(request, 'militares/comissao/documentos/form.html', context)

@login_required
def documento_sessao_delete(request, pk):
    """Excluir documento da sessÃ£o (apenas admin/staff)"""
    if not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir documentos. Apenas administradores podem realizar esta aÃ§Ã£o.')
        documento = get_object_or_404(DocumentoSessao, pk=pk)
        return render(request, 'militares/comissao/documentos/delete.html', {'sessao': documento.sessao, 'documento': documento})
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    sessao_pk = documento.sessao.pk
    titulo = documento.titulo
    
    if request.method == 'POST':
        documento.delete()
        messages.success(request, f'Documento "{titulo}" excluÃ­do com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao_pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    return render(request, 'militares/comissao/documentos/delete.html', context)

@login_required
def documento_sessao_view(request, pk):
    """Visualizar documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=documento.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        # Verificar se o usuÃ¡rio Ã© membro mas nÃ£o estÃ¡ ativo
        try:
            membro_inativo = MembroComissao.objects.get(
                comissao=documento.sessao.comissao,
                usuario=request.user
            )
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este documento. Seu cadastro na comissÃ£o nÃ£o estÃ¡ ativo.')
        except MembroComissao.DoesNotExist:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este documento. VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    context = {
        'documento': documento,
        'sessao': documento.sessao,
    }
    
    if documento.can_preview():
        return render(request, 'militares/comissao/documentos/view.html', context)
    else:
        # Para arquivos que nÃ£o podem ser visualizados, fazer download
        import os
        if os.path.exists(documento.arquivo.path):
            return FileResponse(open(documento.arquivo.path, 'rb'), content_type='application/octet-stream')
        else:
            messages.error(request, 'Arquivo nÃ£o encontrado.')
            return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)

@login_required
def documento_sessao_download(request, pk):
    """Download de documento da sessÃ£o"""
    documento = get_object_or_404(DocumentoSessao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=documento.sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        # Verificar se o usuÃ¡rio Ã© membro mas nÃ£o estÃ¡ ativo
        membro_inativo = MembroComissao.objects.filter(
            comissao=documento.sessao.comissao,
            usuario=request.user
        ).first()
        if membro_inativo:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para baixar este documento. Seu cadastro na comissÃ£o nÃ£o estÃ¡ ativo.')
        else:
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para baixar este documento. VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)
    
    import os
    if os.path.exists(documento.arquivo.path):
        response = FileResponse(open(documento.arquivo.path, 'rb'))
        response['Content-Disposition'] = f'attachment; filename="{documento.filename()}"'
        return response
    else:
        messages.error(request, 'Arquivo nÃ£o encontrado.')
        return redirect('militares:sessao_comissao_detail', pk=documento.sessao.pk)

@login_required
def sessao_encerrar(request, pk):
    """Encerrar sessÃ£o com confirmaÃ§Ã£o de senha"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se todos os presentes (exceto presidente) votaram
    todos_votaram = sessao.todos_presentes_votaram_exceto_presidente
    
    # Se nÃ£o todos votaram, apenas o secretÃ¡rio pode encerrar
    if not todos_votaram and membro.cargo != 'SECRETARIO':
        messages.error(request, 'Apenas o secretÃ¡rio pode encerrar a sessÃ£o quando nem todos os membros votaram.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar membros presentes que nÃ£o votaram (excluindo o presidente)
    membros_sem_voto = []
    for presenca in sessao.presencas.filter(presente=True):
        membro_presenca = presenca.membro
        # O presidente nÃ£o Ã© obrigado a votar
        if membro_presenca.cargo == 'PRESIDENTE':
            continue
            
        votos_do_membro = VotoDeliberacao.objects.filter(
            deliberacao__sessao=sessao,
            membro=membro_presenca
        ).count()
        if votos_do_membro < sessao.deliberacoes.count():
            membros_sem_voto.append({
                'membro': membro_presenca,
                'votos_realizados': votos_do_membro,
                'total_deliberacoes': sessao.deliberacoes.count(),
                'deliberacoes_nao_votadas': sessao.deliberacoes.count() - votos_do_membro
            })
    
    if request.method == 'POST':
        password = request.POST.get('password')
        if not password:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para encerrar a sessÃ£o.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        if not request.user.check_password(password):
            messages.error(request, 'Senha incorreta. SessÃ£o nÃ£o foi encerrada.')
            return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
                'sessao': sessao,
                'comissao': sessao.comissao,
                'membros_sem_voto': membros_sem_voto,
                'todos_votaram': todos_votaram,
                'membro_usuario': membro
            })
        
        # Coletar justificativas para membros sem voto (apenas se secretÃ¡rio e nem todos votaram)
        justificativas = {}
        if membro.cargo == 'SECRETARIO' and membros_sem_voto:
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                justificativa = request.POST.get(f'justificativa_{membro_id}', '').strip()
                if justificativa:
                    justificativas[membro_id] = justificativa
        
        # Encerrar a sessÃ£o
        sessao.status = 'CONCLUIDA'
        sessao.hora_fim = timezone.now().time()
        sessao.save()
        
        # Salvar justificativas se houver
        if justificativas:
            
            justificativas_salvas = []
            for membro_info in membros_sem_voto:
                membro_id = membro_info['membro'].id
                if membro_id in justificativas:
                    # Salvar justificativa no modelo
                    justificativa_obj, created = JustificativaEncerramento.objects.get_or_create(
                        sessao=sessao,
                        membro=membro_info['membro'],
                        defaults={
                            'justificativa': justificativas[membro_id],
                            'registrado_por': request.user
                        }
                    )
                    
                    if not created:
                        # Atualizar justificativa existente
                        justificativa_obj.justificativa = justificativas[membro_id]
                        justificativa_obj.registrado_por = request.user
                        justificativa_obj.save()
                    
                    justificativas_salvas.append(
                        f"{membro_info['membro'].militar.nome_completo}: {justificativas[membro_id]}"
                    )
            
            if justificativas_salvas:
                messages.success(request, f'SessÃ£o {sessao.numero} encerrada com sucesso! {len(justificativas_salvas)} justificativa(s) registrada(s).')
        else:
            messages.success(request, f'SessÃ£o {sessao.numero} encerrada com sucesso!')
        
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Buscar votos da sessÃ£o para o modal de seleÃ§Ã£o
    votos_sessao = VotoDeliberacao.objects.filter(
        deliberacao__sessao=sessao
    ).select_related('membro__militar', 'membro__cargo', 'deliberacao').order_by('deliberacao__numero', 'membro__militar__nome_completo')
    
    return render(request, 'militares/comissao/sessoes/encerrar_confirmacao.html', {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'membros_sem_voto': membros_sem_voto,
        'todos_votaram': todos_votaram,
        'membro_usuario': membro,
        'votos_sessao': votos_sessao
    })

@login_required
def sessao_gerar_ata(request, pk):
    """Gerar ata da sessÃ£o da comissÃ£o"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se existe uma ata editada
    try:
        ata_editada = sessao.ata_editada
        tem_conteudo_editado = ata_editada and ata_editada.conteudo
    except:
        ata_editada = None
        tem_conteudo_editado = False
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
        'ata_editada': ata_editada,
        'tem_conteudo_editado': tem_conteudo_editado,
    }
    
    # Adicionar dados para assinaturas (se houver ata editada)
    if ata_editada:
        # Buscar funÃ§Ãµes do usuÃ¡rio para o modal de assinatura
        from militares.models import UsuarioFuncao
        funcoes_usuario = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO'
        ).order_by('cargo_funcao__nome')
        
        context.update({
            'funcoes_usuario': funcoes_usuario,
            'funcao_atual': request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema'),
        })
    
    return render(request, 'militares/comissao/sessoes/ata.html', context)

@login_required
def sessao_editar_ata(request, pk):
    """Editar ata da sessÃ£o com editor de texto rico"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    # Se for uma requisiÃ§Ã£o AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if request.method == 'POST':
            print(f"DEBUG: Recebendo POST AJAX - dados: {request.POST}")
            form = AtaSessaoForm(request.POST, instance=ata)
            print(f"DEBUG: Form vÃ¡lido: {form.is_valid()}")
            if form.is_valid():
                ata = form.save(commit=False)
                ata.editado_por = request.user
                # Limpar assinaturas eletrÃ´nicas ao editar a ata
                ata.assinaturas.all().delete()
                ata.save()
                print(f"DEBUG: Ata salva com sucesso - versÃ£o: {ata.versao}")
                return JsonResponse({
                    'success': True,
                    'message': f'Ata salva com sucesso! VersÃ£o {ata.versao}. As assinaturas eletrÃ´nicas foram removidas.',
                    'versao': ata.versao
                })
            else:
                print(f"DEBUG: Erros no formulÃ¡rio: {form.errors}")
                return JsonResponse({
                    'success': False,
                    'errors': form.errors
                })
        else:
            return JsonResponse({
                'success': False,
                'errors': {'__all__': ['MÃ©todo nÃ£o permitido']}
            })
    
    # Processamento normal (nÃ£o-AJAX)
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            # Limpar assinaturas eletrÃ´nicas ao editar a ata
            ata.assinaturas.all().delete()
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! VersÃ£o {ata.versao}. As assinaturas eletrÃ´nicas foram removidas e serÃ¡ necessÃ¡rio assinar novamente.')
            return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    return render(request, 'militares/comissao/sessoes/editar_ata.html', context)

@login_required
def ata_conteudo_ajax(request, pk):
    """Retornar conteÃºdo da ata via AJAX"""
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'VocÃª nÃ£o Ã© membro desta comissÃ£o.'
            })
        
        return JsonResponse({
            'success': True,
            'conteudo': ata.conteudo or '',
            'sessao_numero': ata.sessao.numero,
            'data_sessao': ata.sessao.data_sessao.strftime('%d/%m/%Y'),
            'hora_sessao': ata.sessao.hora_inicio.strftime('%H:%M'),
            'local_sessao': ata.sessao.local,
            'versao': ata.versao,
            'editado_por': ata.editado_por.get_full_name() or ata.editado_por.username,
            'data_edicao': ata.data_edicao.strftime('%d/%m/%Y %H:%M')
        })
        
    except AtaSessao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Ata nÃ£o encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao carregar ata: {str(e)}'
        })

@login_required
def sessao_editar_ata_popup(request, pk):
    """Editar ata da sessÃ£o em pÃ¡gina separada/popup"""
    sessao = get_object_or_404(SessaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Preparar dados para a ata
    context = {
        'sessao': sessao,
        'comissao': sessao.comissao,
        'presencas': sessao.presencas.all(),
        'deliberacoes': sessao.deliberacoes.all().order_by('numero'),
        'membro_usuario': membro,
        'justificativas_encerramento': sessao.justificativas_encerramento.all(),
        'data_geracao': timezone.now(),
    }
    
    try:
        ata = sessao.ata_editada
    except AtaSessao.DoesNotExist:
        ata = AtaSessao(sessao=sessao, editado_por=request.user)
    
    if request.method == 'POST':
        form = AtaSessaoForm(request.POST, instance=ata)
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.save()
            messages.success(request, f'Ata editada e salva com sucesso! VersÃ£o {ata.versao}.')
            return redirect('militares:sessao_editar_ata_popup', pk=sessao.pk)
    else:
        form = AtaSessaoForm(instance=ata)
    
    context['form'] = form
    context['ata_salva'] = ata if ata.pk else None
    
    # Se for uma requisiÃ§Ã£o AJAX, retornar JSON
    if request.headers.get('X-Requested-With') == 'XMLHttpRequest':
        if form.is_valid():
            ata = form.save(commit=False)
            ata.editado_por = request.user
            ata.assinaturas.all().delete()
            ata.save()
            return JsonResponse({
                'success': True,
                'message': f'Ata salva com sucesso! VersÃ£o {ata.versao}.',
                'versao': ata.versao
            })
        else:
            return JsonResponse({
                'success': False,
                'errors': form.errors
            })
    
    return render(request, 'militares/comissao/sessoes/editar_ata_popup.html', context)

@login_required
def ata_para_assinatura(request, pk):
    """Marcar ata para assinatura dos membros"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        ata.status = 'PARA_ASSINATURA'
        ata.save()
        messages.success(request, 'Ata marcada para assinatura dos membros.')
        return redirect('militares:ata_assinaturas', pk=pk)
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': ata.sessao.presencas.filter(presente=True),
    }
    return render(request, 'militares/comissao/sessoes/ata_para_assinatura.html', context)

@login_required
def ata_assinaturas(request, pk):
    """Gerenciar assinaturas da ata"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        # Processar assinatura
        membro_id = request.POST.get('membro_id')
        observacoes = request.POST.get('observacoes', '').strip()
        
        if membro_id:
            try:
                membro_para_assinar = MembroComissao.objects.get(id=membro_id)
                # Verificar se o membro estava presente
                if not ata.sessao.presencas.filter(membro=membro_para_assinar, presente=True).exists():
                    messages.error(request, 'Apenas membros presentes podem assinar a ata.')
                    return redirect('militares:ata_assinaturas', pk=pk)
                
                # Criar ou atualizar assinatura
                assinatura, created = AssinaturaAta.objects.get_or_create(
                    ata=ata,
                    membro=membro_para_assinar,
                    defaults={
                        'assinado_por': request.user,
                        'observacoes': observacoes
                    }
                )
                
                if not created:
                    assinatura.assinado_por = request.user
                    assinatura.observacoes = observacoes
                    assinatura.save()
                
                messages.success(request, f'Assinatura de {membro_para_assinar.militar.nome_completo} registrada com sucesso!')
                
                # Verificar se todos assinaram
                if ata.pode_ser_finalizada():
                    ata.status = 'ASSINADA'
                    ata.save()
                    messages.info(request, 'Todos os membros presentes assinaram a ata!')
                
            except MembroComissao.DoesNotExist:
                messages.error(request, 'Membro nÃ£o encontrado.')
    
    # Obter membros presentes e suas assinaturas
    membros_presentes = ata.sessao.presencas.filter(presente=True).select_related('membro__militar')
    assinaturas = ata.assinaturas.select_related('membro__militar', 'assinado_por')
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': membros_presentes,
        'assinaturas': assinaturas,
        'membro_usuario': membro,
    }
    return render(request, 'militares/comissao/sessoes/ata_assinaturas.html', context)

@login_required
def ata_gerar_pdf(request, pk):
    """Gerar PDF da ata finalizada"""
    from reportlab.lib.pagesizes import A4
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.lib.enums import TA_JUSTIFY
    from io import BytesIO
    import html2text
    import os
    import qrcode
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Permitir gerar PDF para qualquer status da ata
    # if ata.status != 'ASSINADA' and ata.status != 'FINALIZADA':
    #     messages.error(request, 'A ata deve estar assinada para gerar o PDF.')
    #     return redirect('militares:ata_assinaturas', pk=pk)
    
    # Criar o PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()
    
    # Configurar fonte para suportar caracteres especiais
    from reportlab.pdfbase import pdfmetrics
    from reportlab.pdfbase.ttfonts import TTFont
    
    # Registrar fonte que suporta UTF-8 (usando fonte padrÃ£o do sistema)
    try:
        # Tentar usar fonte Arial que suporta caracteres especiais
        pdfmetrics.registerFont(TTFont('Arial', 'arial.ttf'))
        font_name = 'Arial'
    except:
        # Se nÃ£o conseguir, usar fonte padrÃ£o
        font_name = 'Helvetica'
    
    # Estilos customizados com fonte que suporta UTF-8
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11, fontName=font_name)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName=font_name, fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1, fontName=font_name)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8, fontName=font_name)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9, fontName=font_name)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11, spaceAfter=8, fontName=font_name)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6, fontName=font_name)
    
    # Estilos para cabeÃ§alho institucional (padrÃ£o do sistema)
    style_header = ParagraphStyle('header', parent=styles['Heading1'], fontSize=12, alignment=1, spaceAfter=8, spaceBefore=12, fontName=font_name)
    style_subheader = ParagraphStyle('subheader', parent=styles['Heading2'], fontSize=11, alignment=1, spaceAfter=6, spaceBefore=10, fontName=font_name)
    
    # Novos estilos para formataÃ§Ã£o avanÃ§ada
    style_heading1 = ParagraphStyle('heading1', parent=styles['Heading1'], fontSize=12, spaceAfter=8, spaceBefore=12, fontName=font_name)
    style_heading2 = ParagraphStyle('heading2', parent=styles['Heading2'], fontSize=11, spaceAfter=6, spaceBefore=10, fontName=font_name)
    style_heading3 = ParagraphStyle('heading3', parent=styles['Heading3'], fontSize=10, spaceAfter=4, spaceBefore=8, fontName=font_name)
    style_paragraph = ParagraphStyle('paragraph', parent=styles['Normal'], fontSize=10, spaceAfter=6, alignment=4, firstLineIndent=20, fontName=font_name)
    style_list_item = ParagraphStyle('list_item', parent=styles['Normal'], fontSize=10, spaceAfter=4, leftIndent=20, firstLineIndent=-10, fontName=font_name)
    style_quote = ParagraphStyle('quote', parent=styles['Normal'], fontSize=10, spaceAfter=6, leftIndent=30, rightIndent=30, fontName=font_name)
    
    story = []
    
    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional (igual aos quadros)
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
    ]
    
    # Determinar o tipo de comissÃ£o baseado no campo tipo
    if ata.sessao.comissao.tipo == 'CPO':
        tipo_comissao = "COMISSÃƒO DE PROMOÃ‡Ã•ES DE OFICIAIS - CBMEPI-PI"
    else:
        tipo_comissao = "COMISSÃƒO DE PROMOÃ‡Ã•ES DE PRAÃ‡AS - CBMEPI-PI"
    
    cabecalho.extend([
        tipo_comissao,
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ])
    
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))
    
    # TÃ­tulo centralizado e sublinhado (mesma visualizaÃ§Ã£o do HTML)
    if ata.sessao.comissao.tipo == 'CPO':
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE OFICIAIS DO CBMEPI"
    elif ata.sessao.comissao.tipo == 'CPP':
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DE PRAÃ‡AS DO CBMEPI"
    else:
        tipo_comissao = "ATA DA REUNIÃƒO DA COMISSÃƒO DE PROMOÃ‡ÃƒO DO CBMEPI"
    
    titulo = f'<u>{tipo_comissao}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 56.7))  # 2cm de espaÃ§amento apÃ³s o tÃ­tulo
    
    # ConteÃºdo da ata (mantendo HTML do CKEditor, mas limpo para ReportLab)
    style_html = ParagraphStyle('html', parent=styles['Normal'], fontSize=11, alignment=TA_JUSTIFY, spaceAfter=8, leading=16, fontName=font_name)
    conteudo_limpo = clean_html_for_reportlab(ata.conteudo)
    
    try:
        story.append(Paragraph(conteudo_limpo, style_html))
    except Exception as e:
        # Se houver erro no parsing do HTML, tentar com texto simples
        print(f"Erro ao processar HTML da ata: {str(e)}")
        # Remover todas as tags HTML e usar apenas texto
        import re
        texto_simples = re.sub(r'<[^>]+>', '', ata.conteudo or '')
        texto_simples = unescape(texto_simples)
        story.append(Paragraph(texto_simples, style_html))
    story.append(Spacer(1, 20))
    
    # Data da sessÃ£o centralizada apÃ³s o conteÃºdo (sistema automÃ¡tico)
    if ata.sessao.data_sessao:
        # Converter data para extenso
        from datetime import datetime
        data_sessao = ata.sessao.data_sessao
        
        # Mapeamento de meses
        meses = {
            1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril',
            5: 'maio', 6: 'junho', 7: 'julho', 8: 'agosto',
            9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
        }
        
        dia = data_sessao.day
        mes = meses[data_sessao.month]
        ano = data_sessao.year
        
        # Formatar data por extenso
        data_extenso = f"Teresina, {dia} de {mes} de {ano}"
        story.append(Paragraph(f"<center><b>{data_extenso}</b></center>", style_center))
    story.append(Spacer(1, 30))
    
    # Assinaturas manuais
    story.append(Spacer(1, 15))
    
    assinaturas = ata.assinaturas.select_related('membro__militar').order_by('data_assinatura')
    for assinatura in assinaturas:
        # FunÃ§Ã£o para obter a abreviaÃ§Ã£o correta do quadro
        def get_quadro_abreviado(quadro):
            if quadro == 'Complementar':
                return 'QOBM/C'
            elif quadro == 'Combatente':
                return 'QOBM/Comb.'
            elif quadro == 'Engenheiro':
                return 'QOBM/E'
            elif quadro == 'SaÃºde':
                return 'QOBM/S'
            else:
                return quadro
        
        # Nome, posto e quadro na mesma linha
        quadro_abreviado = get_quadro_abreviado(assinatura.membro.militar.get_quadro_display())
        nome_posto_quadro = f"{assinatura.membro.militar.nome_completo} - {assinatura.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
        story.append(Paragraph(f"<center>{nome_posto_quadro}</center>", style_center))
        
        # Tipo de membro e funÃ§Ã£o
        tipo_membro = assinatura.membro.get_tipo_display()
        cargo_membro = assinatura.membro.cargo.nome if assinatura.membro.cargo else ""
        if cargo_membro:
            story.append(Paragraph(f"<center>{tipo_membro} - {cargo_membro}</center>", style_center))
        else:
            story.append(Paragraph(f"<center>{tipo_membro}</center>", style_center))
        
        if assinatura.observacoes:
            story.append(Paragraph(f"Obs: {assinatura.observacoes}", style_signature))
        story.append(Spacer(1, 10))
    
    # RodapÃ© com Assinaturas EletrÃ´nicas e QR Code
    story.append(Spacer(1, 20))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Buscar todas as assinaturas vÃ¡lidas da ata (da mais recente para a mais antiga)
    assinaturas_eletronicas = ata.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    if assinaturas_eletronicas.exists():
        for i, assinatura_eletronica in enumerate(assinaturas_eletronicas):
            # InformaÃ§Ãµes de assinatura eletrÃ´nica
            nome_assinante = assinatura_eletronica.assinado_por.get_full_name() or assinatura_eletronica.assinado_por.username
            # Se o nome estiver vazio, usar um nome padrÃ£o
            if not nome_assinante or nome_assinante.strip() == '':
                nome_assinante = "UsuÃ¡rio do Sistema"
            
            from .utils import formatar_data_assinatura
            data_formatada, hora_formatada = formatar_data_assinatura(assinatura_eletronica.data_assinatura)
            
            # FunÃ§Ã£o para obter a abreviaÃ§Ã£o correta do quadro
            def get_quadro_abreviado(quadro):
                if quadro == 'Complementar':
                    return 'QOBM/C'
                elif quadro == 'Combatente':
                    return 'QOBM/Comb.'
                elif quadro == 'Engenheiro':
                    return 'QOBM/E'
                elif quadro == 'SaÃºde':
                    return 'QOBM/S'
                else:
                    return quadro
            
            # Nome, posto e quadro do militar
            quadro_abreviado = get_quadro_abreviado(assinatura_eletronica.membro.militar.get_quadro_display())
            nome_posto_quadro = f"{assinatura_eletronica.membro.militar.nome_completo} - {assinatura_eletronica.membro.militar.get_posto_graduacao_display()} {quadro_abreviado}"
            
            # Obter a funÃ§Ã£o da assinatura (que foi capturada durante a assinatura)
            funcao_atual = assinatura_eletronica.funcao_assinatura or 'UsuÃ¡rio do Sistema'
            
            texto_assinatura = f"Documento assinado eletronicamente por {nome_posto_quadro} - {funcao_atual}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
            
            # Tabela das assinaturas: Logo + Texto de assinatura
            assinatura_data = [
                [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
            ]
            
            assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
            assinatura_table.setStyle(TableStyle([
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
                ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
                ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
                ('LEFTPADDING', (0, 0), (-1, -1), 2),
                ('RIGHTPADDING', (0, 0), (-1, -1), 2),
                ('TOPPADDING', (0, 0), (-1, -1), 2),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
            ]))
            
            story.append(assinatura_table)
            
            # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
            if i < len(assinaturas_eletronicas) - 1:
                story.append(Spacer(1, 8))
                story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=8, spaceBefore=8, color=colors.lightgrey))
                story.append(Spacer(1, 8))
    else:
        # Se nÃ£o houver assinaturas eletrÃ´nicas, mostrar apenas documento gerado pelo usuÃ¡rio logado
        agora = timezone.localtime(timezone.now())
        nome_usuario = request.user.get_full_name() or request.user.username
        if not nome_usuario or nome_usuario.strip() == '':
            nome_usuario = "UsuÃ¡rio do Sistema"
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        texto_geracao = f"Documento gerado pelo usuÃ¡rio {nome_usuario} em {data_formatada}, Ã s {hora_formatada}."
        story.append(Paragraph(texto_geracao, style_small))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a funÃ§Ã£o utilitÃ¡ria para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(ata, request, tipo_documento='ata')
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Gerar PDF
    doc.build(story)
    buffer.seek(0)
    
    # Criar resposta HTTP
    response = HttpResponse(buffer.getvalue(), content_type='application/pdf')
    response['Content-Disposition'] = f'inline; filename="ata_sessao_{ata.sessao.numero}.pdf"'
    
    return response

@login_required
def ata_finalizar(request, pk):
    """Finalizar ata apÃ³s todas as assinaturas"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        if ata.pode_ser_finalizada():
            ata.status = 'FINALIZADA'
            ata.data_finalizacao = timezone.now()
            ata.save()
            messages.success(request, 'Ata finalizada com sucesso! Agora vocÃª pode gerar o PDF.')
        else:
            messages.error(request, 'A ata nÃ£o pode ser finalizada. Todos os membros presentes devem assinar primeiro.')
    
    return redirect('militares:ata_assinaturas', pk=pk)

def clean_html_for_reportlab(html):
    if not html:
        return ""
    
    # Decodifica entidades HTML primeiro
    html = unescape(html)
    
    # Remove comentÃ¡rios HTML
    html = re.sub(r'<!--.*?-->', '', html, flags=re.DOTALL)
    
    # Remove atributos style, id, class, target, etc.
    html = re.sub(r'(<\w+)([^>]*)(style|id|class|target|rel|onclick|onmouseover|onmouseout|align|width|height|data-[^=]*)=["\"][^"\"]*["\"]', r'\1', html)
    
    # Remove todos os atributos de todas as tags, exceto href em <a>
    html = re.sub(r'<(?!a\b)(\w+)[^>]*>', r'<\1>', html)
    
    # Remove atributos de <a> exceto href
    html = re.sub(r'<a\s+[^>]*?href=(["\"][^"\"]*["\"])[^>]*>', r'<a href=\1>', html)
    
    # Remove tags nÃ£o suportadas (mantÃ©m apenas p, b, i, u, br, a, ul, ol, li, strong, em)
    html = re.sub(r'</?(?!p\b|b\b|i\b|u\b|br\b|a\b|ul\b|ol\b|li\b|strong\b|em\b)[a-zA-Z0-9]+[^>]*>', '', html)
    
    # Corrigir tags <br> nÃ£o fechadas - substituir por <br/>
    html = re.sub(r'<br\s*>', '<br/>', html)
    html = re.sub(r'<br\s+[^>]*>', '<br/>', html)
    
    # Corrigir tags <br> com fechamento incorreto
    html = re.sub(r'<br\s*></br>', '<br/>', html)
    
    # Remove espaÃ§os extras entre tags
    html = re.sub(r'>\s+<', '><', html)
    
    # Remove espaÃ§os em branco no inÃ­cio e fim
    html = html.strip()
    
    return html

@login_required
def modelo_ata_list(request):
    print(f"=== INÃCIO modelo_ata_list ===")
    print(f"GET params: {request.GET}")
    print(f"Headers: {dict(request.headers)}")
    
    modelos = ModeloAta.objects.all()
    tipo_comissao = request.GET.get('tipo_comissao')
    if tipo_comissao:
        modelos = modelos.filter(tipo_comissao=tipo_comissao)
    tipo_sessao = request.GET.get('tipo_sessao')
    if tipo_sessao:
        modelos = modelos.filter(tipo_sessao=tipo_sessao)
    ativo = request.GET.get('ativo')
    if ativo is not None:
        modelos = modelos.filter(ativo=ativo == 'true')
    padrao = request.GET.get('padrao')
    if padrao is not None:
        modelos = modelos.filter(padrao=padrao == 'true')
    
    print(f"Modelos encontrados: {modelos.count()}")
    
    context = {
        'modelos': modelos,
        'tipos_comissao': ModeloAta.TIPO_COMISSAO_CHOICES,
        'tipos_sessao': ModeloAta.TIPO_SESSAO_CHOICES,
        'filtros': {
            'tipo_comissao': tipo_comissao,
            'tipo_sessao': tipo_sessao,
            'ativo': ativo,
            'padrao': padrao,
        }
    }
    
    # Verificar se Ã© uma requisiÃ§Ã£o para JSON
    format_json = request.GET.get('format') == 'json'
    ajax_request = request.GET.get('ajax') == '1'
    
    print(f"Format JSON: {format_json}")
    print(f"Ajax Request: {ajax_request}")
    
    if format_json or ajax_request:
        print("=== RETORNANDO JSON ===")
        modelos_data = []
        for modelo in modelos:
            modelos_data.append({
                'id': modelo.pk,
                'nome': modelo.nome,
                'descricao': modelo.descricao,
                'tipo_comissao': modelo.tipo_comissao,
                'tipo_comissao_display': modelo.get_tipo_comissao_display(),
                'tipo_sessao': modelo.tipo_sessao,
                'tipo_sessao_display': modelo.get_tipo_sessao_display(),
                'ativo': modelo.ativo,
                'padrao': modelo.padrao,
                'criado_por': modelo.criado_por.get_full_name() if modelo.criado_por else modelo.criado_por.username,
                'data_criacao': modelo.data_criacao.strftime('%d/%m/%Y %H:%M') if modelo.data_criacao else '',
            })
        
        response_data = {
            'success': True,
            'modelos': modelos_data
        }
        print(f"Response data: {response_data}")
        return JsonResponse(response_data)
    
    print("=== RETORNANDO HTML ===")
    return render(request, 'militares/modelo_ata/list.html', context)

@login_required
def modelo_ata_create(request):
    if request.method == 'POST':
        form = ModeloAtaForm(request.POST)
        if form.is_valid():
            modelo = form.save(commit=False)
            modelo.criado_por = request.user
            modelo.save()
            messages.success(request, f'Modelo "{modelo.nome}" criado com sucesso!')
            return redirect('militares:modelo_ata_list')
    else:
        form = ModeloAtaForm()
    context = {
        'form': form,
        'titulo': 'Criar Novo Modelo de Ata',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_update(request, pk):
    print(f"=== INÃCIO modelo_ata_update ===")
    print(f"PK: {pk}")
    print(f"MÃ©todo: {request.method}")
    print(f"Headers: {dict(request.headers)}")
    
    modelo = get_object_or_404(ModeloAta, pk=pk)
    print(f"Modelo encontrado: {modelo.nome}")
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    print(f"Ã‰ AJAX: {is_ajax}")
    
    if request.method == 'POST':
        print("=== PROCESSANDO POST ===")
        print(f"POST data: {request.POST}")
        
        try:
            # Obter dados do formulÃ¡rio
            nome = request.POST.get('nome', '').strip()
            descricao = request.POST.get('descricao', '').strip()
            tipo_comissao = request.POST.get('tipo_comissao', 'GERAL')
            tipo_sessao = request.POST.get('tipo_sessao', 'GERAL')
            conteudo = request.POST.get('conteudo', '').strip()
            
            print(f"Nome: {nome}")
            print(f"DescriÃ§Ã£o: {descricao}")
            print(f"Tipo ComissÃ£o: {tipo_comissao}")
            print(f"Tipo SessÃ£o: {tipo_sessao}")
            print(f"ConteÃºdo: {conteudo[:100] if conteudo else 'VAZIO'}")
            
            # ValidaÃ§Ãµes
            if not nome:
                error_msg = 'Nome do modelo Ã© obrigatÃ³rio.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:modelo_ata_list')
            
            if not conteudo:
                error_msg = 'ConteÃºdo do modelo Ã© obrigatÃ³rio.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:modelo_ata_list')
            
            # Atualizar o modelo
            modelo.nome = nome
            modelo.descricao = descricao
            modelo.tipo_comissao = tipo_comissao
            modelo.tipo_sessao = tipo_sessao
            modelo.conteudo = conteudo
            modelo.save()
            
            print(f"Modelo atualizado com sucesso: {modelo.nome}")
            
            success_msg = f'Modelo "{modelo.nome}" atualizado com sucesso!'
            
            if is_ajax:
                return JsonResponse({
                    'success': True,
                    'message': success_msg,
                    'modelo_id': modelo.pk,
                    'modelo_nome': modelo.nome
                })
            else:
                messages.success(request, success_msg)
                return redirect('militares:modelo_ata_list')
                
        except Exception as e:
            print(f"ERRO ao atualizar modelo: {str(e)}")
            import traceback
            traceback.print_exc()
            
            error_msg = f'Erro ao atualizar modelo: {str(e)}'
            
            if is_ajax:
                return JsonResponse({'success': False, 'error': error_msg})
            else:
                messages.error(request, error_msg)
                return redirect('militares:modelo_ata_list')
    else:
        print("=== MÃ‰TODO GET ===")
        form = ModeloAtaForm(instance=modelo)
    
    context = {
        'form': form,
        'modelo': modelo,
        'titulo': f'Editar Modelo: {modelo.nome}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    return render(request, 'militares/modelo_ata/form.html', context)

@login_required
def modelo_ata_delete(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if request.method == 'POST':
        nome = modelo.nome
        modelo.delete()
        
        if is_ajax:
            return JsonResponse({
                'success': True,
                'message': f'Modelo "{nome}" excluÃ­do com sucesso!'
            })
        else:
            messages.success(request, f'Modelo "{nome}" excluÃ­do com sucesso!')
            return redirect('militares:modelo_ata_list')
    
    context = {
        'modelo': modelo,
        'titulo': f'Excluir Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/delete.html', context)

@login_required
def modelo_ata_detail(request, pk):
    modelo = get_object_or_404(ModeloAta, pk=pk)
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if is_ajax:
        return JsonResponse({
            'success': True,
            'modelo': {
                'id': modelo.pk,
                'nome': modelo.nome,
                'descricao': modelo.descricao,
                'tipo_comissao': modelo.tipo_comissao,
                'tipo_comissao_display': modelo.get_tipo_comissao_display(),
                'tipo_sessao': modelo.tipo_sessao,
                'tipo_sessao_display': modelo.get_tipo_sessao_display(),
                'conteudo': modelo.conteudo,
                'ativo': modelo.ativo,
                'padrao': modelo.padrao,
                'criado_por': modelo.criado_por.get_full_name() if modelo.criado_por else modelo.criado_por.username,
                'data_criacao': modelo.data_criacao.strftime('%d/%m/%Y %H:%M') if modelo.data_criacao else '',
            }
        })
    
    context = {
        'modelo': modelo,
        'titulo': f'Modelo: {modelo.nome}'
    }
    return render(request, 'militares/modelo_ata/detail.html', context)

@login_required
def modelo_ata_aplicar(request, sessao_pk):
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    try:
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    # Verificar se Ã© uma requisiÃ§Ã£o AJAX
    is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'
    
    if request.method == 'POST':
        modelo_id = request.POST.get('modelo_id')
        if modelo_id:
            try:
                modelo = ModeloAta.objects.get(pk=modelo_id, ativo=True)
                if modelo.pode_ser_usado_para(sessao):
                    conteudo_aplicado = modelo.aplicar_variaveis(sessao)
                    try:
                        ata = sessao.ata_editada
                    except AtaSessao.DoesNotExist:
                        ata = AtaSessao(sessao=sessao, editado_por=request.user)
                    ata.conteudo = conteudo_aplicado
                    ata.editado_por = request.user
                    ata.save()
                    
                    if is_ajax:
                        return JsonResponse({
                            'success': True,
                            'message': f'Modelo "{modelo.nome}" aplicado com sucesso!',
                            'conteudo': conteudo_aplicado
                        })
                    else:
                        messages.success(request, f'Modelo "{modelo.nome}" aplicado com sucesso!')
                        return redirect('militares:sessao_editar_ata', pk=sessao.pk)
                else:
                    error_msg = 'Este modelo nÃ£o pode ser usado para esta sessÃ£o.'
                    if is_ajax:
                        return JsonResponse({'success': False, 'error': error_msg})
                    else:
                        messages.error(request, error_msg)
            except ModeloAta.DoesNotExist:
                error_msg = 'Modelo nÃ£o encontrado.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
    
    modelos_disponiveis = ModeloAta.get_modelos_disponiveis(sessao)
    modelo_padrao = ModeloAta.get_modelo_padrao(sessao)
    context = {
        'sessao': sessao,
        'modelos_disponiveis': modelos_disponiveis,
        'modelo_padrao': modelo_padrao,
        'titulo': f'Aplicar Modelo Ã  SessÃ£o {sessao.numero}'
    }
    return render(request, 'militares/modelo_ata/aplicar.html', context)

@login_required
def modelo_ata_salvar_atual(request, sessao_pk):
    
    print(f"=== INÃCIO DA FUNÃ‡ÃƒO modelo_ata_salvar_atual ===")
    print(f"SessÃ£o PK: {sessao_pk}")
    print(f"MÃ©todo: {request.method}")
    
    sessao = get_object_or_404(SessaoComissao, pk=sessao_pk)
    print(f"SessÃ£o encontrada: {sessao}")
    
    # Verificar se existe uma ata
    try:
        ata = sessao.ata_editada
        print(f"Ata encontrada: {ata}")
        print(f"ConteÃºdo da ata: {ata.conteudo[:100] if ata.conteudo else 'VAZIO'}")
    except AtaSessao.DoesNotExist:
        print("ERRO: NÃ£o existe uma ata para esta sessÃ£o")
        messages.error(request, 'NÃ£o existe uma ata para esta sessÃ£o.')
        return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    
    # Criar formulÃ¡rio personalizado sem o campo conteudo
    class ModeloAtaSalvarForm(forms.ModelForm):
        class Meta:
            model = ModeloAta
            fields = ['nome', 'descricao', 'tipo_comissao', 'tipo_sessao', 'ativo', 'padrao']
            widgets = {
                'nome': forms.TextInput(attrs={
                    'class': 'form-control',
                    'placeholder': 'Ex: Modelo PadrÃ£o CPO OrdinÃ¡ria'
                }),
                'descricao': forms.Textarea(attrs={
                    'class': 'form-control',
                    'rows': 3,
                    'placeholder': 'DescriÃ§Ã£o do modelo e quando usÃ¡-lo...'
                }),
                'tipo_comissao': forms.Select(attrs={'class': 'form-control'}),
                'tipo_sessao': forms.Select(attrs={'class': 'form-control'}),
                'ativo': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
                'padrao': forms.CheckboxInput(attrs={'class': 'form-check-input'}),
            }
    
    if request.method == 'POST':
        print("=== PROCESSANDO POST ===")
        print(f"POST data: {request.POST}")
        
        # Verificar se Ã© uma requisiÃ§Ã£o AJAX
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest' or request.content_type == 'application/json'
        
        try:
            # Obter dados do formulÃ¡rio
            nome = request.POST.get('nome', '').strip()
            descricao = request.POST.get('descricao', '').strip()
            tipo_comissao = request.POST.get('tipo_comissao', 'GERAL')
            tipo_sessao = request.POST.get('tipo_sessao', 'GERAL')
            conteudo = request.POST.get('conteudo', '').strip()
            
            print(f"Nome: {nome}")
            print(f"DescriÃ§Ã£o: {descricao}")
            print(f"Tipo ComissÃ£o: {tipo_comissao}")
            print(f"Tipo SessÃ£o: {tipo_sessao}")
            print(f"ConteÃºdo: {conteudo[:100] if conteudo else 'VAZIO'}")
            
            # ValidaÃ§Ãµes
            if not nome:
                error_msg = 'Nome do modelo Ã© obrigatÃ³rio.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:sessao_editar_ata', pk=sessao.pk)
            
            if not conteudo:
                error_msg = 'ConteÃºdo do modelo Ã© obrigatÃ³rio.'
                if is_ajax:
                    return JsonResponse({'success': False, 'error': error_msg})
                else:
                    messages.error(request, error_msg)
                    return redirect('militares:sessao_editar_ata', pk=sessao.pk)
            
            # Criar o modelo
            modelo = ModeloAta.objects.create(
                nome=nome,
                descricao=descricao,
                tipo_comissao=tipo_comissao,
                tipo_sessao=tipo_sessao,
                conteudo=conteudo,
                criado_por=request.user,
                ativo=True,
                padrao=False
            )
            
            print(f"Modelo salvo com sucesso: {modelo.nome} (ID: {modelo.pk})")
            
            success_msg = f'Modelo "{modelo.nome}" criado com sucesso!'
            
            if is_ajax:
                return JsonResponse({
                    'success': True,
                    'message': success_msg,
                    'modelo_id': modelo.pk,
                    'modelo_nome': modelo.nome
                })
            else:
                messages.success(request, success_msg)
                return redirect('militares:modelo_ata_list')
                
        except Exception as e:
            print(f"ERRO ao salvar modelo: {str(e)}")
            import traceback
            traceback.print_exc()
            
            error_msg = f'Erro ao salvar modelo: {str(e)}'
            
            if is_ajax:
                return JsonResponse({'success': False, 'error': error_msg})
            else:
                messages.error(request, error_msg)
                return redirect('militares:sessao_editar_ata', pk=sessao.pk)
    else:
        print("=== MÃ‰TODO GET ===")
        form = ModeloAtaSalvarForm(initial={
            'nome': f'Modelo da SessÃ£o {sessao.numero} - {sessao.comissao.nome}',
            'tipo_comissao': sessao.comissao.tipo,
            'tipo_sessao': sessao.tipo,
            'descricao': f'Modelo criado a partir da ata da sessÃ£o {sessao.numero} realizada em {sessao.data_sessao.strftime("%d/%m/%Y")}',
        })
    
    context = {
        'form': form,
        'sessao': sessao,
        'ata': ata,
        'titulo': f'Salvar Ata como Modelo - SessÃ£o {sessao.numero}',
        'variaveis_disponiveis': [
            '{{sessao.numero}} - NÃºmero da sessÃ£o',
            '{{sessao.data_sessao}} - Data da sessÃ£o',
            '{{sessao.hora_inicio}} - Hora de inÃ­cio',
            '{{sessao.hora_fim}} - Hora de tÃ©rmino',
            '{{sessao.local}} - Local da sessÃ£o',
            '{{sessao.tipo}} - Tipo da sessÃ£o',
            '{{sessao.pauta}} - Pauta da sessÃ£o',
            '{{comissao.nome}} - Nome da comissÃ£o',
            '{{comissao.tipo}} - Tipo da comissÃ£o',
        ]
    }
    
    print("=== RENDERIZANDO TEMPLATE ===")
    return render(request, 'militares/modelo_ata/salvar_atual.html', context)

@login_required
@comissao_acesso_total
def deliberacao_comissao_resultado(request, sessao_pk):
    """Exibir resultado das deliberaÃ§Ãµes com votos dos membros"""
    try:
        sessao = SessaoComissao.objects.get(pk=sessao_pk)
        comissao = sessao.comissao
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    user_membro = MembroComissao.objects.filter(
        comissao=comissao,
        usuario=request.user,
        ativo=True
    ).first()
    
    # Buscar todas as deliberaÃ§Ãµes da sessÃ£o com seus votos
    deliberacoes = sessao.deliberacoes.prefetch_related('votos__membro__militar').all()
    
    context = {
        'comissao': comissao,
        'sessao': sessao,
        'deliberacoes': deliberacoes,
        'user_membro': user_membro,
        'membros_presentes': [p.membro for p in sessao.presencas.filter(presente=True)],
    }
    return render(request, 'militares/comissao/deliberacoes/resultado.html', context)

@login_required
@comissao_acesso_total
def deliberacao_resultado_update(request, pk):
    """Editar resultado da deliberaÃ§Ã£o apÃ³s votaÃ§Ã£o concluÃ­da"""
    deliberacao = get_object_or_404(DeliberacaoComissao, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    membro = MembroComissao.objects.filter(
        comissao=deliberacao.sessao.comissao,
        usuario=request.user,
        ativo=True
    ).first()
    if not membro:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=deliberacao.sessao.pk)
    
    # Verificar se a votaÃ§Ã£o foi concluÃ­da
    total_presentes = deliberacao.sessao.presencas.filter(presente=True).count()
    total_votos = deliberacao.votos.count()
    
    if total_votos < total_presentes:
        messages.error(request, 
            f'A votaÃ§Ã£o ainda nÃ£o foi concluÃ­da ({total_votos}/{total_presentes} votos). '
            'O resultado sÃ³ pode ser registrado apÃ³s todos os membros presentes votarem.'
        )
        return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    
    if request.method == 'POST':
        # Criar formulÃ¡rio apenas com o campo resultado
        class ResultadoForm(forms.Form):
            resultado = forms.CharField(
                widget=forms.Textarea(attrs={
                    'rows': 6,
                    'class': 'form-control',
                    'placeholder': 'Registre aqui a decisÃ£o ou resultado da deliberaÃ§Ã£o apÃ³s a votaÃ§Ã£o...'
                }),
                required=True,
                label='Resultado da DeliberaÃ§Ã£o'
            )
        
        form = ResultadoForm(request.POST)
        if form.is_valid():
            deliberacao.resultado = form.cleaned_data['resultado']
            deliberacao.save()
            
            messages.success(request, 'Resultado da deliberaÃ§Ã£o registrado com sucesso!')
            return redirect('militares:deliberacao_comissao_detail', pk=deliberacao.pk)
    else:
        # FormulÃ¡rio inicial com o resultado atual
        class ResultadoForm(forms.Form):
            resultado = forms.CharField(
                widget=forms.Textarea(attrs={
                    'rows': 6,
                    'class': 'form-control',
                    'placeholder': 'Registre aqui a decisÃ£o ou resultado da deliberaÃ§Ã£o apÃ³s a votaÃ§Ã£o...'
                }),
                required=True,
                label='Resultado da DeliberaÃ§Ã£o',
                initial=deliberacao.resultado
            )
        
        form = ResultadoForm()
    
    context = {
        'deliberacao': deliberacao,
        'form': form,
        'sessao': deliberacao.sessao,
        'comissao': deliberacao.sessao.comissao,
        'membro': membro,
        'total_presentes': total_presentes,
        'total_votos': total_votos,
        'title': f'Registrar Resultado - DeliberaÃ§Ã£o {deliberacao.numero}'
    }
    
    return render(request, 'militares/comissao/deliberacoes/resultado_form.html', context)

@login_required
def notificacoes_list(request):
    """Lista todas as notificaÃ§Ãµes do usuÃ¡rio"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user
    ).order_by('-data_criacao')
    
    # Filtros
    tipo = request.GET.get('tipo')
    if tipo:
        notificacoes = notificacoes.filter(tipo=tipo)
    
    lida = request.GET.get('lida')
    if lida is not None:
        notificacoes = notificacoes.filter(lida=lida == 'true')
    
    # PaginaÃ§Ã£o
    paginator = Paginator(notificacoes, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'notificacoes': page_obj,
        'tipos': NotificacaoSessao.TIPO_CHOICES,
        'filtros': {
            'tipo': tipo,
            'lida': lida,
        }
    }
    
    return render(request, 'militares/notificacoes/list.html', context)

@login_required
def notificacao_marcar_lida(request, pk):
    """Marca uma notificaÃ§Ã£o como lida"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.marcar_como_lida()
        messages.success(request, 'NotificaÃ§Ã£o marcada como lida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'NotificaÃ§Ã£o nÃ£o encontrada.')
    
    return redirect('militares:notificacoes_list')

@login_required
def notificacao_marcar_todas_lidas(request):
    """Marca todas as notificaÃ§Ãµes do usuÃ¡rio como lidas"""
    
    notificacoes = NotificacaoSessao.objects.filter(
        usuario=request.user,
        lida=False
    )
    
    count = notificacoes.count()
    notificacoes.update(lida=True, data_leitura=timezone.now())
    
    messages.success(request, f'{count} notificaÃ§Ã£o(Ãµes) marcada(s) como lida(s).')
    return redirect('militares:notificacoes_list')

@login_required
def notificacao_delete(request, pk):
    """Remove uma notificaÃ§Ã£o"""
    
    try:
        notificacao = NotificacaoSessao.objects.get(
            pk=pk,
            usuario=request.user
        )
        notificacao.delete()
        messages.success(request, 'NotificaÃ§Ã£o removida.')
    except NotificacaoSessao.DoesNotExist:
        messages.error(request, 'NotificaÃ§Ã£o nÃ£o encontrada.')
    
    return redirect('militares:notificacoes_list')

# Views para gerenciar cargos da comissÃ£o
@login_required
@comissao_acesso_total
def cargo_comissao_list(request):
    """Lista todos os cargos da comissÃ£o"""
    cargos = CargoComissao.objects.all()
    
    context = {
        'cargos': cargos,
        'title': 'Cargos da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/list.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_create(request):
    """Cria um novo cargo"""
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo criado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm()
    
    context = {
        'form': form,
        'title': 'Novo Cargo da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_update(request, pk):
    """Edita um cargo existente"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo nÃ£o encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    if request.method == 'POST':
        form = CargoComissaoForm(request.POST, instance=cargo)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo atualizado com sucesso!')
            return redirect('militares:cargo_comissao_list')
    else:
        form = CargoComissaoForm(instance=cargo)
    
    context = {
        'form': form,
        'cargo': cargo,
        'title': 'Editar Cargo da ComissÃ£o',
    }
    return render(request, 'militares/comissao/cargos/form.html', context)

@login_required
@comissao_acesso_total
def cargo_comissao_delete(request, pk):
    """Exclui um cargo"""
    try:
        cargo = CargoComissao.objects.get(pk=pk)
    except CargoComissao.DoesNotExist:
        messages.error(request, 'Cargo nÃ£o encontrado.')
        return redirect('militares:cargo_comissao_list')
    
    # Buscar membros vinculados ao cargo
    # Como MembroComissao.cargo referencia CargoFuncao, nÃ£o CargoComissao,
    # vamos buscar por membros que tenham o mesmo nome de cargo
    membros_vinculados = MembroComissao.objects.filter(cargo__nome=cargo.nome)
    erro_protegido = False
    

    
    if request.method == 'POST':
        try:
            cargo.delete()
            messages.success(request, 'Cargo excluÃ­do com sucesso!')
            return redirect('militares:cargo_comissao_list')
        except ProtectedError:
            erro_protegido = True
            messages.error(request, 'NÃ£o Ã© possÃ­vel excluir este cargo porque ele estÃ¡ vinculado a um ou mais membros da comissÃ£o. Troque o cargo desses membros antes de excluir.')
    
    context = {
        'cargo': cargo,
        'title': 'Excluir Cargo da ComissÃ£o',
        'membros_vinculados': membros_vinculados,
        'erro_protegido': erro_protegido,
    }
    return render(request, 'militares/comissao/cargos/delete.html', context)

# =============================================================================
# MÃ“DULO DE QUADROS DE FIXAÃ‡ÃƒO DE VAGAS
# =============================================================================

@login_required
def quadro_fixacao_vagas_list(request):
    """Lista todos os quadros de fixaÃ§Ã£o de vagas de oficiais"""
    # PermissÃ£o especial para superusuÃ¡rios, staff e funÃ§Ãµes administrativas
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    
    # SuperusuÃ¡rios e staff podem ver todos os quadros
    if request.user.is_superuser or request.user.is_staff or funcoes_ativas.exists():
        quadros = QuadroFixacaoVagas.objects.all().order_by('-data_criacao')
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                quadros = QuadroFixacaoVagas.objects.all().order_by('-data_criacao')
            elif tem_cpo:
                quadros = QuadroFixacaoVagas.objects.filter(tipo='OFICIAIS').order_by('-data_criacao')
            elif tem_cpp:
                quadros = QuadroFixacaoVagas.objects.filter(tipo='PRACAS').order_by('-data_criacao')
            else:
                quadros = QuadroFixacaoVagas.objects.none()
        else:
            quadros = QuadroFixacaoVagas.objects.none()
    
    # Filtros
    data_inicio = request.GET.get('data_inicio')
    if data_inicio:
        try:
            data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__gte=data_inicio)
        except ValueError:
            pass
    
    data_fim = request.GET.get('data_fim')
    if data_fim:
        try:
            data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
            quadros = quadros.filter(data_criacao__lte=data_fim)
        except ValueError:
            pass
    
    # PaginaÃ§Ã£o
    paginator = Paginator(quadros, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # EstatÃ­sticas
    total_quadros = quadros.count()
    
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    context = {
        'quadros': page_obj,
        'total_quadros': total_quadros,
        'filtros': {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
        },
        'membro_comissao': membro_comissao,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/list.html', context)

@login_required
def quadro_fixacao_vagas_create(request):
    """Cria um novo quadro de fixaÃ§Ã£o de vagas"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        tipo = request.POST.get('tipo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O tÃ­tulo do quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not tipo:
            messages.error(request, 'O tipo de quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_create')
        
        # Verificar se jÃ¡ existe um quadro para esta data
        # Removida a validaÃ§Ã£o que impedia mÃºltiplos quadros para a mesma data
        # (permitir mÃºltiplos quadros de fixaÃ§Ã£o de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo=tipo,
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Capturar previsÃµes de vagas baseado no tipo
            if tipo == 'OFICIAIS':
                # Buscar previsÃµes para oficiais (quadros COMB, SAUDE, ENG, COMP, NVRR)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
                    posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
                ).order_by('quadro', 'posto')
            else:  # PRACAS
                # Buscar previsÃµes para praÃ§as (quadro PRACAS)
                previsoes = PrevisaoVaga.objects.filter(
                    ativo=True,
                    quadro='PRACAS',
                    posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
                ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsÃµes
            for previsao in previsoes:
                # Capturar observaÃ§Ã£o especÃ­fica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual Ã s vagas disponÃ­veis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }
    
    # Buscar previsÃµes de vagas para mostrar no preview
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    previsoes_pracas = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro='PRACAS',
        posto__in=['ST', '1S', '2S', '3S', 'CAB', 'SD']
    )
    
    # Agrupar previsÃµes por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    vagas_por_quadro_pracas = {}
    for previsao in previsoes_pracas:
        if previsao.quadro not in vagas_por_quadro_pracas:
            vagas_por_quadro_pracas[previsao.quadro] = []
        vagas_por_quadro_pracas[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_pracas:
        vagas_por_quadro_pracas[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'tipos': QuadroFixacaoVagas.TIPO_CHOICES,
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'vagas_por_quadro_pracas': vagas_por_quadro_pracas,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/create.html', context)

@login_required
def quadro_fixacao_vagas_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para ver este quadro
    membros_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    )
    
    if membros_comissao.exists():
        # Verificar se Ã© membro de ambas as comissÃµes
        tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
        tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
        
        # Se Ã© membro de ambas, pode ver todos os quadros
        if tem_cpo and tem_cpp:
            pass  # Pode ver todos os quadros
        elif tem_cpo and quadro.tipo != 'OFICIAIS':
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')
        elif tem_cpp and quadro.tipo != 'PRACAS':
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }

    return render(request, 'militares/quadro_fixacao_vagas/detail.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_update(request, pk):
    """Atualiza um quadro de fixaÃ§Ã£o de vagas (geral)"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para editar este quadro
    # SuperusuÃ¡rios e staff tÃªm acesso total, independente de serem membros de comissÃ£o
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        # Atualizar dados bÃ¡sicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')

        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_update', pk=pk)
        quadro.observacoes = observacoes
        # Limpar assinaturas eletrÃ´nicas ao editar o quadro
        quadro.assinaturas.all().delete()
        quadro.save()

        # Atualizar observaÃ§Ãµes dos itens (vagas fixadas sÃ£o automÃ¡ticas)
        for key, value in request.POST.items():
            if key.startswith('observacoes_'):
                item_id = key.replace('observacoes_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    item.observacoes = value
                    # As vagas fixadas sÃ£o automaticamente sincronizadas no save() do modelo
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas atualizado com sucesso! As assinaturas eletrÃ´nicas foram removidas e serÃ¡ necessÃ¡rio assinar novamente.')
        return redirect('militares:quadro_fixacao_vagas_detail', pk=quadro.pk)

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    return render(request, 'militares/quadro_fixacao_vagas/update.html', context)

@login_required
def quadro_fixacao_vagas_pdf_view(request, pk):
    """Visualiza o PDF do quadro de fixaÃ§Ã£o de vagas em nova aba"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para visualizar este quadro
    # SuperusuÃ¡rios e staff tÃªm acesso total, independente de serem membros de comissÃ£o
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/pdf_view.html', context)

@login_required
def quadro_fixacao_vagas_pdf(request, pk):
    """Gera PDF do quadro de fixaÃ§Ã£o de vagas no modelo institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, f'Quadro de fixaÃ§Ã£o de vagas com ID {pk} nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para visualizar este quadro
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    if membro_comissao:
        if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')
        elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
            messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
            return redirect('militares:quadro_fixacao_vagas_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "DIRETORIA DE GESTÃƒO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    tipo_quadro = "QUADRO DE FIXAÃ‡ÃƒO DE VAGAS"
    if quadro.tipo == 'OFICIAIS':
        tipo_quadro += " PARA OFICIAIS"
    elif quadro.tipo == 'PRACAS':
        tipo_quadro += " PARA PRACAS"
    
    titulo = f'<u>{tipo_quadro}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio com data em portuguÃªs
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    data_formatada = f"{quadro.data_promocao.day} de {meses_pt[quadro.data_promocao.month]} de {quadro.data_promocao.year}"
    
    # Texto introdutÃ³rio especÃ­fico para oficiais ou praÃ§as
    if quadro.tipo == 'OFICIAIS':
        # Adicionar cada parÃ¡grafo separadamente
        story.append(Paragraph("O DIRETOR DE GESTÃƒO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ, no uso de suas atribuiÃ§Ãµes que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1Â° da lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Anexo Ãšnico, da lei nÂº 5.949, de 17 de dezembro de 2009 (Lei de OrganizaÃ§Ã£o BÃ¡sica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Art. 2Âº da Lei nÂº 5.461 de 30 de junho de 2005 (Lei de PromoÃ§Ã£o de Oficiais do CBMEPI).", style_just))
    else:  # PRACAS
        # Adicionar cada parÃ¡grafo separadamente
        story.append(Paragraph("O DIRETOR DE GESTÃƒO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ, no uso de suas atribuiÃ§Ãµes que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1Âº da lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Anexo Ãšnico, da lei nÂº 5.949, de 17 de dezembro de 2009 (Lei de OrganizaÃ§Ã£o BÃ¡sica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("CONSIDERANDO o Art. 2Âº da Lei nÂº 5.462 de 30 de junho de 2005 (Lei de PromoÃ§Ã£o de PraÃ§as do CBMEPI);", style_just))
        story.append(Spacer(1, 8))
        
        story.append(Paragraph("RESOLVE:", style_just))
    story.append(Spacer(1, 16))
    
    # Artigo 1Âº em parÃ¡grafo separado
    artigo_1 = f"""
    <b>Art. 1Âº</b> Fixar as vagas para as promoÃ§Ãµes de {quadro.get_tipo_display()} em {data_formatada}, conforme segue:
    """
    
    story.append(Paragraph(artigo_1, style_bold))
    story.append(Spacer(1, 16))

    # Buscar itens do quadro agrupados por quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )

    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13,  # Cabo
        'SD': 14,  # Soldado
    }

    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # Ordenar itens dentro de cada quadro por hierarquia de postos (do mais alto para o mais baixo)
    for quadro_cod in grupos:
        grupos[quadro_cod]['itens'].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    grupos_ordenados = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in grupos:
            grupos_ordenados[cod_quadro] = grupos[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, grupo in grupos.items():
        if cod_quadro not in grupos_ordenados:
            grupos_ordenados[cod_quadro] = grupo
    
    grupos = grupos_ordenados

    # Tabela principal
    for cod_quadro, grupo in grupos.items():
        # Definir nomes completos dos quadros
        quadro_nomes_completos = {
            'COMB': 'Quadro de Oficiais Bombeiros Militares Combatentes (QOBM/Comb.)',
            'SAUDE': 'Quadro de Oficiais Bombeiros Militares de SaÃºde (QOBM/SaÃºde)',
            'ENG': 'Quadro de Oficiais Bombeiros Militares Engenheiros (QOBM/Eng.)',
            'COMP': 'Quadro de Oficiais Bombeiros Militares Complementar (QOBM/Comp.)',
            'PRACAS': 'Quadro de PraÃ§as (QP)',
        }
        
        # TÃ­tulo do quadro com nome completo
        nome_quadro_completo = quadro_nomes_completos.get(cod_quadro, grupo['nome'])
        story.append(Paragraph(f"<b>{nome_quadro_completo}</b>", style_subtitle))
        story.append(Spacer(1, 8))
        
        # Dados da tabela (sem cabeÃ§alho)
        data = []
        
        # Dados da tabela
        for item in grupo['itens']:
            posto = item.previsao_vaga.get_posto_display()
            vagas_fixadas = str(item.vagas_fixadas)
            vagas_disponiveis = str(item.previsao_vaga.vagas_disponiveis)
            observacoes = item.observacoes or '-'
            
            data.append([posto, vagas_fixadas, vagas_disponiveis, observacoes])
        
        # Criar tabela com larguras especÃ­ficas para evitar sobreposiÃ§Ã£o
        table = Table(data, colWidths=[5*cm, 3*cm, 3*cm, 5*cm])
        table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('ALIGN', (3, 0), (3, -1), 'LEFT'),  # ObservaÃ§Ãµes alinhadas Ã  esquerda
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('LEFTPADDING', (0, 0), (-1, -1), 6),
            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
            ('TOPPADDING', (0, 0), (-1, -1), 4),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
            ('WORDWRAP', (0, 0), (-1, -1), True),  # Quebra de linha automÃ¡tica
        ]))
        
        story.append(table)
        story.append(Spacer(1, 16))

    # ObservaÃ§Ãµes do quadro
    if quadro.observacoes:
        story.append(Paragraph("<b>ObservaÃ§Ãµes Gerais:</b>", style_bold))
        story.append(Spacer(1, 6))
        story.append(Paragraph(quadro.observacoes, style_just))
        story.append(Spacer(1, 16))

    # Data e local
    data_extenso = f"Teresina, {data_formatada}"
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # SeÃ§Ã£o de Assinaturas FÃ­sicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas vÃ¡lidas do quadro (da mais recente para a mais antiga)
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo nÃ£o registrado"
        
        # Exibir no formato fÃ­sico: Nome - Posto BM (negrito), FunÃ§Ã£o (normal), Tipo (negrito menor)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Paragraph(f"<b>{tipo}</b>", style_center))
        story.append(Spacer(1, 13))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
    story.append(Spacer(1, 13))
    
    # Buscar todas as assinaturas para exibir na seÃ§Ã£o eletrÃ´nica
    assinaturas_eletronicas = quadro.assinaturas.filter(
        assinado_por__isnull=False
    ).order_by('-data_assinatura')
    
    for i, assinatura in enumerate(assinaturas_eletronicas):
        # Nome e posto - seguir o mesmo padrÃ£o dos quadros de acesso
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{posto} {militar.nome_completo}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        # Tipo de assinatura
        tipo = assinatura.get_tipo_assinatura_display() or "Tipo nÃ£o registrado"
        
        # Data da assinatura
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        data_assinatura = f"{data_formatada} Ã s {hora_formatada}"
        
        # Texto da assinatura eletrÃ´nica no padrÃ£o solicitado
        texto_assinatura = f"Documento assinado eletronicamente por {nome_completo} - {funcao}, em {data_assinatura}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
        if i < len(assinaturas_eletronicas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # Se nÃ£o houver assinaturas, mostrar mensagem
    if not assinaturas.exists() and not assinaturas_eletronicas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a funÃ§Ã£o utilitÃ¡ria para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(quadro, request, tipo_documento='quadro_fixacao')
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualizaÃ§Ã£o em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'quadro_fixacao_vagas_{quadro.pk}.pdf')

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_create(request):
    """Cria um novo quadro de fixaÃ§Ã£o de vagas para oficiais"""
    if request.method == 'POST':
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if not titulo:
            messages.error(request, 'O tÃ­tulo do quadro Ã© obrigatÃ³rio.')
            return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        if not data_promocao:
            data_promocao = calcular_proxima_data_promocao()
            data_automatica = True
        else:
            try:
                data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
                data_automatica = False
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_create')
        
        # Verificar se jÃ¡ existe um quadro para esta data
        quadro_existente = QuadroFixacaoVagas.objects.filter(
            data_promocao=data_promocao,
            tipo='OFICIAIS'
        ).first()
        
        # Removida a validaÃ§Ã£o que impedia mÃºltiplos quadros para a mesma data
        # (permitir mÃºltiplos quadros de fixaÃ§Ã£o de vagas para a mesma data)
        
        # Criar o quadro
        try:
            novo_quadro = QuadroFixacaoVagas.objects.create(
                titulo=titulo,
                tipo='OFICIAIS',
                data_promocao=data_promocao,
                status='RASCUNHO',
                observacoes=observacoes,
                criado_por=request.user
            )
            
            # Buscar previsÃµes para oficiais (quadros COMB, SAUDE, ENG, COMP, NVRR)
            previsoes = PrevisaoVaga.objects.filter(
                ativo=True,
                quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
                posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
            ).order_by('quadro', 'posto')
            
            # Criar itens do quadro baseado nas previsÃµes
            for previsao in previsoes:
                # Capturar observaÃ§Ã£o especÃ­fica para este item
                observacao_key = f'observacoes_{previsao.id}'
                observacao = request.POST.get(observacao_key, '').strip()
                
                ItemQuadroFixacaoVagas.objects.create(
                    quadro=novo_quadro,
                    previsao_vaga=previsao,
                    vagas_fixadas=previsao.vagas_disponiveis,  # Inicialmente igual Ã s vagas disponÃ­veis
                    observacoes=observacao
                )
            
            if data_automatica:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas para Oficiais criado com sucesso! Data automÃ¡tica: {data_promocao.strftime("%d/%m/%Y")}')
            else:
                messages.success(request, f'Quadro de FixaÃ§Ã£o de Vagas para Oficiais criado com sucesso para {data_promocao.strftime("%d/%m/%Y")}!')
            return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=novo_quadro.pk)
                
        except Exception as e:
            messages.error(request, f'Erro ao criar quadro: {str(e)}')
        
        return redirect('militares:quadro_fixacao_vagas_oficiais_create')
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
    }
    
    # Buscar previsÃµes de vagas para oficiais
    previsoes_oficiais = PrevisaoVaga.objects.filter(
        ativo=True,
        quadro__in=['COMB', 'SAUDE', 'ENG', 'COMP', 'NVRR'],
        posto__in=['AS', 'AA', '2T', '1T', 'CP', 'MJ', 'TC', 'CB']
    )
    
    # Calcular efetivo atual em tempo real para cada previsÃ£o
    for previsao in previsoes_oficiais:
        if previsao.quadro == 'COMP':
            # Para COMP, incluir ST (Subtenentes) que sÃ£o cadastrados como COMP mas contam para praÃ§as
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro='COMP',
                situacao='AT'
            ).count()
        else:
            # Para outros quadros, usar o quadro especÃ­fico
            efetivo_atual = Militar.objects.filter(
                posto_graduacao=previsao.posto,
                quadro=previsao.quadro,
                situacao='AT'
            ).count()
        
        # Atualizar o efetivo atual da previsÃ£o (apenas para exibiÃ§Ã£o)
        previsao.efetivo_atual = efetivo_atual
    
    # Agrupar previsÃµes por quadro e ordenar por hierarquia
    vagas_por_quadro_oficiais = {}
    for previsao in previsoes_oficiais:
        if previsao.quadro not in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais[previsao.quadro] = []
        vagas_por_quadro_oficiais[previsao.quadro].append(previsao)
    
    # Ordenar por hierarquia dentro de cada quadro
    for quadro in vagas_por_quadro_oficiais:
        vagas_por_quadro_oficiais[quadro].sort(
            key=lambda x: hierarquia_postos.get(x.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    vagas_por_quadro_oficiais_ordenado = {}
    for cod_quadro in ordem_quadros:
        if cod_quadro in vagas_por_quadro_oficiais:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas_por_quadro_oficiais[cod_quadro]
    
    # Adicionar outros quadros que possam existir
    for cod_quadro, vagas in vagas_por_quadro_oficiais.items():
        if cod_quadro not in vagas_por_quadro_oficiais_ordenado:
            vagas_por_quadro_oficiais_ordenado[cod_quadro] = vagas
    
    context = {
        'proxima_data_automatica': calcular_proxima_data_promocao(),
        'vagas_por_quadro_oficiais': vagas_por_quadro_oficiais_ordenado,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_create.html', context)

@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # EstatÃ­sticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)

@login_required
def assinar_quadro_fixacao_vagas(request, pk):
    """Assinar quadro de fixaÃ§Ã£o de vagas com confirmaÃ§Ã£o de senha"""
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para assinar este quadro
    # SuperusuÃ¡rios e staff tÃªm acesso total, independente de serem membros de comissÃ£o
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        observacoes = request.POST.get('observacoes', '')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Verificar se jÃ¡ existe uma assinatura deste usuÃ¡rio para este tipo
        assinatura_existente = AssinaturaQuadroFixacaoVagas.objects.filter(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            tipo_assinatura=tipo_assinatura
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'VocÃª jÃ¡ assinou este quadro como "{assinatura_existente.get_tipo_assinatura_display()}".')
            context = {
                'quadro': quadro,
            }
            return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)
        
        # Criar a assinatura
        assinatura = AssinaturaQuadroFixacaoVagas.objects.create(
            quadro_fixacao_vagas=quadro,
            assinado_por=request.user,
            observacoes=observacoes,
            tipo_assinatura=tipo_assinatura,
            funcao_assinatura=funcao_assinatura
        )
        
        # Se a assinatura for de aprovaÃ§Ã£o, mudar o status do quadro para APROVADO
        if tipo_assinatura == 'APROVACAO':
            quadro.status = 'APROVADO'
            quadro.save()
        
        messages.success(request, f'Quadro de fixaÃ§Ã£o de vagas assinado com sucesso como "{assinatura.get_tipo_assinatura_display()}"!')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/assinar_quadro_fixacao_vagas.html', context)

@login_required
def retirar_assinatura_quadro_fixacao_vagas(request, pk, assinatura_pk):
    """Retirar assinatura do quadro de fixaÃ§Ã£o de vagas - apenas antes da homologaÃ§Ã£o"""
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    assinatura = get_object_or_404(AssinaturaQuadroFixacaoVagas, pk=assinatura_pk, quadro_fixacao_vagas=quadro)
    
    # Verificar se o quadro jÃ¡ foi homologado
    if quadro.status == 'HOMOLOGADO':
        messages.error(request, 'NÃ£o Ã© possÃ­vel retirar assinaturas de um quadro jÃ¡ homologado.')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    # Verificar se o usuÃ¡rio Ã© o autor da assinatura ou tem permissÃ£o administrativa
    if assinatura.assinado_por != request.user and not request.user.is_staff:
        messages.error(request, 'VocÃª sÃ³ pode retirar suas prÃ³prias assinaturas.')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'quadro': quadro,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_quadro_fixacao_vagas.html', context)
        
        # Verificar se a assinatura Ã© de aprovaÃ§Ã£o e se hÃ¡ outras assinaturas de aprovaÃ§Ã£o
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = quadro.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se nÃ£o hÃ¡ outras aprovaÃ§Ãµes, voltar o status do quadro para RASCUNHO
                quadro.status = 'RASCUNHO'
                quadro.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        return redirect('militares:quadro_fixacao_vagas_visualizar_html', pk=quadro.pk)
    
    context = {
        'quadro': quadro,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_quadro_fixacao_vagas.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_delete(request, pk):
    """Exclui um quadro de fixaÃ§Ã£o de vagas"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        try:
            quadro.delete()
            messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas excluÃ­do com sucesso!')
            return redirect('militares:quadro_fixacao_vagas_list')
        except Exception as e:
            messages.error(request, f'Erro ao excluir quadro: {str(e)}')
    
    context = {
        'quadro': quadro,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/delete.html', context)

@login_required
def quadro_fixacao_vagas_oficiais_detail(request, pk):
    """Detalhes de um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    # EstatÃ­sticas
    total_vagas_fixadas = quadro.total_vagas_fixadas()
    total_vagas_disponiveis = quadro.total_vagas_disponiveis()
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
        'total_vagas_fixadas': total_vagas_fixadas,
        'total_vagas_disponiveis': total_vagas_disponiveis,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_detail.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_update(request, pk):
    """Atualiza um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk)
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')
    
    if request.method == 'POST':
        # Atualizar dados bÃ¡sicos do quadro
        titulo = request.POST.get('titulo')
        data_promocao = request.POST.get('data_promocao')
        observacoes = request.POST.get('observacoes', '')
        
        if titulo:
            quadro.titulo = titulo
        if data_promocao:
            try:
                quadro.data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
            except ValueError:
                messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
                return redirect('militares:quadro_fixacao_vagas_oficiais_update', pk=pk)
        
        quadro.observacoes = observacoes
        # Limpar assinaturas eletrÃ´nicas ao editar o quadro
        quadro.assinaturas.all().delete()
        quadro.save()
        
        # Atualizar vagas fixadas
        for key, value in request.POST.items():
            if key.startswith('vagas_fixadas_'):
                item_id = key.replace('vagas_fixadas_', '')
                try:
                    item = ItemQuadroFixacaoVagas.objects.get(id=item_id, quadro=quadro)
                    vagas_fixadas = int(value) if value else 0
                    item.vagas_fixadas = vagas_fixadas
                    
                    # Buscar observaÃ§Ãµes correspondentes
                    obs_key = f'observacoes_{item_id}'
                    observacoes_item = request.POST.get(obs_key, '')
                    item.observacoes = observacoes_item
                    
                    item.save()
                except (ItemQuadroFixacaoVagas.DoesNotExist, ValueError):
                    continue
        
        messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas atualizado com sucesso! As assinaturas eletrÃ´nicas foram removidas e serÃ¡ necessÃ¡rio assinar novamente.')
        return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=quadro.pk)
    
    # Buscar itens do quadro
    itens = quadro.itens.select_related('previsao_vaga').order_by(
        'previsao_vaga__quadro', 'previsao_vaga__posto'
    )
    
    # Agrupar por quadro
    grupos = {}
    for item in itens:
        previsao = item.previsao_vaga
        if previsao.quadro not in grupos:
            grupos[previsao.quadro] = {
                'nome': previsao.get_quadro_display(),
                'itens': []
            }
        grupos[previsao.quadro]['itens'].append(item)
    
    context = {
        'quadro': quadro,
        'grupos': grupos,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_update.html', context)

@login_required
@cargos_especiais_required
def quadro_fixacao_vagas_oficiais_delete(request, pk):
    """Exclui um quadro de fixaÃ§Ã£o de vagas para oficiais"""
    try:
        quadro = QuadroFixacaoVagas.objects.get(pk=pk, tipo='OFICIAIS')
    except QuadroFixacaoVagas.DoesNotExist:
        messages.error(request, 'Quadro de fixaÃ§Ã£o de vagas nÃ£o encontrado.')
        return redirect('militares:quadro_fixacao_vagas_list')

    if request.method == 'POST':
        try:
            quadro.delete()
            messages.success(request, 'Quadro de fixaÃ§Ã£o de vagas excluÃ­do com sucesso!')
            return redirect('militares:quadro_fixacao_vagas_list')
        except Exception as e:
            messages.error(request, f'Erro ao excluir quadro: {str(e)}')
            return redirect('militares:quadro_fixacao_vagas_oficiais_detail', pk=pk)
    
    context = {
        'quadro': quadro,
    }
    return render(request, 'militares/quadro_fixacao_vagas/oficiais_confirm_delete.html', context)

def gerar_codigo_verificacao(texto_documento):
    """
    Gera um cÃ³digo de verificaÃ§Ã£o baseado no hash SHA-256 do texto do documento.
    Retorna os primeiros 10 caracteres do hash hexadecimal.
    """
    return hashlib.sha256(texto_documento.encode('utf-8')).hexdigest()[:10]

@login_required
def proxima_numeracao_disponivel(request):
    """Retorna a prÃ³xima numeraÃ§Ã£o disponÃ­vel para um posto/quadro especÃ­fico"""
    
    if request.method == 'GET':
        posto = request.GET.get('posto')
        quadro = request.GET.get('quadro')
        
        if not posto or not quadro:
            return JsonResponse({'erro': 'Posto e quadro sÃ£o obrigatÃ³rios'}, status=400)
        
        # Buscar todas as numeraÃ§Ãµes existentes para o posto/quadro
        numeracoes_existentes = list(Militar.objects.filter(
            situacao='AT',
            posto_graduacao=posto,
            quadro=quadro,
            numeracao_antiguidade__isnull=False
        ).values_list('numeracao_antiguidade', flat=True).order_by('numeracao_antiguidade'))
        
        # Encontrar o primeiro nÃºmero disponÃ­vel (nÃ£o necessariamente o maior + 1)
        proxima_numeracao = 1
        for num in numeracoes_existentes:
            if proxima_numeracao < num:
                # Encontrou um gap, usar este nÃºmero
                break
            proxima_numeracao = num + 1
        
        return JsonResponse({
            'proxima_numeracao': proxima_numeracao,
            'posto': posto,
            'quadro': quadro,
            'numeracoes_existentes': numeracoes_existentes
        })
    
    return JsonResponse({'erro': 'MÃ©todo nÃ£o permitido'}, status=405)

def reordenar_numeracoes_militares(posto):
    """
    Reordena as numeraÃ§Ãµes de antiguidade para um posto especÃ­fico,
    corrigindo apenas repetiÃ§Ãµes e gaps, mantendo a ordem atual dos demais.
    """
    # Buscar todos os militares ativos do posto, mantendo a ordem atual
    militares = Militar.objects.filter(
        situacao='AT',
        posto_graduacao=posto
    ).order_by('numeracao_antiguidade', 'id')

    if not militares:
        return 0

    # Detectar problemas (repetiÃ§Ãµes e gaps)
    seen = set()
    start_reorder_index = None
    expected_num = 1
    
    for idx, militar in enumerate(militares):
        current_num = militar.numeracao_antiguidade
        
        # Verificar se hÃ¡ repetiÃ§Ã£o
        if current_num in seen:
            start_reorder_index = idx
            break
        
        # Verificar se hÃ¡ gap (nÃºmero faltando)
        if current_num != expected_num:
            start_reorder_index = idx
            break
            
        seen.add(current_num)
        expected_num += 1

    # Se nÃ£o houver problemas (repetiÃ§Ã£o ou gap), nÃ£o faz nada
    if start_reorder_index is None:
        return 0

    # A partir do primeiro problema, reordena sequencialmente
    # Manter a ordem atual dos militares, apenas corrigindo a numeraÃ§Ã£o
    nova_numeracao = militares[start_reorder_index-1].numeracao_antiguidade + 1 if start_reorder_index > 0 else 1
    militares_para_atualizar = []
    
    for militar in militares[start_reorder_index:]:
        if militar.numeracao_antiguidade != nova_numeracao:
            militar.numeracao_antiguidade = nova_numeracao
            militares_para_atualizar.append(militar)
        nova_numeracao += 1

    if militares_para_atualizar:
        Militar.objects.bulk_update(militares_para_atualizar, ['numeracao_antiguidade'])

    return len(militares_para_atualizar)

@login_required
def reordenar_numeracoes_view(request):
    """View para reordenar numeraÃ§Ãµes de antiguidade por posto, baseado na data de promoÃ§Ã£o"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        
        # Exigir que o posto seja fornecido
        if not posto:
            messages.error(request, 'O posto Ã© obrigatÃ³rio para reordenar numeraÃ§Ãµes')
            return redirect('militares:militar_list')
        
        try:
            # Executar reordenaÃ§Ã£o baseada apenas no posto e data de promoÃ§Ã£o
            total_atualizados = reordenar_numeracoes_militares(posto)
            
            # Contar total de militares do posto
            total_militares = Militar.objects.filter(
                situacao='AT',
                posto_graduacao=posto
            ).count()
            
            posto_display = dict(POSTO_GRADUACAO_CHOICES).get(posto, posto)
            
            if total_atualizados > 0:
                messages.success(
                    request, 
                    f'CorreÃ§Ãµes aplicadas com sucesso para o posto {posto_display}! '
                    f'{total_atualizados} militares foram corrigidos (repetiÃ§Ãµes e gaps removidos).'
                )
            else:
                messages.info(
                    request, 
                    f'Nenhuma correÃ§Ã£o necessÃ¡ria para o posto {posto_display}. '
                    f'As numeraÃ§Ãµes jÃ¡ estÃ£o corretas (sem repetiÃ§Ãµes ou gaps).'
                )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:militar_list')
    
    return redirect('militares:militar_list')

@login_required
def aplicar_promocao_view(request):
    """View para aplicar promoÃ§Ã£o e atribuir numeraÃ§Ã£o automaticamente"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        novo_posto = request.POST.get('novo_posto')
        novo_quadro = request.POST.get('novo_quadro')
        
        if not militar_id or not novo_posto or not novo_quadro:
            return JsonResponse({'erro': 'Dados incompletos para promoÃ§Ã£o'}, status=400)
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = novo_posto
            militar.quadro = novo_quadro
            
            # Aplicar nova numeraÃ§Ã£o por promoÃ§Ã£o
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÃ“GICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2Âº Tenente
            if posto_anterior == 'ST' and novo_posto == '2T':
                from militares.models import FichaConceitoPracas, FichaConceitoOficiais
                
                # Verificar se existe ficha de praÃ§as
                ficha_pracas = militar.fichaconceitopracas_set.first()
                if ficha_pracas:
                    # Criar nova ficha de oficiais com os dados da ficha de praÃ§as
                    ficha_oficiais = FichaConceitoOficiais.objects.create(
                        militar=militar,
                        tempo_posto=ficha_pracas.tempo_posto,
                        cursos_especializacao=ficha_pracas.cursos_especializacao,
                        cursos_cfsd=ficha_pracas.cursos_cfsd,
                        cursos_chc=ficha_pracas.cursos_chc,
                        cursos_chsgt=ficha_pracas.cursos_chsgt,
                        cursos_cas=ficha_pracas.cursos_cas,
                        cursos_cho=ficha_pracas.cursos_cho,
                        cursos_civis_superior=ficha_pracas.cursos_civis_superior,
                        cursos_civis_especializacao=ficha_pracas.cursos_civis_especializacao,
                        cursos_civis_mestrado=ficha_pracas.cursos_civis_mestrado,
                        cursos_civis_doutorado=ficha_pracas.cursos_civis_doutorado,
                        medalha_federal=ficha_pracas.medalha_federal,
                        medalha_estadual=ficha_pracas.medalha_estadual,
                        medalha_cbmepi=ficha_pracas.medalha_cbmepi,
                        elogio_individual=ficha_pracas.elogio_individual,
                        elogio_coletivo=ficha_pracas.elogio_coletivo,
                        punicao_repreensao=ficha_pracas.punicao_repreensao,
                        punicao_detencao=ficha_pracas.punicao_detencao,
                        punicao_prisao=ficha_pracas.punicao_prisao,
                        falta_aproveitamento=ficha_pracas.falta_aproveitamento,
                        observacoes=f"Ficha convertida automaticamente da promoÃ§Ã£o de Subtenente para 2Âº Tenente. Original: {ficha_pracas.id}"
                    )
                    
                    # Remover a ficha de praÃ§as antiga
                    ficha_pracas.delete()
                    
                    # Atualizar a mensagem para incluir informaÃ§Ã£o sobre a conversÃ£o
                    mensagem_adicional = " Ficha de conceito convertida de praÃ§as para oficiais."
                else:
                    mensagem_adicional = ""
            else:
                mensagem_adicional = ""
            
            # Salvar as alteraÃ§Ãµes
            militar.save()
            
            return JsonResponse({
                'sucesso': True,
                'nova_numeracao': nova_numeracao,
                'mensagem': f'PromoÃ§Ã£o aplicada com sucesso! Nova numeraÃ§Ã£o: {nova_numeracao}Âº. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            })
            
        except Militar.DoesNotExist:
            return JsonResponse({'erro': 'Militar nÃ£o encontrado'}, status=404)
        except Exception as e:
            return JsonResponse({'erro': f'Erro ao aplicar promoÃ§Ã£o: {str(e)}'}, status=500)
    
    return JsonResponse({'erro': 'MÃ©todo nÃ£o permitido'}, status=405)

@login_required
def militar_inativo_list(request):
    """Lista militares inativos (transferidos, aposentados, exonerados)"""
    
    # Filtrar apenas militares inativos
    militares = Militar.objects.filter(
        situacao__in=['IN', 'TR', 'AP', 'EX']
    ).order_by('posto_graduacao', 'nome_completo')
    
    # Filtros
    situacao = request.GET.get('situacao')
    if situacao:
        militares = militares.filter(situacao=situacao)
    
    posto = request.GET.get('posto')
    if posto:
        militares = militares.filter(posto_graduacao=posto)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Busca por nome
    busca = request.GET.get('busca')
    if busca:
        militares = militares.filter(
            models.Q(nome_completo__icontains=busca) |
            models.Q(nome_guerra__icontains=busca) |
            models.Q(matricula__icontains=busca)
        )
    
    # EstatÃ­sticas
    total_inativos = militares.count()
    por_situacao = militares.values('situacao').annotate(
        count=models.Count('id')
    ).order_by('situacao')
    
    # PaginaÃ§Ã£o
    paginator = Paginator(militares, 50)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'page_obj': page_obj,
        'militares': page_obj,
        'situacoes': SITUACAO_CHOICES,
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
        'filtros': {
            'situacao': situacao,
            'posto': posto,
            'quadro': quadro,
            'busca': busca
        },
        'estatisticas': {
            'total': total_inativos,
            'por_situacao': por_situacao
        }
    }
    
    return render(request, 'militares/militar_inativo_list.html', context)

@login_required
def militar_inativo_detail(request, pk):
    """Detalhes de um militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    # Verificar se Ã© realmente inativo
    if militar.situacao not in ['IN', 'TR', 'AP', 'EX']:
        messages.warning(request, 'Este militar nÃ£o estÃ¡ inativo.')
        return redirect('militares:militar_detail', pk=pk)
    
    # Buscar histÃ³rico de promoÃ§Ãµes
    promocoes = Promocao.objects.filter(militar=militar).order_by('-data_promocao')
    
    # Buscar fichas de conceito
    fichas_conceito = []
    try:
        ficha_oficiais = FichaConceitoOficiais.objects.get(militar=militar)
        fichas_conceito.append(ficha_oficiais)
    except FichaConceitoOficiais.DoesNotExist:
        pass
    
    try:
        ficha_pracas = FichaConceitoPracas.objects.get(militar=militar)
        fichas_conceito.append(ficha_pracas)
    except FichaConceitoPracas.DoesNotExist:
        pass
    
    # Buscar documentos
    documentos = Documento.objects.filter(militar=militar).order_by('-data_upload')
    
    context = {
        'militar': militar,
        'promocoes': promocoes,
        'fichas_conceito': fichas_conceito,
        'documentos': documentos,
    }
    
    return render(request, 'militares/militar_inativo_detail.html', context)

@login_required
def militar_transferir_inativo(request, pk):
    """Transferir militar para situaÃ§Ã£o inativa"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        nova_situacao = request.POST.get('nova_situacao')
        data_transferencia = request.POST.get('data_transferencia')
        motivo = request.POST.get('motivo')
        
        if nova_situacao and data_transferencia:
            try:
                # Validar data
                from datetime import datetime
                data_transferencia = datetime.strptime(data_transferencia, '%Y-%m-%d').date()
                
                # Atualizar situaÃ§Ã£o do militar
                situacao_anterior = militar.situacao
                militar.situacao = nova_situacao
                militar.observacoes = f"{militar.observacoes or ''}\n\nTransferido para {militar.get_situacao_display()} em {data_transferencia.strftime('%d/%m/%Y')}. Motivo: {motivo}"
                militar.save()
                
                messages.success(request, f'Militar {militar.nome_completo} transferido para {militar.get_situacao_display()} com sucesso!')
                return redirect('militares:militar_inativo_detail', pk=militar.pk)
                
            except ValueError:
                messages.error(request, 'Data invÃ¡lida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Todos os campos sÃ£o obrigatÃ³rios.')
    
    context = {
        'militar': militar,
        'situacoes_inativas': [
            ('IN', 'Inativo'),
            ('TR', 'Transferido'),
            ('AP', 'Aposentado'),
            ('EX', 'Exonerado'),
        ]
    }
    
    return render(request, 'militares/militar_transferir_inativo.html', context)

@login_required
def militar_reativar(request, pk):
    """Reativar militar inativo"""
    militar = get_object_or_404(Militar, pk=pk)
    
    if request.method == 'POST':
        motivo = request.POST.get('motivo')
        
        if motivo:
            # Reativar militar
            militar.situacao = 'AT'
            militar.observacoes = f"{militar.observacoes or ''}\n\nReativado em {timezone.now().strftime('%d/%m/%Y %H:%M')}. Motivo: {motivo}"
            militar.save()
            
            messages.success(request, f'Militar {militar.nome_completo} reativado com sucesso!')
            return redirect('militares:militar_detail', pk=militar.pk)
        else:
            messages.error(request, 'Motivo Ã© obrigatÃ³rio.')
    
    context = {
        'militar': militar,
    }
    
    return render(request, 'militares/militar_reativar.html', context)

    class Meta:
        model = User
        fields = [
            'username', 'first_name', 'last_name', 'email',
            'is_active', 'is_staff', 'is_superuser', 'groups'
        ]
        widgets = {
            'username': forms.TextInput(attrs={'class': 'form-control'}),
            'first_name': forms.TextInput(attrs={
                'class': 'form-control',
                'placeholder': 'ğŸ” Digite o nome do militar para buscar e preencher automaticamente...',
                'autocomplete': 'off'
            }),
            'last_name': forms.TextInput(attrs={'class': 'form-control'}),
            'email': forms.EmailInput(attrs={'class': 'form-control'}),
            'groups': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }
    
    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get('password')
        confirm_password = cleaned_data.get('confirm_password')
        
        # Se Ã© uma criaÃ§Ã£o de usuÃ¡rio (nÃ£o tem instance.pk), senha Ã© obrigatÃ³ria
        if not self.instance.pk:
            if not password:
                raise forms.ValidationError('Senha Ã© obrigatÃ³ria para novos usuÃ¡rios.')
            if not confirm_password:
                raise forms.ValidationError('ConfirmaÃ§Ã£o de senha Ã© obrigatÃ³ria para novos usuÃ¡rios.')
        
        if password and confirm_password and password != confirm_password:
            raise forms.ValidationError('As senhas nÃ£o coincidem.')
        
        return cleaned_data

@login_required
@permission_required('auth.add_user')
def usuario_create(request):
    """Criar novo usuÃ¡rio"""
    if request.method == 'POST':
        form = UsuarioForm(request.POST)
        if form.is_valid():
            usuario = form.save(commit=False)
            password = form.cleaned_data.get('password')
            if password:
                usuario.set_password(password)
            usuario.save()
            form.save_m2m()  # Salvar grupos
            
            # Associar militar se fornecido
            militar_id = form.cleaned_data.get('militar_id')
            if militar_id:
                try:
                    militar = Militar.objects.get(id=militar_id)
                    # Vincular militar ao usuÃ¡rio
                    militar.user = usuario
                    militar.save()
                    messages.success(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso e vinculado ao militar "{militar.nome_completo}"!')
                except Militar.DoesNotExist:
                    messages.warning(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso, mas militar nÃ£o encontrado.')
            else:
                messages.success(request, f'UsuÃ¡rio "{usuario.username}" criado com sucesso!')
            
            return redirect('militares:usuarios_custom_list')
    else:
        form = UsuarioForm()
    
    context = {
        'form': form,
        'title': 'Criar Novo UsuÃ¡rio',
        'submit_text': 'Criar UsuÃ¡rio'
    }
    
    return render(request, 'militares/usuarios/form.html', context)

class GrupoForm(forms.ModelForm):
    """FormulÃ¡rio para criaÃ§Ã£o/ediÃ§Ã£o de grupos"""
    
    class Meta:
        model = Group
        fields = ['name', 'permissions']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control'}),
            'permissions': forms.SelectMultiple(attrs={'class': 'form-control'}),
        }

@login_required
@permission_required('auth.view_user')
def dashboard_permissoes(request):
    """Dashboard com estatÃ­sticas do sistema de permissÃµes"""
    
    # EstatÃ­sticas bÃ¡sicas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    total_grupos = Group.objects.count()
    grupos_com_usuarios = Group.objects.filter(user__isnull=False).distinct().count()
    total_permissoes = Permission.objects.count()
    permissoes_utilizadas = Permission.objects.filter(group__isnull=False).distinct().count()
    
    # AplicaÃ§Ãµes e modelos
    content_types = ContentType.objects.all()
    total_apps = content_types.values('app_label').distinct().count()
    modelos_por_app = content_types.count()
    
    # EstatÃ­sticas por grupo
    grupos_estatisticas = {}
    grupos_nomes = {
        'admin': 'Administrador - Acesso total',
        'superusuario': 'Super UsuÃ¡rio - Acesso total',
        'membro_cpo': 'Membro CPO - Acesso a oficiais e comissÃµes',
        'membro_cpp': 'Membro CPP - Acesso a praÃ§as e comissÃµes',
        'comandante_geral': 'Comandante Geral - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'subcomandante_geral': 'Subcomandante Geral - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'diretor_gestao_pessoas': 'Diretor de GestÃ£o de Pessoas - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'chefe_secao_promocoes': 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes - Acesso total exceto usuÃ¡rios e administraÃ§Ã£o',
        'digitador': 'Digitador - Acesso total sem exclusÃ£o e sem usuÃ¡rios/administraÃ§Ã£o',
        'usuario': 'UsuÃ¡rio - Acesso a documentos especÃ­ficos e visualizaÃ§Ã£o'
    }
    
    for codigo, nome in grupos_nomes.items():
        try:
            grupo = Group.objects.get(name=nome)
            usuarios_count = grupo.user_set.count()
            permissoes_count = grupo.permissions.count()
            grupos_estatisticas[codigo] = {
                'usuarios': usuarios_count,
                'permissoes': permissoes_count
            }
        except Group.DoesNotExist:
            grupos_estatisticas[codigo] = {
                'usuarios': 0,
                'permissoes': 0
            }
    
    # Atividades recentes (simuladas)
    recent_activities = [
        {
            'icon': 'shield-alt',
            'title': 'Sistema de permissÃµes simplificado',
            'description': 'ConfiguraÃ§Ã£o de permissÃµes por nÃ­veis de acesso concluÃ­da',
            'time': '5 minutos atrÃ¡s'
        },
        {
            'icon': 'users-cog',
            'title': 'Grupos criados',
            'description': '10 grupos de permissÃµes foram configurados',
            'time': '10 minutos atrÃ¡s'
        },
        {
            'icon': 'key',
            'title': 'PermissÃµes atribuÃ­das',
            'description': 'Sistema de permissÃµes organizado por nÃ­veis',
            'time': '15 minutos atrÃ¡s'
        }
    ]
    
    context = {
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'total_grupos': total_grupos,
        'grupos_com_usuarios': grupos_com_usuarios,
        'total_permissoes': total_permissoes,
        'permissoes_utilizadas': permissoes_utilizadas,
        'total_apps': total_apps,
        'modelos_por_app': modelos_por_app,
        'recent_activities': recent_activities,
        # EstatÃ­sticas por grupo
        'admin_users': grupos_estatisticas.get('admin', {}).get('usuarios', 0),
        'admin_permissions': grupos_estatisticas.get('admin', {}).get('permissoes', 88),
        'super_users': grupos_estatisticas.get('superusuario', {}).get('usuarios', 0),
        'super_permissions': grupos_estatisticas.get('superusuario', {}).get('permissoes', 88),
        'cpo_users': grupos_estatisticas.get('membro_cpo', {}).get('usuarios', 0),
        'cpo_permissions': grupos_estatisticas.get('membro_cpo', {}).get('permissoes', 44),
        'cpp_users': grupos_estatisticas.get('membro_cpp', {}).get('usuarios', 0),
        'cpp_permissions': grupos_estatisticas.get('membro_cpp', {}).get('permissoes', 44),
        'comandante_users': grupos_estatisticas.get('comandante_geral', {}).get('usuarios', 0),
        'comandante_permissions': grupos_estatisticas.get('comandante_geral', {}).get('permissoes', 76),
        'subcomandante_users': grupos_estatisticas.get('subcomandante_geral', {}).get('usuarios', 0),
        'subcomandante_permissions': grupos_estatisticas.get('subcomandante_geral', {}).get('permissoes', 76),
        'diretor_users': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('usuarios', 0),
        'diretor_permissions': grupos_estatisticas.get('diretor_gestao_pessoas', {}).get('permissoes', 76),
        'chefe_users': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('usuarios', 0),
        'chefe_permissions': grupos_estatisticas.get('chefe_secao_promocoes', {}).get('permissoes', 76),
        'digitador_users': grupos_estatisticas.get('digitador', {}).get('usuarios', 0),
        'digitador_permissions': grupos_estatisticas.get('digitador', {}).get('permissoes', 57),
        'usuario_users': grupos_estatisticas.get('usuario', {}).get('usuarios', 0),
        'usuario_permissions': grupos_estatisticas.get('usuario', {}).get('permissoes', 2),
    }
    
    return render(request, 'militares/usuarios/dashboard.html', context)

@login_required
def meus_votos_list(request):
    """Lista todos os votos do usuÃ¡rio logado"""
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o
    membros_usuario = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True
    )
    
    if not membros_usuario.exists():
        messages.warning(request, 'VocÃª nÃ£o Ã© membro de nenhuma comissÃ£o ativa.')
        return redirect('militares:comissao_list')
    
    # Buscar todos os votos do usuÃ¡rio
    votos = VotoDeliberacao.objects.filter(
        membro__usuario=request.user,
        membro__ativo=True
    ).select_related(
        'deliberacao__sessao__comissao',
        'membro__militar'
    ).order_by('-data_registro')
    
    # Calcular estatÃ­sticas
    total_votos = votos.count()
    votos_favor = votos.filter(voto='FAVOR').count()
    votos_contra = votos.filter(voto='CONTRA').count()
    votos_abstencao = votos.filter(voto='ABSTENCAO').count()
    
    context = {
        'votos': votos,
        'total_votos': total_votos,
        'votos_favor': votos_favor,
        'votos_contra': votos_contra,
        'votos_abstencao': votos_abstencao,
        'title': 'Meus Votos',
    }
    return render(request, 'militares/comissao/deliberacoes/meus_votos_list.html', context)

@login_required
def meu_voto_detail(request, pk):
    """Visualizar detalhes de um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este voto.')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_detail.html', context)

@login_required
def meu_voto_update(request, pk):
    """Editar um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para editar este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessÃ£o ainda estÃ¡ aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'NÃ£o Ã© possÃ­vel editar votos de sessÃµes finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Obter dados do voto
        novo_voto = request.POST.get('voto')
        voto_proferido = request.POST.get('voto_proferido', '')
        senha_votante = request.POST.get('senha_votante')
        
        # Validar senha
        if not senha_votante:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar a ediÃ§Ã£o do voto.')
            
            # Criar formulÃ¡rio para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        # Validar senha do usuÃ¡rio
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            
            # Criar formulÃ¡rio para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        if not novo_voto:
            messages.error(request, 'VocÃª deve escolher uma opÃ§Ã£o de voto.')
            
            # Criar formulÃ¡rio para o voto proferido com CKEditor 5
            class VotoProferidoForm(forms.Form):
                voto_proferido = forms.CharField(
                    widget=forms.Textarea(
                        attrs={
                            'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                            'class': 'ckeditor5',
                            'data-config-name': 'voto_proferido_config'
                        }
                    ),
                    required=False,
                    label='Voto Proferido'
                )
            
            context = {
                'voto': voto,
                'form': VotoProferidoForm(initial={'voto_proferido': voto.voto_proferido}),
            }
            return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)
        
        # Atualizar voto
        voto.voto = novo_voto
        voto.voto_proferido = voto_proferido
        # Limpar assinatura eletrÃ´nica ao editar o voto
        voto.assinado = False
        voto.data_assinatura = None
        voto.funcao_assinatura = ''
        voto.tipo_assinatura = ''
        voto.observacoes_assinatura = ''
        voto.save()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = voto.deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = voto.deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = voto.deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        voto.deliberacao.votos_favor = votos_favor
        voto.deliberacao.votos_contra = votos_contra
        voto.deliberacao.votos_abstencao = votos_abstencao
        voto.deliberacao.save()
        
        messages.success(request, f'âœ… Voto atualizado com sucesso!')
        return redirect('militares:voto_visualizar_assinar', pk=voto.pk)
    
    # Criar formulÃ¡rio para o voto proferido com CKEditor 5 (mesmo das atas)
    
    class VotoProferidoForm(forms.Form):
        voto_proferido = forms.CharField(
            widget=forms.Textarea(
                attrs={
                    'placeholder': 'Digite aqui o texto do voto que vocÃª proferiu durante a sessÃ£o...',
                    'class': 'ckeditor5',
                    'data-config-name': 'voto_proferido_config'
                }
            ),
            required=False,
            label='Voto Proferido'
        )
    
    form = VotoProferidoForm(initial={
        'voto_proferido': voto.voto_proferido
    })
    
    context = {
        'voto': voto,
        'form': form,
        'title': f'Editar Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_form.html', context)

@login_required
def meu_voto_delete(request, pk):
    """Excluir um voto especÃ­fico do usuÃ¡rio"""
    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se o voto pertence ao usuÃ¡rio logado
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir este voto.')
        return redirect('militares:meus_votos_list')
    
    # Verificar se a sessÃ£o ainda estÃ¡ aberta
    if voto.deliberacao.sessao.status == 'FINALIZADA':
        messages.error(request, 'NÃ£o Ã© possÃ­vel excluir votos de sessÃµes finalizadas.')
        return redirect('militares:meu_voto_detail', pk=voto.pk)
    
    if request.method == 'POST':
        # Salvar referÃªncias antes de excluir
        deliberacao = voto.deliberacao
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, 'âœ… Voto excluÃ­do com sucesso!')
        return redirect('militares:meus_votos_list')
    
    context = {
        'voto': voto,
        'title': f'Excluir Voto - DeliberaÃ§Ã£o {voto.deliberacao.numero}',
    }
    return render(request, 'militares/comissao/deliberacoes/meu_voto_confirm_delete.html', context)

@login_required
def status_efetivo_vagas(request):
    """Mostra o status do efetivo atual e permite atualizaÃ§Ã£o manual das vagas"""
    from .signals import atualizar_todas_vagas_efetivo
    
    # Contar militares por posto e quadro
    efetivo_por_posto_quadro = {}
    militares_ativos = Militar.objects.filter(situacao='AT')
    
    for militar in militares_ativos:
        key = f"{militar.get_posto_graduacao_display()} - {militar.get_quadro_display()}"
        if key not in efetivo_por_posto_quadro:
            efetivo_por_posto_quadro[key] = {
                'posto': militar.posto_graduacao,
                'quadro': militar.quadro,
                'efetivo_atual': 0,
                'militares': []
            }
        efetivo_por_posto_quadro[key]['efetivo_atual'] += 1
        efetivo_por_posto_quadro[key]['militares'].append(militar)
    
    # Buscar vagas existentes
    vagas = Vaga.objects.all().order_by('posto', 'quadro')
    vagas_dict = {}
    for vaga in vagas:
        key = f"{vaga.get_posto_display()} - {vaga.get_quadro_display()}"
        vagas_dict[key] = vaga
    
    # Buscar previsÃµes existentes
    previsoes = PrevisaoVaga.objects.filter(ativo=True).order_by('posto', 'quadro')
    previsoes_dict = {}
    for previsao in previsoes:
        key = f"{previsao.get_posto_display()} - {previsao.get_quadro_display()}"
        previsoes_dict[key] = previsao
    
    # Processar atualizaÃ§Ã£o se solicitado
    if request.method == 'POST' and 'atualizar_efetivo' in request.POST:
        try:
            resultado = atualizar_todas_vagas_efetivo()
            messages.success(
                request, 
                f"Efetivo atualizado com sucesso! "
                f"Militares processados: {resultado['militares_processados']}, "
                f"Vagas criadas: {resultado['vagas_criadas']}, "
                f"Vagas atualizadas: {resultado['vagas_atualizadas']}, "
                f"PrevisÃµes atualizadas: {resultado['previsoes_atualizadas']}"
            )
            return redirect('militares:status_efetivo_vagas')
        except Exception as e:
            messages.error(request, f"Erro ao atualizar efetivo: {str(e)}")
    
    context = {
        'efetivo_por_posto_quadro': efetivo_por_posto_quadro,
        'vagas_dict': vagas_dict,
        'previsoes_dict': previsoes_dict,
        'total_militares_ativos': militares_ativos.count(),
        'total_vagas': vagas.count(),
        'total_previsoes': previsoes.count(),
    }
    
    return render(request, 'militares/status_efetivo_vagas.html', context)

@login_required
def reordenar_antiguidade_apos_inativacao(request):
    """View para reordenar numeraÃ§Ãµes de antiguidade apÃ³s inativaÃ§Ãµes"""
    if request.method == 'POST':
        posto = request.POST.get('posto')
        quadro = request.POST.get('quadro')
        
        try:
            # Executar reordenaÃ§Ã£o
            total_reordenados = Militar.reordenar_todos_apos_inativacao(
                posto_graduacao=posto if posto else None,
                quadro=quadro if quadro else None
            )
            
            messages.success(
                request, 
                f'ReordenaÃ§Ã£o concluÃ­da com sucesso! {total_reordenados} militares foram reordenados.'
            )
            
        except Exception as e:
            messages.error(request, f'Erro ao reordenar: {str(e)}')
        
        return redirect('militares:status_efetivo_vagas')
    
    # GET - mostrar formulÃ¡rio
    context = {
        'postos': POSTO_GRADUACAO_CHOICES,
        'quadros': QUADRO_CHOICES,
    }
    
    return render(request, 'militares/reordenar_antiguidade_apos_inativacao.html', context)

@login_required
def promocao_subtenente_view(request):
    """View especÃ­fica para promoÃ§Ã£o de subtenentes do quadro praÃ§as para complementar"""
    if request.method == 'POST':
        militar_id = request.POST.get('militar_id')
        data_promocao = request.POST.get('data_promocao')
        
        if not militar_id or not data_promocao:
            messages.error(request, 'Militar e data de promoÃ§Ã£o sÃ£o obrigatÃ³rios.')
            return redirect('militares:militar_list')
        
        try:
            from datetime import datetime
            data_promocao = datetime.strptime(data_promocao, '%Y-%m-%d').date()
        except ValueError:
            messages.error(request, 'Data de promoÃ§Ã£o invÃ¡lida.')
            return redirect('militares:militar_list')
        
        try:
            militar = Militar.objects.get(pk=militar_id)
            
            # Verificar se Ã© subtenente do quadro praÃ§as
            if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
                messages.error(request, 'Apenas subtenentes do quadro praÃ§as podem ser promovidos.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Verificar se estÃ¡ apto para promoÃ§Ã£o
            if not militar.apto_promocao_antiguidade():
                messages.error(request, 'Militar nÃ£o estÃ¡ apto para promoÃ§Ã£o. Verifique inspeÃ§Ã£o de saÃºde, interstÃ­cio e cursos obrigatÃ³rios.')
                return redirect('militares:militar_detail', pk=militar_id)
            
            # Capturar dados anteriores
            posto_anterior = militar.posto_graduacao
            quadro_anterior = militar.quadro
            
            # Atualizar posto e quadro
            militar.posto_graduacao = '2T'  # 2Âº Tenente
            militar.quadro = 'COMP'  # Complementar
            militar.data_promocao_atual = data_promocao
            
            # Aplicar nova numeraÃ§Ã£o por promoÃ§Ã£o
            nova_numeracao = militar.atribuir_numeracao_por_promocao(posto_anterior, quadro_anterior)
            
            # Reordenar os militares do posto anterior (preencher gap)
            militares_reordenados = militar.reordenar_posto_anterior_apos_promocao(posto_anterior, quadro_anterior)
            
            # LÃ“GICA ESPECIAL: Converter ficha de conceito quando Subtenente promove para 2Âº Tenente
            ficha_oficiais, mensagem_conversao = militar.converter_ficha_pracas_para_oficiais(
                motivo_conversao="PromoÃ§Ã£o de Subtenente para 2Âº Tenente"
            )
            
            if ficha_oficiais:
                mensagem_adicional = " Ficha de conceito convertida de praÃ§as para oficiais."
            else:
                mensagem_adicional = f" {mensagem_conversao}"
            
            # Salvar as alteraÃ§Ãµes
            militar.save()
            
            # Registrar a promoÃ§Ã£o no histÃ³rico
            from militares.models import Promocao
            Promocao.objects.create(
                militar=militar,
                posto_anterior=posto_anterior,
                posto_novo='2T',
                criterio='ANTIGUIDADE',
                data_promocao=data_promocao,
                data_publicacao=data_promocao,
                numero_ato='PromoÃ§Ã£o automÃ¡tica via sistema',
                observacoes=f'PromoÃ§Ã£o de Subtenente (PraÃ§as) para 2Âº Tenente (Complementar). Nova numeraÃ§Ã£o: {nova_numeracao}Âº.{mensagem_adicional}'
            )
            
            messages.success(
                request, 
                f'PromoÃ§Ã£o realizada com sucesso! {militar.nome_completo} foi promovido de Subtenente (PraÃ§as) para 2Âº Tenente (Complementar) com a {nova_numeracao}Âª numeraÃ§Ã£o de antiguidade. {militares_reordenados} militares foram reordenados no posto anterior.{mensagem_adicional}'
            )
            
            return redirect('militares:militar_detail', pk=militar_id)
            
        except Militar.DoesNotExist:
            messages.error(request, 'Militar nÃ£o encontrado.')
            return redirect('militares:militar_list')
        except Exception as e:
            messages.error(request, f'Erro ao realizar promoÃ§Ã£o: {str(e)}')
            return redirect('militares:militar_detail', pk=militar_id)
    
    # GET - mostrar formulÃ¡rio de promoÃ§Ã£o
    militar_id = request.GET.get('militar_id')
    if not militar_id:
        messages.error(request, 'ID do militar Ã© obrigatÃ³rio.')
        return redirect('militares:militar_list')
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Verificar se Ã© subtenente do quadro praÃ§as
        if militar.posto_graduacao != 'ST' or militar.quadro != 'PRACAS':
            messages.error(request, 'Apenas subtenentes do quadro praÃ§as podem ser promovidos.')
            return redirect('militares:militar_detail', pk=militar_id)
        
        # Verificar se estÃ¡ apto para promoÃ§Ã£o
        apto_promocao = militar.apto_promocao_antiguidade()
        
        # Calcular prÃ³xima data de promoÃ§Ã£o
        from datetime import date
        hoje = date.today()
        proxima_data = date(hoje.year, 7, 18) if hoje < date(hoje.year, 7, 18) else date(hoje.year, 12, 25)
        
        context = {
            'militar': militar,
            'apto_promocao': apto_promocao,
            'proxima_data': proxima_data,
        }
        
        return render(request, 'militares/promocao_subtenente.html', context)
        
    except Militar.DoesNotExist:
        messages.error(request, 'Militar nÃ£o encontrado.')
        return redirect('militares:militar_list')

@login_required
@administracao_required
def usuarios_custom_list(request):
    # ParÃ¢metros de filtro
    query = request.GET.get('q', '').strip()
    status = request.GET.get('status', '')
    grupo = request.GET.get('grupo', '')
    ordenacao = request.GET.get('ordenacao', 'nome')
    
    # Query base
    usuarios = User.objects.all().select_related('militar').prefetch_related('groups', 'funcoes')
    
    # Aplicar filtros
    if query:
        usuarios = usuarios.filter(
            Q(first_name__icontains=query) |
            Q(last_name__icontains=query) |
            Q(username__icontains=query) |
            Q(email__icontains=query) |
            Q(militar__nome_completo__icontains=query)
        )
    
    if status == 'ativo':
        usuarios = usuarios.filter(is_active=True)
    elif status == 'inativo':
        usuarios = usuarios.filter(is_active=False)
    
    if grupo:
        usuarios = usuarios.filter(groups__name__icontains=grupo)
    
    # Aplicar ordenaÃ§Ã£o
    if ordenacao == 'nome':
        usuarios = usuarios.order_by('first_name', 'last_name')
    elif ordenacao == 'username':
        usuarios = usuarios.order_by('username')
    elif ordenacao == 'email':
        usuarios = usuarios.order_by('email')
    elif ordenacao == 'data_criacao':
        usuarios = usuarios.order_by('-date_joined')
    elif ordenacao == 'status':
        usuarios = usuarios.order_by('-is_active', 'first_name')
    else:
        usuarios = usuarios.order_by('first_name', 'last_name')
    
    # Buscar militar e funÃ§Ãµes/cargos
    usuarios_info = []
    for usuario in usuarios:
        militar = getattr(usuario, 'militar', None)
        funcoes_militar = []
        if militar:
            membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
            funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
        
        # FunÃ§Ãµes diretas do usuÃ¡rio
        funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
        
        usuarios_info.append({
            'usuario': usuario,
            'militar': militar,
            'funcoes_militar': funcoes_militar,
            'funcoes_usuario': funcoes_usuario,
        })
    
    # EstatÃ­sticas
    total_usuarios = User.objects.count()
    usuarios_ativos = User.objects.filter(is_active=True).count()
    usuarios_inativos = User.objects.filter(is_active=False).count()
    
    # Grupos disponÃ­veis para filtro
    grupos_disponiveis = Group.objects.all().order_by('name')
    
    context = {
        'usuarios_info': usuarios_info,
        'query': query,
        'status': status,
        'grupo': grupo,
        'ordenacao': ordenacao,
        'total_usuarios': total_usuarios,
        'usuarios_ativos': usuarios_ativos,
        'usuarios_inativos': usuarios_inativos,
        'grupos_disponiveis': grupos_disponiveis,
        'resultados_count': len(usuarios_info),
    }
    return render(request, 'militares/usuarios/custom_list.html', context)

@login_required
@permission_required('auth.view_user')
def usuario_detail(request, pk):
    """Detalhes de um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    # Buscar militar vinculado
    militar = getattr(usuario, 'militar', None)
    funcoes_militar = []
    
    if militar:
        membros_comissao = MembroComissao.objects.filter(militar=militar, ativo=True)
        funcoes_militar = [membro.get_tipo_display() for membro in membros_comissao]
    
    # FunÃ§Ãµes diretas do usuÃ¡rio
    funcoes_usuario = usuario.funcoes.filter(status='ATIVO').order_by('tipo_funcao', 'cargo_funcao__nome')
    
    # PermissÃµes do usuÃ¡rio
    permissoes_usuario = usuario.user_permissions.all()
    permissoes_grupos = []
    for grupo in usuario.groups.all():
        permissoes_grupo = grupo.permissions.all()
        permissoes_grupos.extend(permissoes_grupo)
    permissoes_grupos = list(set(permissoes_grupos))
    
    context = {
        'usuario': usuario,
        'militar': militar,
        'funcoes_militar': funcoes_militar,
        'funcoes_usuario': funcoes_usuario,
        'permissoes_usuario': permissoes_usuario,
        'permissoes_grupos': permissoes_grupos,
    }
    return render(request, 'militares/usuarios/detail.html', context)

# Views para gerenciamento de permissÃµes

@login_required
@permission_required('auth.change_user')
def usuario_update(request, pk):
    """Editar um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        # FormulÃ¡rio simples para editar dados bÃ¡sicos
        first_name = request.POST.get('first_name', '')
        last_name = request.POST.get('last_name', '')
        email = request.POST.get('email', '')
        is_active = request.POST.get('is_active') == 'on'
        
        usuario.first_name = first_name
        usuario.last_name = last_name
        usuario.email = email
        usuario.is_active = is_active
        usuario.save()
        
        messages.success(request, f'UsuÃ¡rio {usuario.get_full_name()} atualizado com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/update.html', context)

@login_required
@permission_required('auth.delete_user')
def usuario_delete(request, pk):
    """Excluir um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        nome_usuario = usuario.get_full_name()
        usuario.delete()
        messages.success(request, f'UsuÃ¡rio {nome_usuario} excluÃ­do com sucesso!')
        return redirect('militares:usuarios_custom_list')
    
    context = {
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/delete.html', context)

# Views para gerenciar funÃ§Ãµes dos usuÃ¡rios
@login_required
@permission_required('auth.view_user')
def usuario_funcoes_list(request, pk):
    """Lista todas as funÃ§Ãµes de um usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcoes = usuario.funcoes.all().order_by('-data_inicio')
    
    # EstatÃ­sticas
    funcoes_ativas = funcoes.filter(status='AT')
    funcoes_inativas = funcoes.filter(status='INATIVO')
    funcoes_suspensas = funcoes.filter(status='SUSPENSO')
    
    context = {
        'usuario': usuario,
        'funcoes': funcoes,
        'funcoes_ativas': funcoes_ativas,
        'funcoes_inativas': funcoes_inativas,
        'funcoes_suspensas': funcoes_suspensas,
    }
    return render(request, 'militares/usuarios/funcoes/list.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_add(request, pk):
    """Adiciona uma nova funÃ§Ã£o ao usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST)
        if form.is_valid():
            # Verificar se jÃ¡ existe uma funÃ§Ã£o com a mesma combinaÃ§Ã£o
            cargo_funcao = form.cleaned_data['cargo_funcao']
            data_inicio = form.cleaned_data['data_inicio']
            
            funcao_existente = UsuarioFuncao.objects.filter(
                usuario=usuario,
                cargo_funcao=cargo_funcao,
                data_inicio=data_inicio
            ).first()
            
            if funcao_existente:
                messages.error(request, f'JÃ¡ existe uma funÃ§Ã£o "{cargo_funcao.nome}" para este usuÃ¡rio com a data de inÃ­cio {data_inicio}.')
                context = {
                    'form': form,
                    'usuario': usuario,
                }
                return render(request, 'militares/usuarios/funcoes/form.html', context)
            
            funcao = form.save(commit=False)
            funcao.usuario = usuario
            funcao.save()
            messages.success(request, f'FunÃ§Ã£o "{funcao.cargo_funcao.nome}" adicionada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(initial={'usuario': usuario})
    
    context = {
        'form': form,
        'usuario': usuario,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_edit(request, pk, funcao_pk):
    """Edita uma funÃ§Ã£o do usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST, instance=funcao)
        if form.is_valid():
            form.save()
            messages.success(request, f'FunÃ§Ã£o "{funcao.cargo_funcao.nome}" atualizada com sucesso!')
            return redirect('militares:usuario_funcoes_list', pk=usuario.pk)
    else:
        form = UsuarioFuncaoForm(instance=funcao)
    
    context = {
        'form': form,
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/form.html', context)

@login_required
@permission_required('auth.change_user')
def usuario_funcao_delete(request, pk, funcao_pk):
    """Remove uma funÃ§Ã£o do usuÃ¡rio"""
    usuario = get_object_or_404(User, pk=pk)
    funcao = get_object_or_404(UsuarioFuncao, pk=funcao_pk, usuario=usuario)
    
    if request.method == 'POST':
        nome_funcao = funcao.cargo_funcao.nome
        
        # Verificar se a funÃ§Ã£o excluÃ­da Ã© a mesma que estÃ¡ na sessÃ£o do usuÃ¡rio
        funcao_na_sessao = request.session.get('funcao_atual_id')
        if funcao_na_sessao and int(funcao_na_sessao) == funcao_pk:
            # Se for a funÃ§Ã£o da sessÃ£o, limpar a sessÃ£o antes de excluir
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
        
        cargo_id = funcao.cargo_funcao.id
        funcao.delete()
        messages.success(request, f'FunÃ§Ã£o "{nome_funcao}" removida com sucesso!')
        return redirect('militares:cargo_funcao_detail', cargo_id=cargo_id)
    
    context = {
        'usuario': usuario,
        'funcao': funcao,
    }
    return render(request, 'militares/usuarios/funcoes/delete.html', context)

# Views para seleÃ§Ã£o de funÃ§Ã£o apÃ³s login
def selecionar_funcao(request):
    """
    View para selecionar funÃ§Ã£o/cargo apÃ³s login
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funÃ§Ãµes ativas do usuÃ¡rio
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    # Se sÃ³ tem uma funÃ§Ã£o, seleciona automaticamente
    if funcoes_usuario.count() == 1:
        funcao = funcoes_usuario.first()
        request.session['funcao_atual_id'] = funcao.id
        request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
        request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
        messages.success(request, f'FunÃ§Ã£o selecionada automaticamente: {funcao.cargo_funcao.nome}')
        return redirect('militares:militar_dashboard')
    
    # Se nÃ£o tem funÃ§Ãµes, redireciona para erro
    if funcoes_usuario.count() == 0:
        messages.error(request, 'VocÃª nÃ£o possui funÃ§Ãµes ativas no sistema.')
        return redirect('logout')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'FunÃ§Ã£o selecionada: {funcao.cargo_funcao.nome}')
                return redirect('militares:militar_dashboard')
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'FunÃ§Ã£o invÃ¡lida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/selecionar_funcao.html', context)

def trocar_funcao(request):
    """
    View para trocar funÃ§Ã£o durante a sessÃ£o
    """
    if not request.user.is_authenticated:
        return redirect('login')
    
    # Buscar funÃ§Ãµes ativas do usuÃ¡rio
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao')
    
    if request.method == 'POST':
        funcao_id = request.POST.get('funcao_id')
        if funcao_id:
            try:
                funcao = funcoes_usuario.get(id=funcao_id)
                request.session['funcao_atual_id'] = funcao.id
                request.session['funcao_atual_nome'] = funcao.cargo_funcao.nome
                request.session['funcoes_disponiveis'] = list(funcoes_usuario.values('id', 'cargo_funcao__nome'))
                messages.success(request, f'FunÃ§Ã£o alterada para: {funcao.cargo_funcao.nome}')
                return redirect(request.POST.get('next', 'militares:militar_dashboard'))
            except UsuarioFuncao.DoesNotExist:
                messages.error(request, 'FunÃ§Ã£o invÃ¡lida selecionada.')
    
    context = {
        'funcoes': funcoes_usuario,
        'usuario': request.user,
        'funcao_atual_id': request.session.get('funcao_atual_id'),
        'next': request.GET.get('next', 'militares:militar_dashboard'),
    }
    return render(request, 'militares/usuarios/trocar_funcao.html', context)

def obter_funcao_atual(request):
    """
    FunÃ§Ã£o helper para obter a funÃ§Ã£o atual da sessÃ£o
    """
    if not request.user.is_authenticated:
        return None
    
    funcao_id = request.session.get('funcao_atual_id')
    if funcao_id:
        try:
            return UsuarioFuncao.objects.get(id=funcao_id, usuario=request.user)
        except UsuarioFuncao.DoesNotExist:
            # Se a funÃ§Ã£o nÃ£o existe mais, limpa a sessÃ£o
            request.session.pop('funcao_atual_id', None)
            request.session.pop('funcao_atual_nome', None)
    
    return None

@login_required
@csrf_protect
def alterar_senha(request):
    """View para alterar senha do usuÃ¡rio logado"""
    if request.method == 'POST':
        form = AlterarSenhaForm(request.user, request.POST)
        if form.is_valid():
            form.save()
            # Atualizar a sessÃ£o para nÃ£o deslogar o usuÃ¡rio
            update_session_auth_hash(request, form.user)
            messages.success(request, 'âœ… Senha alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=request.user.pk)
    else:
        form = AlterarSenhaForm(request.user)
    
    context = {
        'form': form,
        'usuario': request.user,
    }
    return render(request, 'militares/usuarios/alterar_senha.html', context)

@login_required
@permission_required('auth.change_user')
def alterar_senha_usuario(request, pk):
    """View para administradores alterarem senha de outros usuÃ¡rios"""
    usuario = get_object_or_404(User, pk=pk)
    
    if request.method == 'POST':
        form = AlterarSenhaAdminForm(usuario, request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, f'âœ… Senha do usuÃ¡rio {usuario.get_full_name()} alterada com sucesso!')
            return redirect('militares:usuario_detail', pk=usuario.pk)
    else:
        form = AlterarSenhaAdminForm(usuario)
    
    context = {
        'form': form,
        'usuario': usuario,
        'usuario_alvo': usuario,
    }
    return render(request, 'militares/usuarios/alterar_senha_admin.html', context)

class AlterarSenhaForm(forms.Form):
    """FormulÃ¡rio para alterar senha"""
    senha_atual = forms.CharField(
        label='Senha Atual',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite sua senha atual'
        }),
        strip=False
    )
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean_senha_atual(self):
        senha_atual = self.cleaned_data.get('senha_atual')
        if not self.user.check_password(senha_atual):
            raise forms.ValidationError('Senha atual incorreta.')
        return senha_atual

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas nÃ£o coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user

class AlterarSenhaAdminForm(forms.Form):
    """FormulÃ¡rio para administradores alterarem senha de outros usuÃ¡rios"""
    nova_senha1 = forms.CharField(
        label='Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Digite a nova senha'
        }),
        strip=False
    )
    nova_senha2 = forms.CharField(
        label='Confirmar Nova Senha',
        widget=forms.PasswordInput(attrs={
            'class': 'form-control',
            'placeholder': 'Confirme a nova senha'
        }),
        strip=False
    )

    def __init__(self, user, *args, **kwargs):
        self.user = user
        super().__init__(*args, **kwargs)

    def clean(self):
        cleaned_data = super().clean()
        nova_senha1 = cleaned_data.get('nova_senha1')
        nova_senha2 = cleaned_data.get('nova_senha2')

        if nova_senha1 and nova_senha2:
            if nova_senha1 != nova_senha2:
                raise forms.ValidationError('As senhas nÃ£o coincidem.')
            
            # Validar a nova senha
            try:
                validate_password(nova_senha2, self.user)
            except ValidationError as e:
                raise forms.ValidationError(e.messages[0])

        return cleaned_data

    def save(self, commit=True):
        nova_senha = self.cleaned_data['nova_senha1']
        self.user.set_password(nova_senha)
        if commit:
            self.user.save()
        return self.user

@login_required
def cargo_funcao_delete(request, cargo_id):
    """
    Exclui um cargo/funÃ§Ã£o e todas as suas relaÃ§Ãµes
    - Remove todas as funÃ§Ãµes de usuÃ¡rios vinculadas
    - Remove todas as permissÃµes vinculadas
    - Exclui o cargo/funÃ§Ã£o
    """
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    erro_protegido = False
    
    # Buscar todas as relaÃ§Ãµes
    usuarios_com_funcao = UsuarioFuncao.objects.filter(cargo_funcao=cargo)
    permissoes_vinculadas = PermissaoFuncao.objects.filter(cargo_funcao=cargo)
    
    if request.method == 'POST':
        try:
            # Contadores para feedback
            usuarios_removidos = 0
            permissoes_removidas = 0
            
            # 1. Remover todas as funÃ§Ãµes de usuÃ¡rios vinculadas
            if usuarios_com_funcao.exists():
                usuarios_removidos = usuarios_com_funcao.count()
                usuarios_com_funcao.delete()
                messages.warning(request, f'{usuarios_removidos} funÃ§Ã£o(Ãµes) de usuÃ¡rio(s) removida(s) automaticamente.')
            
            # 2. Remover todas as permissÃµes vinculadas
            if permissoes_vinculadas.exists():
                permissoes_removidas = permissoes_vinculadas.count()
                permissoes_vinculadas.delete()
                messages.warning(request, f'{permissoes_removidas} permissÃ£o(Ãµes) removida(s) automaticamente.')
            
            # 3. Excluir o cargo/funÃ§Ã£o
            nome_cargo = cargo.nome
            cargo.delete()
            
            # Mensagem de sucesso
            if usuarios_removidos > 0 or permissoes_removidas > 0:
                messages.success(request, f'Cargo/FunÃ§Ã£o "{nome_cargo}" excluÃ­do com sucesso! {usuarios_removidos} funÃ§Ã£o(Ãµes) de usuÃ¡rio(s) e {permissoes_removidas} permissÃ£o(Ãµes) foram removidas automaticamente.')
            else:
                messages.success(request, f'Cargo/FunÃ§Ã£o "{nome_cargo}" excluÃ­do com sucesso!')
            
            return redirect('militares:cargo_funcao_list')
            
        except Exception as e:
            erro_protegido = True
            messages.error(request, f'Erro ao excluir cargo/funÃ§Ã£o: {str(e)}')
    
    context = {
        'cargo': cargo,
        'erro_protegido': erro_protegido,
        'usuarios_com_funcao': usuarios_com_funcao,
        'permissoes_vinculadas': permissoes_vinculadas,
        'total_usuarios': usuarios_com_funcao.count(),
        'total_permissoes': permissoes_vinculadas.count(),
    }
    return render(request, 'militares/cargos/cargo_funcao_confirm_delete.html', context)

from django.contrib.auth.models import Group, Permission
from django.contrib.auth.decorators import login_required, permission_required
from django.shortcuts import render, redirect, get_object_or_404
from django.contrib import messages

@login_required
def buscar_funcao_militar(request):
    """Busca a funÃ§Ã£o/cargo do militar para preenchimento automÃ¡tico"""
    militar_id = request.GET.get('militar_id')
    
    if not militar_id:
        return JsonResponse({'error': 'ID do militar nÃ£o fornecido'}, status=400)
    
    try:
        militar = Militar.objects.get(pk=militar_id)
        
        # Buscar funÃ§Ã£o do militar atravÃ©s do usuÃ¡rio vinculado
        funcao_militar = None
        if militar.user:
            # Buscar funÃ§Ã£o ativa do usuÃ¡rio
            funcao_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='ATIVO'
            ).select_related('cargo_funcao').first()
            
            if funcao_usuario:
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        # Se nÃ£o encontrou funÃ§Ã£o via usuÃ¡rio, buscar todas as funÃ§Ãµes do usuÃ¡rio
        if not funcao_militar and militar.user:
            # Buscar todas as funÃ§Ãµes ativas do usuÃ¡rio
            funcoes_usuario = UsuarioFuncao.objects.filter(
                usuario=militar.user,
                status='AT'
            ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
            
            if funcoes_usuario.exists():
                # Se hÃ¡ mÃºltiplas funÃ§Ãµes, retornar a primeira como padrÃ£o
                funcao_usuario = funcoes_usuario.first()
                funcao_militar = {
                    'id': funcao_usuario.cargo_funcao.id,
                    'nome': funcao_usuario.cargo_funcao.nome,
                    'tipo': funcao_usuario.get_tipo_funcao_display()
                }
        
        return JsonResponse({
            'success': True,
            'funcao': funcao_militar,
            'militar': {
                'id': militar.id,
                'nome': militar.nome_completo,
                'posto': militar.get_posto_graduacao_display(),
                'matricula': militar.matricula
            }
        })
        
    except Militar.DoesNotExist:
        return JsonResponse({'error': 'Militar nÃ£o encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar funÃ§Ã£o: {str(e)}'}, status=500)

@login_required
def buscar_funcoes_usuario(request):
    """Busca as funÃ§Ãµes/cargos do usuÃ¡rio para permitir escolha"""
    usuario_id = request.GET.get('usuario_id')
    
    if not usuario_id:
        return JsonResponse({'error': 'ID do usuÃ¡rio nÃ£o fornecido'}, status=400)
    
    try:
        usuario = User.objects.get(pk=usuario_id)
        
        # Buscar todas as funÃ§Ãµes ativas do usuÃ¡rio
        funcoes_usuario = UsuarioFuncao.objects.filter(
            usuario=usuario,
            status='AT'
        ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
        
        funcoes = []
        for funcao in funcoes_usuario:
            funcoes.append({
                'id': funcao.cargo_funcao.id,
                'nome': funcao.cargo_funcao.nome,
                'tipo': funcao.get_tipo_funcao_display(),
                'descricao': funcao.cargo_funcao.descricao or '',
                'data_inicio': funcao.data_inicio.strftime('%d/%m/%Y'),
                'data_fim': funcao.data_fim.strftime('%d/%m/%Y') if funcao.data_fim else None
            })
        
        return JsonResponse({
            'success': True,
            'funcoes': funcoes,
            'usuario': {
                'id': usuario.id,
                'nome': usuario.get_full_name(),
                'username': usuario.username
            }
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'UsuÃ¡rio nÃ£o encontrado'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Erro ao buscar funÃ§Ãµes: {str(e)}'}, status=500)

@login_required
def voto_deliberacao_delete(request, voto_pk):
    """Excluir voto de uma deliberaÃ§Ã£o"""
    try:
        voto = VotoDeliberacao.objects.get(pk=voto_pk)
        deliberacao = voto.deliberacao
        sessao = deliberacao.sessao
        comissao = sessao.comissao
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:comissao_list')
    
    # Verificar se o usuÃ¡rio logado Ã© o autor do voto ou tem permissÃ£o
    if voto.membro.usuario != request.user:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para excluir este voto.')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    if request.method == 'POST':
        # Verificar se a senha foi fornecida
        senha_votante = request.POST.get('senha_votante')
        if not senha_votante:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar a exclusÃ£o.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Validar senha do usuÃ¡rio
        if not request.user.check_password(senha_votante):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:voto_deliberacao_create', deliberacao_pk=deliberacao.pk)
        
        # Excluir o voto
        voto.delete()
        
        # Atualizar contadores da deliberaÃ§Ã£o
        votos_favor = deliberacao.votos.filter(voto='FAVOR').count()
        votos_contra = deliberacao.votos.filter(voto='CONTRA').count()
        votos_abstencao = deliberacao.votos.filter(voto='ABSTENCAO').count()
        
        deliberacao.votos_favor = votos_favor
        deliberacao.votos_contra = votos_contra
        deliberacao.votos_abstencao = votos_abstencao
        deliberacao.save()
        
        messages.success(request, 'âœ… Voto excluÃ­do com sucesso!')
        return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
    
    context = {
        'voto': voto,
        'deliberacao': deliberacao,
        'sessao': sessao,
        'comissao': comissao,
    }
    return render(request, 'militares/comissao/deliberacoes/voto_delete.html', context)

@login_required
def assinar_ata_eletronica(request, pk):
    """Processar assinatura eletrÃ´nica da ata"""
    if request.method != 'POST':
        return JsonResponse({'success': False, 'error': 'MÃ©todo nÃ£o permitido'})
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            return JsonResponse({
                'success': False,
                'error': 'VocÃª nÃ£o Ã© membro desta comissÃ£o.'
            })
        
        # Buscar a ata da sessÃ£o
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            return JsonResponse({
                'success': False,
                'error': 'Ata nÃ£o encontrada para esta sessÃ£o.'
            })
        
        # Verificar se a ata estÃ¡ para assinatura
        if ata.status != 'PARA_ASSINATURA':
            return JsonResponse({
                'success': False,
                'error': 'Ata nÃ£o estÃ¡ disponÃ­vel para assinatura.'
            })
        
        # Processar dados da assinatura
        import json
        dados = json.loads(request.body)
        
        hash_documento = dados.get('hash')
        timestamp = dados.get('timestamp')
        assinatura_digital = dados.get('assinatura')
        certificado = dados.get('certificado')
        assinante = dados.get('assinante')
        data_assinatura = dados.get('data_assinatura')
        
        # Validar dados obrigatÃ³rios (certificado pode ser 'ASSINATURA_SIMPLES_SEI' para assinatura simples)
        if not all([hash_documento, timestamp, assinatura_digital, assinante]):
            return JsonResponse({
                'success': False,
                'error': 'Dados de assinatura incompletos.'
            })
        
        # Criar registro de assinatura
        from .models import AssinaturaAta
        
        # Buscar o membro da comissÃ£o
        membro = MembroComissao.objects.get(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        )
        
        # Capturar a funÃ§Ã£o atual do usuÃ¡rio na sessÃ£o
        funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema')
        
        # Verificar se jÃ¡ existe uma assinatura para este membro nesta ata
        assinatura_criada = False
        try:
            assinatura = AssinaturaAta.objects.get(ata=ata, membro=membro)
            # Atualizar a assinatura existente com os novos dados eletrÃ´nicos
            assinatura.hash_documento = hash_documento
            assinatura.timestamp = timestamp
            assinatura.assinatura_digital = assinatura_digital
            assinatura.certificado = certificado or 'ASSINATURA_SIMPLES_SEI'
            assinatura.ip_assinatura = request.META.get('REMOTE_ADDR', '')
            assinatura.user_agent = request.META.get('HTTP_USER_AGENT', '')
            assinatura.assinado_por = request.user
            assinatura.funcao_assinatura = funcao_atual
            assinatura.save()
        except AssinaturaAta.DoesNotExist:
            # Criar nova assinatura
            assinatura = AssinaturaAta.objects.create(
                ata=ata,
                membro=membro,
                assinado_por=request.user,
                hash_documento=hash_documento,
                timestamp=timestamp,
                assinatura_digital=assinatura_digital,
                certificado=certificado or 'ASSINATURA_SIMPLES_SEI',
                ip_assinatura=request.META.get('REMOTE_ADDR', ''),
                user_agent=request.META.get('HTTP_USER_AGENT', ''),
                funcao_assinatura=funcao_atual
            )
            assinatura_criada = True
        
        # Verificar se todos os membros presentes assinaram
        membros_presentes = sessao.presencas.filter(presente=True)
        assinaturas_realizadas = AssinaturaAta.objects.filter(ata=ata)
        
        if assinaturas_realizadas.count() >= membros_presentes.count():
            # Todos assinaram, marcar ata como assinada
            ata.status = 'ASSINADA'
            ata.save()
            
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Ata marcada como assinada.',
                'ata_status': 'ASSINADA'
            })
        else:
            acao = 'assinado' if assinatura_criada else 'atualizado'
            return JsonResponse({
                'success': True,
                'message': f'Documento {acao} com sucesso! Aguardando outras assinaturas.',
                'ata_status': 'PARA_ASSINATURA',
                'assinaturas_restantes': membros_presentes.count() - assinaturas_realizadas.count()
            })
        
    except SessaoComissao.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'SessÃ£o nÃ£o encontrada.'
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': f'Erro ao processar assinatura: {str(e)}'
        })

@login_required
def ata_assinaturas_eletronicas(request, pk):
    """PÃ¡gina para visualizar assinaturas eletrÃ´nicas da ata no formato SEI"""
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar a ata da sessÃ£o
        try:
            ata = AtaSessao.objects.get(sessao=sessao)
        except AtaSessao.DoesNotExist:
            messages.error(request, 'Ata nÃ£o encontrada para esta sessÃ£o.')
            return redirect('militares:sessao_comissao_detail', pk=sessao.pk)
        
        # Buscar assinaturas eletrÃ´nicas
        assinaturas = AssinaturaAta.objects.filter(ata=ata).order_by('data_assinatura')
        
        context = {
            'sessao': sessao,
            'comissao': sessao.comissao,
            'ata': ata,
            'assinaturas': assinaturas,
            'membro_usuario': membro,
        }
        
        return render(request, 'militares/comissao/sessoes/ata_assinaturas_eletronicas.html', context)
        
    except SessaoComissao.DoesNotExist:
        messages.error(request, 'SessÃ£o nÃ£o encontrada.')
        return redirect('militares:comissao_list')
    except Exception as e:
        messages.error(request, f'Erro ao carregar assinaturas: {str(e)}')
        return redirect('militares:sessao_comissao_detail', pk=pk)

@login_required
def quadro_fixacao_vagas_visualizar_html(request, pk):
    quadro = get_object_or_404(QuadroFixacaoVagas, pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e tem permissÃ£o para visualizar este quadro
    # SuperusuÃ¡rios e staff tÃªm acesso total, independente de serem membros de comissÃ£o
    if not request.user.is_superuser and not request.user.is_staff:
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        ).first()
        
        if membro_comissao:
            if membro_comissao.comissao.tipo == 'CPO' and quadro.tipo != 'OFICIAIS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
            elif membro_comissao.comissao.tipo == 'CPP' and quadro.tipo != 'PRACAS':
                messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para visualizar este quadro.')
                return redirect('militares:quadro_fixacao_vagas_list')
    assinaturas = quadro.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    # Agrupar itens por quadro e ordenar por hierarquia
    itens_por_quadro = {}
    for item in quadro.itens.all().select_related('previsao_vaga'):
        quadro_nome = item.previsao_vaga.quadro
        if quadro_nome not in itens_por_quadro:
            itens_por_quadro[quadro_nome] = []
        itens_por_quadro[quadro_nome].append(item)
    
    # Definir hierarquia dos postos (do mais alto para o mais baixo)
    hierarquia_postos = {
        'CB': 1,   # Coronel
        'TC': 2,   # Tenente Coronel
        'MJ': 3,   # Major
        'CP': 4,   # CapitÃ£o
        '1T': 5,   # 1Âº Tenente
        '2T': 6,   # 2Âº Tenente
        'AS': 7,   # Aspirante a Oficial
        'AA': 8,   # Aluno de AdaptaÃ§Ã£o
        'ST': 9,   # Subtenente
        '1S': 10,  # 1Âº Sargento
        '2S': 11,  # 2Âº Sargento
        '3S': 12,  # 3Âº Sargento
        'CAB': 13, # Cabo
        'SD': 14,  # Soldado
    }
    
    # Ordenar itens por hierarquia (posto) dentro de cada quadro
    for quadro_nome in itens_por_quadro:
        itens_por_quadro[quadro_nome].sort(
            key=lambda x: hierarquia_postos.get(x.previsao_vaga.posto, 999)
        )
    
    # Ordenar quadros na sequÃªncia hierÃ¡rquica: COMB, SAUDE, ENG, COMP
    ordem_quadros = ['COMB', 'SAUDE', 'ENG', 'COMP']
    itens_por_quadro_ordenado = {}
    
    # Primeiro, adicionar os quadros na ordem hierÃ¡rquica
    for cod_quadro in ordem_quadros:
        if cod_quadro in itens_por_quadro:
            itens_por_quadro_ordenado[cod_quadro] = itens_por_quadro[cod_quadro]
    
    # Depois, adicionar outros quadros que possam existir
    for cod_quadro, itens in itens_por_quadro.items():
        if cod_quadro not in itens_por_quadro_ordenado:
            itens_por_quadro_ordenado[cod_quadro] = itens
    
    itens_por_quadro = itens_por_quadro_ordenado
    
    # Obter funÃ§Ãµes do usuÃ¡rio para o modal de assinatura
    funcoes_usuario = request.user.funcoes.all() if hasattr(request.user, 'funcoes') else []
    
    context = {
        'quadro': quadro,
        'assinaturas': assinaturas,
        'funcoes_usuario': funcoes_usuario,
        'itens_por_quadro': itens_por_quadro,
    }
    
    return render(request, 'militares/quadro_fixacao_vagas/visualizar.html', context)

@login_required
def ata_assinar_melhorada(request, pk):
    """Assinar ata seguindo o padrÃ£o dos quadros de acesso"""
    
    try:
        ata = AtaSessao.objects.get(sessao_id=pk)
    except AtaSessao.DoesNotExist:
        messages.error(request, 'Ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
    try:
        membro = MembroComissao.objects.get(
            comissao=ata.sessao.comissao,
            usuario=request.user,
            ativo=True
        )
    except MembroComissao.DoesNotExist:
        messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        # Processar assinatura
        membro_id = request.POST.get('membro_id')
        observacoes = request.POST.get('observacoes', '').strip()
        senha = request.POST.get('senha')
        
        if not membro_id:
            messages.error(request, 'Selecione um membro para assinar.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        if not senha:
            messages.error(request, 'Digite sua senha para confirmar a assinatura.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta.')
            return redirect('militares:ata_assinar_melhorada', pk=pk)
        
        try:
            membro_para_assinar = MembroComissao.objects.get(id=membro_id)
            # Verificar se o membro estava presente
            if not ata.sessao.presencas.filter(membro=membro_para_assinar, presente=True).exists():
                messages.error(request, 'Apenas membros presentes podem assinar a ata.')
                return redirect('militares:ata_assinar_melhorada', pk=pk)
            
            # Verificar se jÃ¡ nÃ£o assinou
            if ata.assinaturas.filter(membro=membro_para_assinar).exists():
                messages.error(request, 'Este membro jÃ¡ assinou a ata.')
                return redirect('militares:ata_assinar_melhorada', pk=pk)
            
            # Capturar a funÃ§Ã£o atual do usuÃ¡rio na sessÃ£o
            funcao_atual = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema')
            
            # Criar assinatura
            assinatura = AssinaturaAta.objects.create(
                ata=ata,
                membro=membro_para_assinar,
                assinado_por=request.user,
                observacoes=observacoes,
                funcao_assinatura=funcao_atual
            )
            
            messages.success(request, f'Assinatura de {membro_para_assinar.militar.nome_completo} registrada com sucesso!')
            
            # Verificar se todos assinaram
            membros_presentes = ata.sessao.presencas.filter(presente=True).count()
            assinaturas_count = ata.assinaturas.count()
            
            if assinaturas_count >= membros_presentes:
                ata.status = 'ASSINADA'
                ata.save()
                messages.info(request, 'Todos os membros presentes assinaram a ata!')
            
            return redirect('militares:ata_assinar_melhorada', pk=pk)
            
        except MembroComissao.DoesNotExist:
            messages.error(request, 'Membro nÃ£o encontrado.')
    
    # Obter membros presentes e suas assinaturas
    membros_presentes = ata.sessao.presencas.filter(presente=True).select_related('membro__militar', 'membro__cargo')
    assinaturas = ata.assinaturas.select_related('membro__militar', 'assinado_por')
    
    context = {
        'ata': ata,
        'sessao': ata.sessao,
        'comissao': ata.sessao.comissao,
        'membros_presentes': membros_presentes,
        'assinaturas': assinaturas,
        'membro_usuario': membro,
    }
    return render(request, 'militares/comissao/sessoes/ata_assinaturas_melhorada.html', context)

@login_required
def assinar_ata_html(request, pk):
    """Assinar ata via modal"""
    from .models import AtaSessao, AssinaturaAta
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        ata = AtaSessao.objects.get(sessao=sessao)
    except (SessaoComissao.DoesNotExist, AtaSessao.DoesNotExist):
        messages.error(request, 'SessÃ£o ou ata nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        observacoes = request.POST.get('observacoes', '')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Verificar se o usuÃ¡rio Ã© membro da comissÃ£o
        membro = MembroComissao.objects.filter(
            comissao=sessao.comissao,
            usuario=request.user,
            ativo=True
        ).first()
        
        if not membro:
            messages.error(request, 'VocÃª nÃ£o Ã© membro desta comissÃ£o.')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Verificar se jÃ¡ existe uma assinatura deste membro nesta ata
        assinatura_existente = AssinaturaAta.objects.filter(
            ata=ata,
            membro=membro
        ).first()
        
        if assinatura_existente:
            messages.error(request, f'VocÃª jÃ¡ assinou esta ata como "{assinatura_existente.get_tipo_assinatura_display()}".')
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
        
        # Usar a funÃ§Ã£o selecionada pelo usuÃ¡rio ou funÃ§Ã£o padrÃ£o
        if not funcao_assinatura:
            funcao_assinatura = request.session.get('funcao_atual_nome', 'UsuÃ¡rio do Sistema')
        
        # Criar assinatura
        assinatura = AssinaturaAta.objects.create(
            ata=ata,
            membro=membro,
            assinado_por=request.user,
            funcao_assinatura=funcao_assinatura,
            tipo_assinatura=tipo_assinatura,
            observacoes=observacoes,
            ip_assinatura=request.META.get('REMOTE_ADDR', ''),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        messages.success(request, 'Ata assinada com sucesso!')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    messages.error(request, 'MÃ©todo nÃ£o permitido.')
    return redirect('militares:sessao_gerar_ata', pk=sessao.pk)

@login_required
def retirar_assinatura_ata(request, pk, assinatura_pk):
    """Retirar assinatura da ata - apenas antes da finalizaÃ§Ã£o"""
    from .models import AtaSessao, AssinaturaAta
    
    try:
        sessao = SessaoComissao.objects.get(pk=pk)
        ata = AtaSessao.objects.get(sessao=sessao)
        assinatura = AssinaturaAta.objects.get(pk=assinatura_pk, ata=ata)
    except (SessaoComissao.DoesNotExist, AtaSessao.DoesNotExist, AssinaturaAta.DoesNotExist):
        messages.error(request, 'SessÃ£o, ata ou assinatura nÃ£o encontrada.')
        return redirect('militares:sessao_comissao_detail', pk=pk)
    
    # Verificar se a ata jÃ¡ foi finalizada
    if ata.status == 'FINALIZADA':
        messages.error(request, 'NÃ£o Ã© possÃ­vel retirar assinaturas de uma ata jÃ¡ finalizada.')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    # Verificar se o usuÃ¡rio Ã© o autor da assinatura ou tem permissÃ£o administrativa
    if assinatura.assinado_por != request.user and not request.user.is_staff:
        messages.error(request, 'VocÃª sÃ³ pode retirar suas prÃ³prias assinaturas.')
        return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'sessao': sessao,
                'ata': ata,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_ata.html', context)
        
        # Verificar se a assinatura Ã© de aprovaÃ§Ã£o e se hÃ¡ outras assinaturas de aprovaÃ§Ã£o
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = ata.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se nÃ£o hÃ¡ outras aprovaÃ§Ãµes, voltar o status da ata para PARA_ASSINATURA
                ata.status = 'PARA_ASSINATURA'
                ata.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a pÃ¡gina de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:sessao_gerar_ata', pk=sessao.pk)
    
    context = {
        'sessao': sessao,
        'ata': ata,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_ata.html', context)
from django.http import FileResponse
from reportlab.platypus import SimpleDocTemplate, Image, Spacer, Paragraph, Table, TableStyle, HRFlowable
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm
from reportlab.lib import colors
from io import BytesIO
import os
from django.contrib.auth.decorators import login_required
from django.shortcuts import redirect
from django.contrib import messages

@login_required
def voto_deliberacao_pdf(request, pk):
    """Gera PDF do voto individual, incluindo assinatura eletrÃ´nica no padrÃ£o dos quadros"""
    from .models import VotoDeliberacao
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        voto = VotoDeliberacao.objects.select_related(
            'deliberacao__sessao__comissao',
            'membro__militar',
            'membro__usuario'
        ).get(pk=pk)
    except VotoDeliberacao.DoesNotExist:
        messages.error(request, 'Voto nÃ£o encontrado.')
        return redirect('militares:meus_votos_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        f"{voto.deliberacao.sessao.comissao.nome.upper()} - CBMEPI-PI",
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    titulo = '<u>VOTO PROFERIDO EM DELIBERAÃ‡ÃƒO DE COMISSÃƒO</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # InformaÃ§Ãµes do voto (alinhadas Ã  esquerda)
    info_data = [
        [Paragraph('<b>DeliberaÃ§Ã£o:</b>', style_bold), Paragraph(f"{voto.deliberacao.numero} - {voto.deliberacao.assunto}", styles['Normal'])],
        [Paragraph('<b>ComissÃ£o:</b>', style_bold), Paragraph(voto.deliberacao.sessao.comissao.nome, styles['Normal'])],
        [Paragraph('<b>Data da SessÃ£o:</b>', style_bold), Paragraph(voto.deliberacao.sessao.data_sessao.strftime('%d/%m/%Y'), styles['Normal'])],
        [Paragraph('<b>Membro:</b>', style_bold), Paragraph(voto.membro.militar.nome_completo, styles['Normal'])],
        [Paragraph('<b>FunÃ§Ã£o:</b>', style_bold), Paragraph(voto.membro.cargo.nome if hasattr(voto.membro, 'cargo') and voto.membro.cargo else 'Membro da ComissÃ£o', styles['Normal'])],
        [Paragraph('<b>OpÃ§Ã£o de Voto:</b>', style_bold), Paragraph(voto.get_voto_display(), styles['Normal'])],
    ]
    info_table = Table(info_data, colWidths=[4*cm, 11*cm], hAlign='LEFT')
    info_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'TOP'),
        ('ALIGN', (0, 0), (0, -1), 'LEFT'),
        ('ALIGN', (1, 0), (1, -1), 'LEFT'),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 4),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('LEFTPADDING', (0, 0), (-1, -1), 0),
        ('RIGHTPADDING', (0, 0), (-1, -1), 0),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))

    # Voto proferido (espaÃ§amento 1,15 e justificado)
    if voto.voto_proferido:
        story.append(Paragraph('<b>Voto Proferido:</b>', style_bold))
        story.append(Spacer(1, 4))
        # Criar estilo com espaÃ§amento 1,15 e justificado
        style_voto = ParagraphStyle('voto', parent=styles['Normal'], leading=15, alignment=4)
        story.append(Paragraph(voto.voto_proferido, style_voto))
        story.append(Spacer(1, 20))

    # Assinatura EletrÃ´nica (padrÃ£o dos quadros)
    if voto.assinado and voto.data_assinatura:
        # InformaÃ§Ãµes de assinatura eletrÃ´nica
        nome_assinante = voto.membro.militar.nome_completo
        
        # Se o usuÃ¡rio tem militar associado, incluir posto com BM
        if hasattr(voto.membro.militar, 'get_posto_graduacao_display'):
            posto = voto.membro.militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_assinante = f"{posto} {voto.membro.militar.nome_completo}"
        
        # FunÃ§Ã£o da assinatura
        funcao = voto.funcao_assinatura or voto.membro.cargo.nome if hasattr(voto.membro, 'cargo') and voto.membro.cargo else "Membro da ComissÃ£o"
        
        # Data e hora da assinatura
        from django.utils import timezone
        agora = timezone.localtime(voto.data_assinatura)
        data_formatada = agora.strftime('%d/%m/%Y')
        hora_formatada = agora.strftime('%H:%M')
        
        texto_assinatura = f"Documento assinado eletronicamente por {nome_assinante} - {funcao}, em {data_formatada}, Ã s {hora_formatada}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
        
        # Adicionar logo do CBMEPI
        logo_path = os.path.join(settings.STATIC_ROOT, 'logo_cbmepi.png')
        if not os.path.exists(logo_path):
            logo_path = os.path.join(settings.STATICFILES_DIRS[0], 'logo_cbmepi.png') if settings.STATICFILES_DIRS else os.path.join(settings.BASE_DIR, 'static', 'logo_cbmepi.png')
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        story.append(Spacer(1, 20))

    # RodapÃ© com QR Code (padrÃ£o dos quadros)
    # Gerar URL de autenticaÃ§Ã£o
    from django.urls import reverse
    from django.contrib.sites.shortcuts import get_current_site
    
    current_site = get_current_site(request)
    protocol = 'https' if request.is_secure() else 'http'
    url_autenticacao = f"{protocol}://{current_site.domain}{reverse('militares:voto_visualizar_assinar', kwargs={'pk': voto.pk})}"
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a funÃ§Ã£o utilitÃ¡ria para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(voto, request, tipo_documento='voto')
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)

    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualizaÃ§Ã£o em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'voto_deliberacao_{voto.pk}.pdf')
from django.shortcuts import get_object_or_404, render, redirect
from django.utils import timezone
from django.contrib.auth.decorators import login_required

@login_required
def voto_visualizar_assinar(request, pk):
    from .models import VotoDeliberacao, UsuarioFuncao
    voto = get_object_or_404(VotoDeliberacao, pk=pk, membro__usuario=request.user)
    
    # Buscar funÃ§Ãµes ativas do usuÃ¡rio
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).select_related('cargo_funcao').order_by('cargo_funcao__nome')
    
    # FunÃ§Ã£o atual selecionada (da sessÃ£o ou primeira disponÃ­vel)
    funcao_atual = request.session.get('funcao_atual_nome', )
    if not funcao_atual and funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    context = {
        'voto': voto,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
    }
    
    return render(request, 'militares/comissao/deliberacoes/voto_visualizar_assinar.html', context)

@login_required
def assinar_voto(request, pk):
    from .models import VotoDeliberacao
    from django.contrib.auth import authenticate
    from django.contrib import messages
    
    voto = get_object_or_404(VotoDeliberacao, pk=pk, membro__usuario=request.user)
    
    if request.method == "POST" and not voto.assinado:
        # Validar senha
        senha = request.POST.get('senha')
        if not authenticate(username=request.user.username, password=senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            return redirect('militares:voto_visualizar_assinar', pk=pk)
        
        # Capturar funÃ§Ã£o da assinatura
        funcao_assinatura = request.POST.get('funcao_assinatura')
        tipo_assinatura = request.POST.get('tipo_assinatura', 'VOTO')
        observacoes = request.POST.get('observacoes', '')
        
        # Salvar assinatura
        voto.assinado = True
        voto.data_assinatura = timezone.now()
        voto.funcao_assinatura = funcao_assinatura
        voto.tipo_assinatura = tipo_assinatura
        voto.observacoes_assinatura = observacoes
        voto.save()
        
        messages.success(request, 'Voto assinado eletronicamente com sucesso!')
    
    return redirect('militares:voto_visualizar_assinar', pk=pk)

@login_required
def verificar_autenticidade(request):
    """
    View para verificar a autenticidade de documentos
    """
    resultado = None
    documento = None
    erro = None
    
    if request.method == 'POST':
        codigo_verificador = request.POST.get('codigo_verificador', '').strip()
        codigo_crc = request.POST.get('codigo_crc', '').strip()
        tipo_documento = request.POST.get('tipo_documento', '')
        
        if codigo_verificador and codigo_crc:
            try:
                # Extrair o ID do cÃ³digo verificador (primeiros 8 dÃ­gitos)
                if len(codigo_verificador) >= 8:
                    documento_id = int(codigo_verificador[:8])
                    
                    # Verificar o cÃ³digo CRC
                    codigo_crc_esperado = f"{hash(str(documento_id)) % 0xFFFFFFF:07X}"
                    
                    if codigo_crc.upper() == codigo_crc_esperado:
                        # Buscar o documento baseado no tipo
                        if tipo_documento == 'quadro':
                            documento = get_object_or_404(QuadroAcesso, pk=documento_id)
                            resultado = {
                                'tipo': 'Quadro de Acesso',
                                'titulo': f'Quadro de Acesso - {documento.get_tipo_display()}',
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'ata':
                            documento = get_object_or_404(AtaSessao, pk=documento_id)
                            resultado = {
                                'tipo': 'Ata de SessÃ£o',
                                'titulo': f'Ata da SessÃ£o {documento.sessao.numero}',
                                'data_criacao': documento.sessao.data_sessao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'voto':
                            documento = get_object_or_404(VotoDeliberacao, pk=documento_id)
                            resultado = {
                                'tipo': 'Voto de DeliberaÃ§Ã£o',
                                'titulo': f'Voto de {documento.membro.militar.nome_completo}',
                                'data_criacao': documento.data_registro,
                                'assinaturas': 1 if documento.assinado else 0
                            }
                        elif tipo_documento == 'quadro_fixacao':
                            documento = get_object_or_404(QuadroFixacaoVagas, pk=documento_id)
                            resultado = {
                                'tipo': 'Quadro de FixaÃ§Ã£o de Vagas',
                                'titulo': f'Quadro de FixaÃ§Ã£o - {documento.get_tipo_display()}',
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        elif tipo_documento == 'calendario_promocao':
                            documento = get_object_or_404(CalendarioPromocao, pk=documento_id)
                            resultado = {
                                'tipo': 'CalendÃ¡rio de PromoÃ§Ã£o',
                                'titulo': documento.get_titulo_completo(),
                                'data_criacao': documento.data_criacao,
                                'assinaturas': documento.assinaturas.count()
                            }
                        else:
                            erro = "Tipo de documento nÃ£o reconhecido."
                    else:
                        erro = "CÃ³digo CRC invÃ¡lido. Verifique os cÃ³digos informados."
                else:
                    erro = "CÃ³digo verificador invÃ¡lido. Deve ter pelo menos 8 dÃ­gitos."
                    
            except (ValueError, TypeError):
                erro = "CÃ³digo verificador invÃ¡lido. Deve conter apenas nÃºmeros."
            except QuadroAcesso.DoesNotExist:
                erro = "Quadro de Acesso nÃ£o encontrado com o cÃ³digo informado."
            except AtaSessao.DoesNotExist:
                erro = "Ata de SessÃ£o nÃ£o encontrada com o cÃ³digo informado."
            except VotoDeliberacao.DoesNotExist:
                erro = "Voto de DeliberaÃ§Ã£o nÃ£o encontrado com o cÃ³digo informado."
            except QuadroFixacaoVagas.DoesNotExist:
                erro = "Quadro de FixaÃ§Ã£o de Vagas nÃ£o encontrado com o cÃ³digo informado."
            except CalendarioPromocao.DoesNotExist:
                erro = "CalendÃ¡rio de PromoÃ§Ã£o nÃ£o encontrado com o cÃ³digo informado."
            except Exception as e:
                erro = f"Erro interno do sistema. Tente novamente ou entre em contato com o suporte."
        else:
            erro = "Por favor, informe ambos os cÃ³digos."
    
    context = {
        'resultado': resultado,
        'documento': documento,
        'erro': erro,
        'tipos_documento': [
            ('quadro', 'Quadro de Acesso'),
            ('ata', 'Ata de SessÃ£o'),
            ('voto', 'Voto de DeliberaÃ§Ã£o'),
            ('quadro_fixacao', 'Quadro de FixaÃ§Ã£o de Vagas'),
            ('calendario_promocao', 'CalendÃ¡rio de PromoÃ§Ã£o'),
        ]
    }
    
    return render(request, 'militares/verificar_autenticidade.html', context)

# Views para CalendÃ¡rios de PromoÃ§Ãµes
@login_required
def calendario_promocao_list(request):
    """Lista todos os calendÃ¡rios de promoÃ§Ãµes"""
    # Verificar se usuÃ¡rio tem permissÃ£o para CRUD completo
    from .decorators import usuario_comissao_required, usuario_cpo_required, usuario_cpp_required, apenas_visualizacao_comissao, administracao_required, militar_edit_permission, comissao_acesso_total, cargos_especiais_required, can_edit_ficha_conceito
    from functools import wraps
    
    def has_crud_permission(user):
        cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes']
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=cargos_especiais
        )
        return user.is_superuser or user.is_staff or funcoes_especiais.exists()
    
    calendarios = CalendarioPromocao.objects.all().order_by('-ano', '-semestre')
    
    context = {
        'calendarios': calendarios,
        'title': 'CalendÃ¡rios de PromoÃ§Ãµes',
        'can_edit': has_crud_permission(request.user),
    }
    return render(request, 'militares/calendario_promocao/list.html', context)

@login_required
def calendario_promocao_detail(request, pk):
    """Exibe detalhes de um calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Verificar se usuÃ¡rio tem permissÃ£o para CRUD completo
    def has_crud_permission(user):
        cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes']
        funcoes_especiais = UsuarioFuncao.objects.filter(
            usuario=user,
            status='ATIVO',
            cargo_funcao__nome__in=cargos_especiais
        )
        return user.is_superuser or user.is_staff or funcoes_especiais.exists()
    
    itens = calendario.itens.all().order_by('ordem')
    
    context = {
        'calendario': calendario,
        'itens': itens,
        'title': f'CalendÃ¡rio {calendario.periodo_completo}',
        'can_edit': has_crud_permission(request.user),
        'active_menu': 'calendario_promocao',
    }
    return render(request, 'militares/calendario_promocao/detail.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_create(request):
    """Cria um novo calendÃ¡rio de promoÃ§Ã£o"""
    if request.method == 'POST':
        ano = request.POST.get('ano')
        semestre = request.POST.get('semestre')
        tipo = request.POST.get('tipo')
        observacoes = request.POST.get('observacoes', '')
        
        if ano and semestre and tipo:
            # Verificar se jÃ¡ existe um calendÃ¡rio para este ano/semestre/tipo
            if CalendarioPromocao.objects.filter(ano=ano, semestre=semestre, tipo=tipo).exists():
                messages.error(request, f'JÃ¡ existe um calendÃ¡rio para {semestre}Âº semestre de {ano} - {dict(CalendarioPromocao.TIPO_CHOICES)[tipo]}.')
                return redirect('militares:calendario_promocao_create')
            
            calendario = CalendarioPromocao.objects.create(
                ano=ano,
                semestre=semestre,
                tipo=tipo,
                observacoes=observacoes
            )
            
            messages.success(request, f'CalendÃ¡rio {calendario.periodo_completo} criado com sucesso!')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        else:
            messages.error(request, 'Ano, semestre e tipo sÃ£o obrigatÃ³rios.')
    
    context = {
        'title': 'Criar CalendÃ¡rio de PromoÃ§Ã£o',
        'anos': [(str(year), str(year)) for year in range(2020, 2031)],
        'semestres': [('1', '1Âº Semestre'), ('2', '2Âº Semestre')],
        'tipos': CalendarioPromocao.TIPO_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/create.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_update(request, pk):
    """Atualiza um calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        ano = request.POST.get('ano')
        semestre = request.POST.get('semestre')
        tipo = request.POST.get('tipo')
        observacoes = request.POST.get('observacoes', '')
        ativo = request.POST.get('ativo') == 'on'
        
        if ano and semestre and tipo:
            # Verificar se jÃ¡ existe outro calendÃ¡rio para este ano/semestre/tipo
            if CalendarioPromocao.objects.filter(ano=ano, semestre=semestre, tipo=tipo).exclude(pk=calendario.pk).exists():
                messages.error(request, f'JÃ¡ existe um calendÃ¡rio para {semestre}Âº semestre de {ano} - {dict(CalendarioPromocao.TIPO_CHOICES)[tipo]}.')
                return redirect('militares:calendario_promocao_update', pk=pk)
            
            calendario.ano = ano
            calendario.semestre = semestre
            calendario.tipo = tipo
            calendario.observacoes = observacoes
            calendario.ativo = ativo
            calendario.save()
            
            messages.success(request, f'CalendÃ¡rio {calendario.periodo_completo} atualizado com sucesso!')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        else:
            messages.error(request, 'Ano, semestre e tipo sÃ£o obrigatÃ³rios.')
    
    context = {
        'calendario': calendario,
        'title': f'Editar CalendÃ¡rio {calendario.periodo_completo}',
        'anos': [(str(year), str(year)) for year in range(2020, 2031)],
        'semestres': [('1', '1Âº Semestre'), ('2', '2Âº Semestre')],
        'tipos': CalendarioPromocao.TIPO_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/update.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_delete(request, pk):
    """Exclui um calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if not calendario.pode_ser_excluido():
            messages.error(request, f'CalendÃ¡rio {calendario.numero} nÃ£o pode ser excluÃ­do pois estÃ¡ {calendario.get_status_display()}.')
            return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
        
        nome_calendario = calendario.numero or calendario.periodo_completo
        calendario.delete()
        messages.success(request, f'CalendÃ¡rio {nome_calendario} excluÃ­do com sucesso!')
        return redirect('militares:calendario_promocao_list')
    
    context = {
        'calendario': calendario,
        'title': f'Excluir CalendÃ¡rio {calendario.numero or calendario.periodo_completo}',
        'pode_excluir': calendario.pode_ser_excluido(),
    }
    return render(request, 'militares/calendario_promocao/delete.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_aprovar(request, pk):
    """Aprova um calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if calendario.status in ['RASCUNHO', 'EM_ELABORACAO']:
            calendario.aprovar(request.user)
            messages.success(request, f'CalendÃ¡rio {calendario.numero} aprovado com sucesso!')
        else:
            messages.error(request, f'CalendÃ¡rio {calendario.numero} nÃ£o pode ser aprovado no status atual.')
        
        return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'title': f'Aprovar CalendÃ¡rio {calendario.numero or calendario.periodo_completo}',
        'pode_aprovar': calendario.status in ['RASCUNHO', 'EM_ELABORACAO'],
    }
    return render(request, 'militares/calendario_promocao/aprovar.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_homologar(request, pk):
    """Homologa um calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        if calendario.status == 'APROVADO':
            calendario.homologar(request.user)
            messages.success(request, f'CalendÃ¡rio {calendario.numero} homologado com sucesso!')
        else:
            messages.error(request, f'CalendÃ¡rio {calendario.numero} nÃ£o pode ser homologado no status atual.')
        
        return redirect('militares:calendario_promocao_detail', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'title': f'Homologar CalendÃ¡rio {calendario.numero or calendario.periodo_completo}',
        'pode_homologar': calendario.status == 'APROVADO',
    }
    return render(request, 'militares/calendario_promocao/homologar.html', context)

@login_required
@cargos_especiais_required
def item_calendario_create(request, calendario_pk):
    """Adiciona um item ao calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=calendario_pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        tipo_atividade = request.POST.get('tipo_atividade')
        data_inicio = request.POST.get('data_inicio')
        data_fim = request.POST.get('data_fim')
        ordem = request.POST.get('ordem', 0)
        observacoes = request.POST.get('observacoes', '')
        
        if tipo_atividade and data_inicio and data_fim:
            try:
                data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
                data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
                
                # Verificar se jÃ¡ existe um item deste tipo no calendÃ¡rio
                if ItemCalendarioPromocao.objects.filter(calendario=calendario, tipo_atividade=tipo_atividade).exists():
                    messages.error(request, 'JÃ¡ existe um item deste tipo no calendÃ¡rio.')
                    return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
                
                # Criar o item sem ordem (serÃ¡ definida automaticamente no save)
                item = ItemCalendarioPromocao.objects.create(
                    calendario=calendario,
                    tipo_atividade=tipo_atividade,
                    data_inicio=data_inicio,
                    data_fim=data_fim,
                    ordem=0,  # SerÃ¡ definida automaticamente no save
                    observacoes=observacoes
                )
                
                # Reordenar todos os itens do calendÃ¡rio
                ItemCalendarioPromocao.reordenar_itens_calendario(calendario)
                
                messages.success(request, f'Item "{item.get_tipo_atividade_display()}" adicionado com sucesso!')
                return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
                
            except ValueError:
                messages.error(request, 'Data invÃ¡lida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Tipo de atividade e datas sÃ£o obrigatÃ³rios.')
    
    # Determinar o prÃ³ximo item a ser adicionado
    itens_existentes = calendario.itens.values_list('tipo_atividade', flat=True)
    proximo_item = None
    
    # Buscar o prÃ³ximo item na ordem padrÃ£o que ainda nÃ£o foi adicionado
    for tipo_atividade, ordem in sorted(ItemCalendarioPromocao.ORDEM_PADRAO.items(), key=lambda x: x[1]):
        if tipo_atividade not in itens_existentes:
            proximo_item = tipo_atividade
            break
    
    # Se nÃ£o hÃ¡ prÃ³ximo item, usar o primeiro da lista
    if not proximo_item:
        proximo_item = ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES[0][0]
    
    # Criar lista de tipos de atividade com ordem
    tipos_com_ordem = []
    for tipo_valor, tipo_label in ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES:
        ordem = ItemCalendarioPromocao.ORDEM_PADRAO.get(tipo_valor, 999)
        tipos_com_ordem.append({
            'valor': tipo_valor,
            'label': tipo_label,
            'ordem': ordem,
            'display': f"{ordem}. {tipo_label}"
        })
    
    # Ordenar por ordem
    tipos_com_ordem.sort(key=lambda x: x['ordem'])
    
    context = {
        'calendario': calendario,
        'title': f'Adicionar Item ao CalendÃ¡rio {calendario.periodo_completo}',
        'tipos_atividade': tipos_com_ordem,
        'proximo_item': proximo_item,
        'ordem_proximo_item': ItemCalendarioPromocao.ORDEM_PADRAO.get(proximo_item, 999),
    }
    return render(request, 'militares/calendario_promocao/item_create.html', context)

@login_required
@cargos_especiais_required
def item_calendario_update(request, pk):
    """Atualiza um item do calendÃ¡rio de promoÃ§Ã£o"""
    try:
        item = ItemCalendarioPromocao.objects.get(pk=pk)
    except ItemCalendarioPromocao.DoesNotExist:
        messages.error(request, 'Item do calendÃ¡rio nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        tipo_atividade = request.POST.get('tipo_atividade')
        data_inicio = request.POST.get('data_inicio')
        data_fim = request.POST.get('data_fim')
        ordem = request.POST.get('ordem', 0)
        observacoes = request.POST.get('observacoes', '')
        
        if tipo_atividade and data_inicio and data_fim:
            try:
                data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
                data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
                
                # Verificar se jÃ¡ existe outro item deste tipo no calendÃ¡rio
                if ItemCalendarioPromocao.objects.filter(
                    calendario=item.calendario, 
                    tipo_atividade=tipo_atividade
                ).exclude(pk=item.pk).exists():
                    messages.error(request, 'JÃ¡ existe um item deste tipo no calendÃ¡rio.')
                    return redirect('militares:calendario_promocao_detail', pk=item.calendario.pk)
                
                item.tipo_atividade = tipo_atividade
                item.data_inicio = data_inicio
                item.data_fim = data_fim
                item.ordem = 0  # SerÃ¡ definida automaticamente no save
                item.observacoes = observacoes
                item.save()
                
                # Reordenar todos os itens do calendÃ¡rio
                ItemCalendarioPromocao.reordenar_itens_calendario(item.calendario)
                
                messages.success(request, f'Item "{item.get_tipo_atividade_display()}" atualizado com sucesso!')
                return redirect('militares:calendario_promocao_detail', pk=item.calendario.pk)
                
            except ValueError:
                messages.error(request, 'Data invÃ¡lida. Use o formato DD/MM/AAAA.')
        else:
            messages.error(request, 'Tipo de atividade e datas sÃ£o obrigatÃ³rios.')
    
    context = {
        'item': item,
        'calendario': item.calendario,
        'title': f'Editar Item do CalendÃ¡rio {item.calendario.periodo_completo}',
        'tipos_atividade': ItemCalendarioPromocao.TIPO_ATIVIDADE_CHOICES,
    }
    return render(request, 'militares/calendario_promocao/item_update.html', context)

@login_required
def calendario_promocao_visualizar_assinatura(request, pk):
    """VisualizaÃ§Ã£o do calendÃ¡rio de promoÃ§Ã£o com opÃ§Ãµes de assinatura"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Buscar itens do calendÃ¡rio ordenados por ordem
    itens = calendario.itens.all().order_by('ordem')
    
    # Buscar assinaturas eletrÃ´nicas
    assinaturas = calendario.assinaturas.all().order_by('data_assinatura')
    
    # Verificar permissÃµes de assinatura
    can_sign = False
    
    # Verificar se nÃ£o Ã© o usuÃ¡rio "usuario"
    if request.user.username == 'usuario':
        can_sign = False
    else:
        # Verificar se o usuÃ¡rio tem funÃ§Ãµes especÃ­ficas
        funcoes_especificas = [
            'Presidente', 'Diretor', 'Chefe', 'Comandante', 'SecretÃ¡rio', 
            'Coordenador', 'Supervisor', 'Gerente', 'Assessor', 'Consultor',
            'Membro de ComissÃ£o', 'Membro Efetivo', 'Membro Nato'
        ]
        
        # Verificar se tem funÃ§Ãµes ativas
        funcoes_ativas = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO',
            data_fim__isnull=True
        )
        
        # Verificar se Ã© membro de comissÃ£o ativa
        membro_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            data_termino__isnull=True
        ).exists()
        
        # Verificar se tem funÃ§Ãµes especÃ­ficas ou Ã© membro de comissÃ£o
        tem_funcao_especifica = False
        for funcao in funcoes_ativas:
            if any(nome in funcao.cargo_funcao.nome for nome in funcoes_especificas):
                tem_funcao_especifica = True
                break
        
        if tem_funcao_especifica or membro_comissao or request.user.is_superuser or request.user.is_staff:
            can_sign = True
    
    # Buscar funÃ§Ãµes do usuÃ¡rio para assinatura
    funcoes_usuario = []
    funcao_atual = None
    funcoes_adicionadas = set()  # Para evitar duplicatas
    
    if request.user.is_authenticated and request.user.username != 'usuario':
        print(f"DEBUG: Verificando funÃ§Ãµes para usuÃ¡rio: {request.user.username}")
        
        # Buscar TODAS as comissÃµes ativas (nÃ£o apenas do tipo do calendÃ¡rio)
        comissoes_ativas = ComissaoPromocao.objects.filter(status='ATIVA')
        
        # Adicionar funÃ§Ãµes de comissÃ£o
        for comissao in comissoes_ativas:
            membros_comissao = comissao.membros.filter(usuario=request.user)
            for membro in membros_comissao:
                nome_funcao = membro.cargo.nome
                if nome_funcao not in funcoes_adicionadas:
                    funcoes_usuario.append({
                        'tipo': 'comissao',
                        'objeto': membro,
                        'nome': nome_funcao,
                        'descricao': f"{nome_funcao} ({comissao.get_tipo_display()})"
                    })
                    funcoes_adicionadas.add(nome_funcao)
        
        # Buscar TODAS as funÃ§Ãµes especÃ­ficas do usuÃ¡rio (sem filtrar)
        funcoes_especificas = UsuarioFuncao.objects.filter(
            usuario=request.user,
            status='ATIVO',
            data_fim__isnull=True
        )
        
        print(f"DEBUG: FunÃ§Ãµes especÃ­ficas encontradas: {funcoes_especificas.count()}")
        
        # Adicionar TODAS as funÃ§Ãµes especÃ­ficas do usuÃ¡rio (sem filtrar)
        for funcao in funcoes_especificas:
            nome_funcao = funcao.cargo_funcao.nome
            if nome_funcao not in funcoes_adicionadas:
                print(f"DEBUG: Adicionando funÃ§Ã£o especÃ­fica: {nome_funcao}")
                funcoes_usuario.append({
                    'tipo': 'especifica',
                    'objeto': funcao,
                    'nome': nome_funcao,
                    'descricao': f"{nome_funcao} (FunÃ§Ã£o EspecÃ­fica)"
                })
                funcoes_adicionadas.add(nome_funcao)
        
        # Definir funÃ§Ã£o atual (primeira da lista)
        if funcoes_usuario:
            funcao_atual = funcoes_usuario[0]['nome']
        
        # Debug: Log das funÃ§Ãµes encontradas
        print(f"DEBUG: Total de funÃ§Ãµes encontradas: {len(funcoes_usuario)}")
        for i, funcao in enumerate(funcoes_usuario):
            print(f"DEBUG: FunÃ§Ã£o {i+1}: {funcao['nome']} - {funcao['descricao']}")
        
        # Se nÃ£o encontrou nenhuma funÃ§Ã£o, permitir assinatura como usuÃ¡rio genÃ©rico
        if not funcoes_usuario and can_sign:
            funcoes_usuario.append({
                'tipo': 'generico',
                'objeto': None,
                'nome': 'UsuÃ¡rio Autorizado',
                'descricao': 'UsuÃ¡rio Autorizado (FunÃ§Ã£o GenÃ©rica)'
            })
            funcao_atual = 'UsuÃ¡rio Autorizado'
    
    context = {
        'calendario': calendario,
        'itens': itens,
        'assinaturas': assinaturas,
        'can_sign': can_sign,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
        'title': f'Visualizar CalendÃ¡rio {calendario.numero}',
    }
    return render(request, 'militares/calendario_promocao/visualizar_assinatura.html', context)

@login_required
@cargos_especiais_required
def calendario_promocao_assinar(request, pk):
    """Assinar calendÃ¡rio de promoÃ§Ã£o"""
    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, 'CalendÃ¡rio de promoÃ§Ã£o nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    # Verificar permissÃµes de assinatura
    if request.user.username == 'usuario':
        messages.error(request, 'O usuÃ¡rio "usuario" nÃ£o tem permissÃ£o para assinar calendÃ¡rios.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    # Verificar se o usuÃ¡rio tem funÃ§Ãµes especÃ­ficas
    funcoes_especificas = [
        'Presidente', 'Diretor', 'Chefe', 'Comandante', 'SecretÃ¡rio', 
        'Coordenador', 'Supervisor', 'Gerente', 'Assessor', 'Consultor',
        'Membro de ComissÃ£o', 'Membro Efetivo', 'Membro Nato'
    ]
    
    # Verificar se tem funÃ§Ãµes ativas
    funcoes_ativas = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO',
        data_fim__isnull=True
    )
    
    # Verificar se Ã© membro de comissÃ£o ativa
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        data_termino__isnull=True
    ).exists()
    
    # Verificar se tem funÃ§Ãµes especÃ­ficas ou Ã© membro de comissÃ£o
    tem_funcao_especifica = False
    for funcao in funcoes_ativas:
        if any(nome in funcao.cargo_funcao.nome for nome in funcoes_especificas):
            tem_funcao_especifica = True
            break
    
    if not (tem_funcao_especifica or membro_comissao or request.user.is_superuser or request.user.is_staff):
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para assinar calendÃ¡rios. Ã‰ necessÃ¡rio ter funÃ§Ãµes especÃ­ficas ou ser membro de comissÃ£o.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    if request.method == 'POST':
        tipo_assinatura = request.POST.get('tipo_assinatura')
        funcao_assinatura = request.POST.get('funcao_assinatura', '')
        observacoes = request.POST.get('observacoes', '')
        senha = request.POST.get('senha')
        
        if not senha:
            messages.error(request, 'Senha Ã© obrigatÃ³ria para confirmar a assinatura.')
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta.')
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
        
        # Criar assinatura
        try:
            assinatura = AssinaturaCalendarioPromocao.objects.create(
                calendario=calendario,
                tipo_assinatura=tipo_assinatura,
                funcao_assinatura=funcao_assinatura,
                assinado_por=request.user,
                observacoes=observacoes
            )
            messages.success(request, f'CalendÃ¡rio {calendario.numero} assinado com sucesso!')
        except Exception as e:
            messages.error(request, f'Erro ao assinar calendÃ¡rio: {str(e)}')
        
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=pk)
    
    context = {
        'calendario': calendario,
        'title': f'Assinar CalendÃ¡rio {calendario.numero}',
    }
    return render(request, 'militares/calendario_promocao/assinar.html', context)

@login_required
def retirar_assinatura_calendario(request, pk, assinatura_pk):
    """Retirar assinatura do calendÃ¡rio de promoÃ§Ã£o - apenas antes da homologaÃ§Ã£o"""
    calendario = get_object_or_404(CalendarioPromocao, pk=pk)
    assinatura = get_object_or_404(AssinaturaCalendarioPromocao, pk=assinatura_pk, calendario=calendario)
    
    # Verificar se o calendÃ¡rio jÃ¡ foi homologado
    if calendario.status == 'HOMOLOGADO':
        messages.error(request, 'NÃ£o Ã© possÃ­vel retirar assinaturas de um calendÃ¡rio jÃ¡ homologado.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    # Verificar se o usuÃ¡rio Ã© o autor da assinatura ou tem permissÃ£o administrativa
    if assinatura.assinado_por != request.user and not request.user.is_superuser and not request.user.is_staff:
        messages.error(request, 'VocÃª sÃ³ pode retirar suas prÃ³prias assinaturas.')
        return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    if request.method == 'POST':
        senha = request.POST.get('senha')
        
        # Verificar senha do usuÃ¡rio
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Tente novamente.')
            context = {
                'calendario': calendario,
                'assinatura': assinatura,
            }
            return render(request, 'militares/retirar_assinatura_calendario.html', context)
        
        # Verificar se a assinatura Ã© de aprovaÃ§Ã£o e se hÃ¡ outras assinaturas de aprovaÃ§Ã£o
        if assinatura.tipo_assinatura == 'APROVACAO':
            outras_aprovacoes = calendario.assinaturas.filter(
                tipo_assinatura='APROVACAO'
            ).exclude(pk=assinatura.pk).count()
            
            if outras_aprovacoes == 0:
                # Se nÃ£o hÃ¡ outras aprovaÃ§Ãµes, voltar o status do calendÃ¡rio para EM_ELABORACAO
                calendario.status = 'EM_ELABORACAO'
                calendario.save()
        
        # Excluir a assinatura
        assinatura.delete()
        
        messages.success(request, f'Assinatura de "{assinatura.get_tipo_assinatura_display()}" retirada com sucesso!')
        
        # Redirecionar de volta para a pÃ¡gina de onde veio
        next_url = request.GET.get('next')
        if next_url:
            return redirect(next_url)
        else:
            return redirect('militares:calendario_promocao_visualizar_assinatura', pk=calendario.pk)
    
    context = {
        'calendario': calendario,
        'assinatura': assinatura,
    }
    
    return render(request, 'militares/retirar_assinatura_calendario.html', context)

@login_required
def calendario_promocao_gerar_pdf(request, pk):
    """Gera PDF do calendÃ¡rio de promoÃ§Ã£o no modelo institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    try:
        calendario = CalendarioPromocao.objects.get(pk=pk)
    except CalendarioPromocao.DoesNotExist:
        messages.error(request, f'CalendÃ¡rio de promoÃ§Ã£o com ID {pk} nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "DIRETORIA DE GESTÃƒO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    titulo_completo = calendario.get_titulo_completo()
    titulo = f'<u>{titulo_completo}</u>'
    story.append(Paragraph(titulo, style_title))
    story.append(Spacer(1, 16))

    # InformaÃ§Ãµes do calendÃ¡rio
    info_data = [
        ['PerÃ­odo:', f"{calendario.get_semestre_display()} {calendario.ano}"],
        ['Tipo:', calendario.get_tipo_display()],
        ['Status:', calendario.get_status_display()],
        ['Data de CriaÃ§Ã£o:', calendario.data_criacao.strftime('%d/%m/%Y %H:%M')],
    ]
    
    if calendario.data_aprovacao:
        info_data.append(['Aprovado em:', calendario.data_aprovacao.strftime('%d/%m/%Y %H:%M')])
        info_data.append(['Aprovado por:', calendario.aprovado_por.get_full_name()])
    
    if calendario.data_homologacao:
        info_data.append(['Homologado em:', calendario.data_homologacao.strftime('%d/%m/%Y %H:%M')])
        info_data.append(['Homologado por:', calendario.homologado_por.get_full_name()])

    info_table = Table(info_data, colWidths=[4*cm, 10*cm])
    info_table.setStyle(TableStyle([
        ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f8f9fa')),
        ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
        ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 0), (-1, -1), 10),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
    ]))
    story.append(info_table)
    story.append(Spacer(1, 20))

    # Itens do calendÃ¡rio
    if calendario.itens.exists():
        story.append(Paragraph("ITENS DO CALENDÃRIO", style_subtitle))
        story.append(Spacer(1, 10))
        
        # CabeÃ§alho da tabela
        header_data = [['Ordem', 'Atividade', 'PerÃ­odo']]
        
        # Dados dos itens
        for item in calendario.itens.all().order_by('ordem'):
            header_data.append([
                str(item.ordem),
                item.get_tipo_atividade_display(),
                item.periodo_formatado
            ])
        
        items_table = Table(header_data, colWidths=[1.5*cm, 10*cm, 4*cm])
        items_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 9),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ]))
        story.append(items_table)
        story.append(Spacer(1, 20))

    # Data e local
    data_atual = datetime.now()
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    data_formatada = f"{data_atual.day} de {meses_pt[data_atual.month]} de {data_atual.year}"
    data_extenso = f"Teresina, {data_formatada}"
    story.append(Spacer(1, 20))
    story.append(Paragraph(data_extenso, style_center))
    
    # SeÃ§Ã£o de Assinaturas FÃ­sicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))

    # Buscar todas as assinaturas vÃ¡lidas do calendÃ¡rio (da mais recente para a mais antiga)
    assinaturas = calendario.assinaturas.filter(assinado_por__isnull=False).order_by('-data_assinatura')
    
    for assinatura in assinaturas:
        # Nome e posto
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{militar.nome_completo} - {posto}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        # Exibir no formato fÃ­sico: Nome - Posto BM (negrito), FunÃ§Ã£o (normal)
        story.append(Spacer(1, 13))
        story.append(Paragraph(f"<b>{nome_completo}</b>", style_center))
        story.append(Paragraph(f"{funcao}", style_center))
        story.append(Spacer(1, 13))

    # Se nÃ£o houver assinaturas, mostrar mensagem
    if not assinaturas.exists():
        story.append(Paragraph("Nenhuma assinatura registrada", style_center))

    # SeÃ§Ã£o de Assinaturas EletrÃ´nicas (sem tÃ­tulo)
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
    story.append(Spacer(1, 13))
    
    # Buscar todas as assinaturas para exibir na seÃ§Ã£o eletrÃ´nica
    assinaturas_eletronicas = calendario.assinaturas.filter(
        assinado_por__isnull=False
    ).order_by('-data_assinatura')
    
    for i, assinatura in enumerate(assinaturas_eletronicas):
        # Nome e posto - seguir o mesmo padrÃ£o dos quadros de acesso
        if hasattr(assinatura.assinado_por, 'militar') and assinatura.assinado_por.militar:
            militar = assinatura.assinado_por.militar
            posto = militar.get_posto_graduacao_display()
            # Adicionar BM apÃ³s o posto se nÃ£o jÃ¡ estiver presente
            if "BM" not in posto:
                posto = f"{posto} BM"
            nome_completo = f"{posto} {militar.nome_completo}"
        else:
            nome_completo = assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username
        
        # FunÃ§Ã£o
        funcao = assinatura.funcao_assinatura or "FunÃ§Ã£o nÃ£o registrada"
        
        # Data da assinatura
        from .utils import formatar_data_assinatura
        data_formatada, hora_formatada = formatar_data_assinatura(assinatura.data_assinatura)
        data_assinatura = f"{data_formatada} Ã s {hora_formatada}"
        
        # Texto da assinatura eletrÃ´nica no padrÃ£o solicitado
        texto_assinatura = f"Documento assinado eletronicamente por {nome_completo} - {funcao}, em {data_assinatura}, conforme horÃ¡rio oficial de BrasÃ­lia, conforme portaria comando geral nÂº59/2020 publicada em boletim geral nÂº26/2020"
        
        # Tabela das assinaturas: Logo + Texto de assinatura
        assinatura_data = [
            [Image(logo_path, width=1.5*cm, height=1.5*cm), Paragraph(texto_assinatura, style_small)]
        ]
        
        assinatura_table = Table(assinatura_data, colWidths=[2*cm, 14*cm])
        assinatura_table.setStyle(TableStyle([
            ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
            ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # Logo centralizado
            ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
            ('LEFTPADDING', (0, 0), (-1, -1), 2),
            ('RIGHTPADDING', (0, 0), (-1, -1), 2),
            ('TOPPADDING', (0, 0), (-1, -1), 2),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
        ]))
        
        story.append(assinatura_table)
        
        # Adicionar linha separadora entre assinaturas (exceto na Ãºltima)
        if i < len(assinaturas_eletronicas) - 1:
            story.append(Spacer(1, 13))
            story.append(HRFlowable(width="100%", thickness=0.5, spaceAfter=13, spaceBefore=13, color=colors.lightgrey))
            story.append(Spacer(1, 13))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Usar a funÃ§Ã£o utilitÃ¡ria para gerar o autenticador
    from .utils import gerar_autenticador_veracidade
    autenticador = gerar_autenticador_veracidade(calendario, request, tipo_documento='calendario_promocao')
    
    # Tabela do rodapÃ©: QR + Texto de autenticaÃ§Ã£o
    rodape_data = [
        [autenticador['qr_img'], Paragraph(autenticador['texto_autenticacao'], style_small)]
    ]
    
    rodape_table = Table(rodape_data, colWidths=[2*cm, 14*cm])
    rodape_table.setStyle(TableStyle([
        ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'),
        ('ALIGN', (0, 0), (0, 0), 'CENTER'),  # QR centralizado
        ('ALIGN', (1, 0), (1, 0), 'LEFT'),    # Texto alinhado Ã  esquerda
        ('LEFTPADDING', (0, 0), (-1, -1), 2),
        ('RIGHTPADDING', (0, 0), (-1, -1), 2),
        ('TOPPADDING', (0, 0), (-1, -1), 2),
        ('BOTTOMPADDING', (0, 0), (-1, -1), 2),
    ]))
    
    story.append(rodape_table)
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o PDF para visualizaÃ§Ã£o em nova guia
    buffer.seek(0)
    from django.http import FileResponse
    return FileResponse(buffer, content_type='application/pdf', filename=f'calendario_promocao_{calendario.pk}.pdf')

@login_required
@cargos_especiais_required
def item_calendario_delete(request, pk):
    """Exclui um item do calendÃ¡rio de promoÃ§Ã£o"""
    try:
        item = ItemCalendarioPromocao.objects.get(pk=pk)
    except ItemCalendarioPromocao.DoesNotExist:
        messages.error(request, 'Item do calendÃ¡rio nÃ£o encontrado.')
        return redirect('militares:calendario_promocao_list')
    
    if request.method == 'POST':
        nome_item = item.get_tipo_atividade_display()
        calendario_pk = item.calendario.pk
        item.delete()
        messages.success(request, f'Item "{nome_item}" excluÃ­do com sucesso!')
        return redirect('militares:calendario_promocao_detail', pk=calendario_pk)
    
    context = {
        'item': item,
        'calendario': item.calendario,
        'title': f'Excluir Item do CalendÃ¡rio {item.calendario.periodo_completo}',
    }
    return render(request, 'militares/calendario_promocao/item_delete.html', context)

@login_required
def calendario_promocao_visualizar(request):
    """VisualizaÃ§Ã£o pÃºblica dos calendÃ¡rios de promoÃ§Ãµes ativos"""
    calendarios_ativos = CalendarioPromocao.objects.filter(ativo=True).order_by('-ano', '-semestre')
    
    context = {
        'calendarios': calendarios_ativos,
        'title': 'CalendÃ¡rios de PromoÃ§Ãµes',
    }
    return render(request, 'militares/calendario_promocao/visualizar.html', context)
# Views para Almanaque
from django.core.files.base import ContentFile
from django.http import HttpResponse
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, PageBreak
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import cm, inch
from reportlab.lib import colors
from io import BytesIO

@login_required
def almanaque_militares(request):
    """Almanaque dos militares organizado por hierarquia"""
    
    # Definir ordem hierÃ¡rquica dos postos (do mais graduado ao menos graduado)
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos
    militares_ativos = Militar.objects.filter(situacao='AT').order_by('posto_graduacao', 'numeracao_antiguidade', 'nome_completo')
    
    # Separar oficiais, praÃ§as e NVRR
    oficiais = []
    pracas = []
    nvrr = []
    
    for militar in militares_ativos:
        if militar.is_nvrr():
            nvrr.append(militar)
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar oficiais por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por nÃºmero de antiguidade (menor primeiro) e depois por data de promoÃ§Ã£o
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    # Organizar praÃ§as por hierarquia
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por nÃºmero de antiguidade (menor primeiro) e depois por data de promoÃ§Ã£o
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Organizar NVRR separadamente
    nvrr_organizados = {}
    if nvrr:
        # Ordenar por data de promoÃ§Ã£o (mais antiga primeiro) e depois por nome
        nvrr.sort(key=lambda x: (x.data_promocao_atual, x.nome_completo))
        nvrr_organizados['NVRR'] = nvrr
    
    # Organizar todos os militares por hierarquia geral (incluindo NVRR)
    todos_organizados = {}
    ordem_geral = ordem_postos_oficiais + ordem_postos_pracas
    
    for posto in ordem_geral:
        militares_posto = [m for m in militares_ativos if m.posto_graduacao == posto]
        if militares_posto:
            # Ordenar por nÃºmero de antiguidade (menor primeiro) e depois por data de promoÃ§Ã£o
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            todos_organizados[posto] = militares_posto
    
    # Adicionar NVRR ao todos_organizados
    if nvrr:
        todos_organizados['NVRR'] = nvrr
        ordem_geral = ['NVRR'] + ordem_geral
    
    context = {
        'title': 'Almanaque dos Militares',
        'oficiais_organizados': oficiais_organizados,
        'pracas_organizadas': pracas_organizadas,
        'nvrr_organizados': nvrr_organizados,
        'todos_organizados': todos_organizados,
        'ordem_postos_oficiais': ordem_postos_oficiais,
        'ordem_postos_pracas': ordem_postos_pracas,
        'ordem_geral': ordem_geral,
        'total_oficiais': len(oficiais),
        'total_pracas': len(pracas),
        'total_nvrr': len(nvrr),
        'total_geral': len(militares_ativos),
        'POSTO_GRADUACAO_CHOICES': POSTO_GRADUACAO_CHOICES,
    }
    
    return render(request, 'militares/almanaque.html', context)

@login_required
def almanaque_list(request):
    """Lista todos os almanaques seguindo o padrÃ£o dos quadros de fixaÃ§Ã£o de vagas"""
    # PermissÃ£o especial para superusuÃ¡rios, staff e funÃ§Ãµes administrativas
    cargos_especiais = ['Diretor de GestÃ£o de Pessoas', 'Chefe da SeÃ§Ã£o de PromoÃ§Ãµes', 'Administrador do Sistema', 'Administrador']
    funcoes_ativas = request.user.funcoes.filter(
        cargo_funcao__nome__in=cargos_especiais,
        status='ATIVO',
    )
    
    # SuperusuÃ¡rios e staff podem ver todos os almanaques
    if request.user.is_superuser or request.user.is_staff or funcoes_ativas.exists():
        almanaques = AlmanaqueMilitar.objects.filter(ativo=True).order_by('-data_geracao')
    else:
        # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o e aplicar filtro
        membros_comissao = MembroComissao.objects.filter(
            usuario=request.user,
            ativo=True,
            comissao__status='ATIVA'
        )
        if membros_comissao.exists():
            tem_cpo = membros_comissao.filter(comissao__tipo='CPO').exists()
            tem_cpp = membros_comissao.filter(comissao__tipo='CPP').exists()
            if tem_cpo and tem_cpp:
                almanaques = AlmanaqueMilitar.objects.filter(ativo=True).order_by('-data_geracao')
            elif tem_cpo:
                almanaques = AlmanaqueMilitar.objects.filter(tipo='OFICIAIS', ativo=True).order_by('-data_geracao')
            elif tem_cpp:
                almanaques = AlmanaqueMilitar.objects.filter(tipo='PRACAS', ativo=True).order_by('-data_geracao')
            else:
                almanaques = AlmanaqueMilitar.objects.none()
        else:
            almanaques = AlmanaqueMilitar.objects.none()
    
    # Filtros
    data_inicio = request.GET.get('data_inicio')
    if data_inicio:
        try:
            from datetime import datetime
            data_inicio = datetime.strptime(data_inicio, '%Y-%m-%d').date()
            almanaques = almanaques.filter(data_geracao__date__gte=data_inicio)
        except ValueError:
            pass
    
    data_fim = request.GET.get('data_fim')
    if data_fim:
        try:
            from datetime import datetime
            data_fim = datetime.strptime(data_fim, '%Y-%m-%d').date()
            almanaques = almanaques.filter(data_geracao__date__lte=data_fim)
        except ValueError:
            pass
    
    # PaginaÃ§Ã£o
    paginator = Paginator(almanaques, 20)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    # EstatÃ­sticas
    total_almanaques = almanaques.count()
    
    # Verificar se o usuÃ¡rio Ã© membro de alguma comissÃ£o
    membro_comissao = MembroComissao.objects.filter(
        usuario=request.user,
        ativo=True,
        comissao__status='ATIVA'
    ).first()
    
    context = {
        'almanaques': page_obj,
        'total_almanaques': total_almanaques,
        'filtros': {
            'data_inicio': data_inicio,
            'data_fim': data_fim,
        },
        'membro_comissao': membro_comissao,
    }
    
    return render(request, 'militares/almanaque/list.html', context)

@login_required
def almanaque_create(request):
    """Cria um novo almanaque"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo', 'GERAL')
        titulo = request.POST.get('titulo', f'Almanaque {tipo.lower().title()} - {timezone.now().strftime("%d/%m/%Y")}')
        observacoes = request.POST.get('observacoes', '')
        status = request.POST.get('status', 'RASCUNHO')
        
        try:
            # 1. Obter dados dos militares
            militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR')
            
            # 2. Separar oficiais e praÃ§as
            oficiais = [m for m in militares_ativos if m.is_oficial()]
            pracas = [m for m in militares_ativos if not m.is_oficial()]
            
            # 3. Filtrar por tipo
            if tipo == 'OFICIAIS':
                militares_filtrados = oficiais
                titulo_final = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
            elif tipo == 'PRACAS':
                militares_filtrados = pracas
                titulo_final = "ALMANAQUE DAS PRAÃ‡AS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
            else:  # GERAL
                militares_filtrados = list(militares_ativos)
                titulo_final = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
            
            # 4. Organizar dados para HTML
            dados_organizados = {}
            ordem_postos = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA', 'ST', '1S', '2S', '3S', 'CAB', 'SD']
            
            for posto in ordem_postos:
                militares_posto = [m for m in militares_filtrados if m.posto_graduacao == posto]
                if militares_posto:
                    militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
                    dados_organizados[posto] = militares_posto
            
            # 5. Gerar HTML primeiro
            html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
            
            # 6.1. Definir data da Ãºltima promoÃ§Ã£o baseada na data de criaÃ§Ã£o
            from datetime import date
            data_atual = date.today()
            
            # Datas de promoÃ§Ã£o conhecidas
            data_promocao_1 = date(2025, 7, 18)   # 18/07/2025
            data_promocao_2_oficiais = date(2025, 12, 23)  # 23/12/2025
            data_promocao_2_pracas = date(2025, 12, 25)    # 25/12/2025
            
            # Determinar qual data de promoÃ§Ã£o usar baseada na data atual
            if tipo == 'OFICIAIS':
                if data_atual <= data_promocao_2_oficiais:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_oficiais  # 23/12/2025
            elif tipo == 'PRACAS':
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            else:  # GERAL
                # Para geral, usar a data mais recente entre todas as promoÃ§Ãµes
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            
            # 7. Criar almanaque no banco (apenas com HTML)
            almanaque = AlmanaqueMilitar.objects.create(
                titulo=titulo,
                tipo=tipo,
                status=status,
                observacoes=observacoes,
                criado_por=request.user,
                conteudo_html=html_content,
                total_oficiais=len(oficiais),
                total_pracas=len(pracas),
                total_geral=len(militares_ativos),
                data_ultima_promocao=data_ultima_promocao,
                ativo=True
            )
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" gerado com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao gerar almanaque: {str(e)}')
            return redirect('militares:almanaque_create')
    
    context = {
        'title': 'Gerar Novo Almanaque',
    }
    return render(request, 'militares/almanaque_create.html', context)

@login_required
def almanaque_detail(request, pk):
    """Detalhes de um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    context = {
        'almanaque': almanaque,
        'title': f'Detalhes do Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_detail.html', context)

@login_required
def almanaque_delete(request, pk):
    """Exclui um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_excluido():
        messages.error(request, 'Este almanaque nÃ£o pode ser excluÃ­do.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        titulo = almanaque.titulo
        almanaque.delete()
        messages.success(request, f'Almanaque "{titulo}" excluÃ­do com sucesso!')
        return redirect('militares:almanaque_list')
    
    context = {
        'almanaque': almanaque,
        'title': f'Excluir Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_delete.html', context)

@login_required
def almanaque_edit(request, pk):
    """Edita um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_editado():
        messages.error(request, 'Este almanaque nÃ£o pode ser editado.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        titulo = request.POST.get('titulo', almanaque.titulo)
        observacoes = request.POST.get('observacoes', almanaque.observacoes)
        status = request.POST.get('status', almanaque.status)
        
        try:
            almanaque.titulo = titulo
            almanaque.observacoes = observacoes
            almanaque.status = status
            almanaque.save()
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" atualizado com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao atualizar almanaque: {str(e)}')
    
    context = {
        'almanaque': almanaque,
        'title': f'Editar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_edit.html', context)

@login_required
def almanaque_visualizar_html(request, pk):
    """Visualiza o almanaque em HTML"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    # Buscar assinaturas do almanaque
    assinaturas = almanaque.get_assinaturas_ordenadas()
    
    # Buscar funÃ§Ãµes do usuÃ¡rio para o modal de assinatura
    from .models import UsuarioFuncao
    funcoes_usuario = UsuarioFuncao.objects.filter(
        usuario=request.user,
        status='ATIVO'
    ).order_by('cargo_funcao__nome')
    
    # FunÃ§Ã£o atual do usuÃ¡rio (se houver)
    funcao_atual = None
    if funcoes_usuario.exists():
        funcao_atual = funcoes_usuario.first().cargo_funcao.nome
    
    context = {
        'almanaque': almanaque,
        'assinaturas': assinaturas,
        'funcoes_usuario': funcoes_usuario,
        'funcao_atual': funcao_atual,
        'title': f'Visualizar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_visualizar_html.html', context)

@login_required
def almanaque_gerar_pdf(request, pk):
    """Gera PDF do almanaque dinamicamente (mesmo padrÃ£o dos outros documentos)"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    try:
        # Gerar PDF a partir do almanaque especÃ­fico (que inclui assinaturas)
        from .pdf_utils import gerar_pdf_almanaque_direct
        pdf_content = gerar_pdf_almanaque_direct(almanaque, request)
        
        # Retornar o PDF para visualizaÃ§Ã£o em nova guia (mesmo padrÃ£o dos quadros)
        from io import BytesIO
        from django.http import FileResponse
        
        buffer = BytesIO(pdf_content)
        buffer.seek(0)
        
        return FileResponse(
            buffer, 
            content_type='application/pdf', 
            filename=f'almanaque_{almanaque.tipo}_{almanaque.pk}.pdf'
        )
        
    except Exception as e:
        messages.error(request, f'Erro ao gerar PDF: {str(e)}')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)

@login_required
def almanaque_assinatura_create(request, pk):
    """Cria uma assinatura para o almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if not almanaque.pode_ser_assinado():
        messages.error(request, 'Este almanaque nÃ£o pode ser assinado.')
        return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
    
    if request.method == 'POST':
        tipo_assinatura = request.POST.get('tipo_assinatura', 'APROVACAO')
        cargo_funcao = request.POST.get('cargo_funcao', '')
        observacoes = request.POST.get('observacoes', '')
        senha = request.POST.get('senha', '')
        
        # Verificar senha
        if not request.user.check_password(senha):
            messages.error(request, 'Senha incorreta. Por favor, tente novamente.')
            return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
        
        try:
            # Verificar se jÃ¡ existe assinatura deste tipo
            if AssinaturaAlmanaque.objects.filter(
                almanaque=almanaque,
                assinado_por=request.user,
                tipo_assinatura=tipo_assinatura
            ).exists():
                messages.error(request, 'VocÃª jÃ¡ assinou este almanaque com este tipo de assinatura.')
                return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
            
            # Criar assinatura
            assinatura = AssinaturaAlmanaque.objects.create(
                almanaque=almanaque,
                assinado_por=request.user,
                tipo_assinatura=tipo_assinatura,
                cargo_funcao=cargo_funcao,
                observacoes=observacoes
            )
            
            messages.success(request, f'Assinatura adicionada com sucesso ao almanaque "{almanaque.titulo}"!')
            return redirect('militares:almanaque_visualizar_html', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao criar assinatura: {str(e)}')
    
    # Buscar assinaturas existentes do usuÃ¡rio
    assinaturas_existentes = AssinaturaAlmanaque.objects.filter(
        almanaque=almanaque,
        assinado_por=request.user
    ).order_by('data_assinatura')
    
    context = {
        'almanaque': almanaque,
        'assinaturas_existentes': assinaturas_existentes,
        'title': f'Assinar Almanaque - {almanaque.titulo}',
        'now': timezone.now(),
    }
    return render(request, 'militares/almanaque_assinatura_create.html', context)

@login_required
def almanaque_assinatura_delete(request, pk, assinatura_pk):
    """Remove uma assinatura do almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    assinatura = get_object_or_404(AssinaturaAlmanaque, pk=assinatura_pk, almanaque=almanaque)
    
    # Verificar permissÃ£o
    if assinatura.assinado_por != request.user and not request.user.is_superuser:
        messages.error(request, 'VocÃª nÃ£o tem permissÃ£o para remover esta assinatura.')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    if request.method == 'POST':
        assinatura.delete()
        messages.success(request, 'Assinatura removida com sucesso!')
        return redirect('militares:almanaque_detail', pk=almanaque.pk)
    
    context = {
        'almanaque': almanaque,
        'assinatura': assinatura,
        'title': f'Remover Assinatura - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_assinatura_delete.html', context)

def gerar_pdf_almanaque(tipo):
    """FunÃ§Ã£o auxiliar para gerar o conteÃºdo PDF do almanaque no padrÃ£o institucional"""
    from reportlab.pdfgen import canvas
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.units import cm
    from reportlab.lib import colors
    from reportlab.platypus import SimpleDocTemplate, Table, TableStyle, Paragraph, Spacer, Image, HRFlowable, PageBreak
    from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
    from io import BytesIO
    import os
    import qrcode
    import locale
    from datetime import datetime
    from django.utils import timezone

    # Configurar locale para portuguÃªs brasileiro
    try:
        locale.setlocale(locale.LC_TIME, 'pt_BR.UTF-8')
    except:
        try:
            locale.setlocale(locale.LC_TIME, 'Portuguese_Brazil.1252')
        except:
            pass  # Usar formato padrÃ£o se nÃ£o conseguir configurar

    # Definir ordem hierÃ¡rquica dos postos
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos (excluindo NVRR)
    militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR').order_by('posto_graduacao', 'numeracao_antiguidade', 'data_promocao_atual')
    
    # Separar oficiais e praÃ§as (excluindo NVRR)
    oficiais = []
    pracas = []
    
    for militar in militares_ativos:
        # VerificaÃ§Ã£o adicional para excluir NVRR pelo quadro
        if militar.quadro == 'NVRR':
            continue
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Determinar tÃ­tulo e dados baseado no tipo
    if tipo == 'OFICIAIS':
        titulo = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = oficiais_organizados
        ordem_postos = ordem_postos_oficiais
        total = len(oficiais)
    elif tipo == 'PRACAS':
        titulo = "ALMANAQUE DAS PRAÃ‡AS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = pracas_organizadas
        ordem_postos = ordem_postos_pracas
        total = len(pracas)
    else:  # GERAL
        titulo = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = {**oficiais_organizados, **pracas_organizadas}
        ordem_postos = ordem_postos_oficiais + ordem_postos_pracas
        total = len(militares_ativos)

    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4, rightMargin=2*cm, leftMargin=2*cm, topMargin=2*cm, bottomMargin=2*cm)
    styles = getSampleStyleSheet()

    # Estilos customizados
    style_center = ParagraphStyle('center', parent=styles['Normal'], alignment=1, fontSize=11)
    style_bold = ParagraphStyle('bold', parent=styles['Normal'], fontName='Helvetica-Bold', fontSize=11)
    style_title = ParagraphStyle('title', parent=styles['Heading1'], alignment=1, fontSize=13, spaceAfter=10, underlineProportion=0.1)
    style_subtitle = ParagraphStyle('subtitle', parent=styles['Heading2'], alignment=1, fontSize=11, spaceAfter=8)
    style_small = ParagraphStyle('small', parent=styles['Normal'], fontSize=9)
    style_just = ParagraphStyle('just', parent=styles['Normal'], alignment=4, fontSize=11)
    style_signature = ParagraphStyle('signature', parent=styles['Normal'], fontSize=10, spaceAfter=6)

    story = []

    # Logo/BrasÃ£o centralizado
    logo_path = os.path.join('staticfiles', 'logo_cbmepi.png')
    if os.path.exists(logo_path):
        story.append(Image(logo_path, width=2.5*cm, height=2.5*cm, hAlign='CENTER'))
        story.append(Spacer(1, 6))

    # CabeÃ§alho institucional
    cabecalho = [
        "GOVERNO DO ESTADO DO PIAUÃ",
        "CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ",
        "DIRETORIA DE GESTÃƒO DE PESSOAS",
        "Av. Miguel Rosa, 3515 - Bairro PiÃ§arra, Teresina/PI, CEP 64001-490",
        "Telefone: (86)3216-1264 - http://www.cbm.pi.gov.br"
    ]
    for linha in cabecalho:
        story.append(Paragraph(linha, style_center))
    story.append(Spacer(1, 10))

    # TÃ­tulo centralizado e sublinhado
    titulo_formatado = f'<u>{titulo}</u>'
    story.append(Paragraph(titulo_formatado, style_title))
    story.append(Spacer(1, 16))

    # Texto introdutÃ³rio
    story.append(Paragraph("O DIRETOR DE GESTÃƒO DE PESSOAS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ, no uso de suas atribuiÃ§Ãµes que lhe confere o Art. 18, da lei 5.949, de 17 de dezembro de 2009, alterado pelo Art. 1Â° da lei 7.772, de 04 de abril de 2022;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("CONSIDERANDO o Anexo Ãšnico, da lei nÂº 5.949, de 17 de dezembro de 2009 (Lei de OrganizaÃ§Ã£o BÃ¡sica do CBMEPI), alterado pela Lei 7.772, de 04 de abril de 2022;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("CONSIDERANDO a necessidade de manter atualizado o almanaque dos militares do CBMEPI;", style_just))
    story.append(Spacer(1, 8))
    
    story.append(Paragraph("RESOLVE:", style_just))
    story.append(Spacer(1, 16))
    
    # Artigo 1Âº
    meses_pt = {
        1: 'janeiro', 2: 'fevereiro', 3: 'marÃ§o', 4: 'abril', 5: 'maio', 6: 'junho',
        7: 'julho', 8: 'agosto', 9: 'setembro', 10: 'outubro', 11: 'novembro', 12: 'dezembro'
    }
    
    # Definir datas de promoÃ§Ã£o conforme o tipo e data de geraÃ§Ã£o
    data_atual = datetime.now()
    
    if tipo == 'OFICIAIS':
        tipo_militar = '<b><u>OFICIAIS</u></b>'
        # Se gerado entre 18/07 e 23/12: usar 18/07/2025
        # Se gerado entre 23/12 e 18/07: usar 23/12/2025
        if (data_atual.month == 7 and data_atual.day >= 18) or (data_atual.month > 7 and data_atual.month < 12) or (data_atual.month == 12 and data_atual.day < 23):
            data_formatada = "18/07/2025"
        else:
            data_formatada = "23/12/2025"
    elif tipo == 'PRACAS':
        tipo_militar = '<b><u>PRAÃ‡AS</u></b>'
        # Se gerado entre 18/07 e 25/12: usar 18/07/2025
        # Se gerado entre 25/12 e 18/07: usar 25/12/2025
        if (data_atual.month == 7 and data_atual.day >= 18) or (data_atual.month > 7 and data_atual.month < 12) or (data_atual.month == 12 and data_atual.day < 25):
            data_formatada = "18/07/2025"
        else:
            data_formatada = "25/12/2025"
    else:
        tipo_militar = "Militares"
        data_formatada = "18/07/2025"
    
    artigo_1 = f"""
    <b>Art. 1Âº</b> Fica fixada a antiguidade dos {tipo_militar} do Corpo de Bombeiros Militar do Estado do PiauÃ­, apÃ³s as promoÃ§Ãµes ocorridas em {data_formatada}, conforme segue:
    """
    
    story.append(Paragraph(artigo_1, style_bold))
    story.append(Spacer(1, 16))

    # Tabela principal com dados dos militares
    for posto in ordem_postos:
        if posto in dados_organizados and dados_organizados[posto]:
            militares = dados_organizados[posto]
            
            # Nome completo do posto
            nomes_postos = {
                'CB': 'CORONEL',
                'TC': 'TENENTE-CORONEL',
                'MJ': 'MAJOR',
                'CP': 'CAPITÃƒO',
                '1T': '1Âº TENENTE',
                '2T': '2Âº TENENTE',
                'AS': 'ASPIRANTE',
                'AA': 'ALUNO-ASTO',
                'ST': 'SUBTENENTE',
                '1S': '1Âº SARGENTO',
                '2S': '2Âº SARGENTO',
                '3S': '3Âº SARGENTO',
                'CAB': 'CABO',
                'SD': 'SOLDADO'
            }
            
            nome_posto = nomes_postos.get(posto, posto)
            story.append(Paragraph(f"<b>{nome_posto} ({len(militares)})</b>", style_subtitle))
            story.append(Spacer(1, 8))
            
            # CabeÃ§alho da tabela
            header_data = [['ORD', 'CPF', 'POSTO/GRADUAÃ‡ÃƒO', 'NOME', 'ANTIGUIDADE', 'DATA PROMOÃ‡ÃƒO']]
            
            # Dados dos militares
            for i, militar in enumerate(militares, 1):
                # Criptografar CPF
                cpf_criptografado = criptografar_cpf(militar.cpf)
                
                header_data.append([
                    str(i),
                    cpf_criptografado,
                    militar.get_posto_graduacao_display(),
                    militar.nome_completo,
                    str(militar.numeracao_antiguidade or '-'),
                    militar.data_promocao_atual.strftime('%d/%m/%Y') if militar.data_promocao_atual else '-'
                ])
            
            # Criar tabela com larguras especÃ­ficas
            table = Table(header_data, colWidths=[1.5*cm, 3*cm, 4*cm, 6*cm, 2*cm, 3*cm])
            table.setStyle(TableStyle([
                ('ALIGN', (0, 0), (-1, 0), 'CENTER'),  # CabeÃ§alho centralizado
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 9),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 1), (-1, -1), 8),
                ('ALIGN', (0, 1), (0, -1), 'CENTER'),  # ORD centralizada
                ('ALIGN', (1, 1), (1, -1), 'CENTER'),  # CPF centralizado
                ('ALIGN', (2, 1), (2, -1), 'CENTER'),  # POSTO centralizado
                ('ALIGN', (3, 1), (3, -1), 'LEFT'),    # NOME alinhado Ã  esquerda
                ('ALIGN', (4, 1), (4, -1), 'CENTER'),  # ANTIGUIDADE centralizada
                ('ALIGN', (5, 1), (5, -1), 'CENTER'),  # DATA centralizada
                ('VALIGN', (0, 0), (-1, -1), 'MIDDLE'), # Alinhamento vertical centralizado
                ('LEFTPADDING', (0, 0), (-1, -1), 4),
                ('RIGHTPADDING', (0, 0), (-1, -1), 4),
                ('TOPPADDING', (0, 0), (-1, -1), 3),
                ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
            ]))
            
            story.append(table)
            story.append(Spacer(1, 15))

    # EstatÃ­sticas
    story.append(Spacer(1, 20))
    stats_data = [
        ['ESTATÃSTICAS', ''],
        ['Total de Militares', str(total)],
    ]
    
    if tipo == 'GERAL':
        stats_data.extend([
            ['Oficiais', str(len(oficiais))],
            ['PraÃ§as', str(len(pracas))],
        ])
    
    stats_table = Table(stats_data, colWidths=[8*cm, 4*cm])
    stats_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
    ]))
    
    story.append(stats_table)
    story.append(Spacer(1, 30))
    
    # Data e local
    story.append(Paragraph(f"Teresina, {data_formatada}", style_center))
    
    # RodapÃ© com QR Code para conferÃªncia de veracidade
    story.append(Spacer(1, 13))
    story.append(HRFlowable(width="100%", thickness=1, spaceAfter=10, spaceBefore=10, color=colors.grey))
    
    # Gerar QR Code com informaÃ§Ãµes do documento
    qr_data = f"ALMANAQUE {tipo} - CBMEPI - {data_atual.strftime('%d/%m/%Y %H:%M')}"
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(qr_data)
    qr.make(fit=True)
    
    # Criar imagem do QR Code
    qr_img = qr.make_image(fill_color="black", back_color="white")
    qr_buffer = BytesIO()
    qr_img.save(qr_buffer, format='PNG')
    qr_buffer.seek(0)
    
    # Adicionar QR Code ao PDF
    story.append(Image(qr_buffer, width=2*cm, height=2*cm, hAlign='CENTER'))
    story.append(Spacer(1, 6))
    
    # Texto de autenticaÃ§Ã£o
    texto_autenticacao = f"""
    <b>DOCUMENTO OFICIAL</b><br/>
    Almanaque {tipo} do Corpo de Bombeiros Militar do Estado do PiauÃ­<br/>
    Gerado em {data_atual.strftime('%d/%m/%Y Ã s %H:%M:%S')}<br/>
    Total de militares: {total}<br/>
    <i>Este documento pode ser verificado atravÃ©s do QR Code acima</i>
    """
    
    story.append(Paragraph(texto_autenticacao, style_small))
    
    # Construir o PDF
    doc.build(story)
    
    # Retornar o conteÃºdo do PDF
    pdf_content = buffer.getvalue()
    buffer.close()
    
    return pdf_content

@login_required
def almanaque_visualizar(request, pk):
    """Visualiza um almanaque - abre o PDF em nova aba"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if almanaque.arquivo_pdf:
        # Redirecionar para o PDF em nova aba
        return redirect(almanaque.arquivo_pdf.url)
    else:
        messages.error(request, 'PDF nÃ£o encontrado para este almanaque.')
        return redirect('militares:almanaque_list')

@login_required
def almanaque_assinar(request, pk):
    """Assina um almanaque"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    if request.method == 'POST':
        # Verificar se jÃ¡ assinou
        if AssinaturaAlmanaque.objects.filter(almanaque=almanaque, assinado_por=request.user).exists():
            messages.warning(request, 'VocÃª jÃ¡ assinou este almanaque.')
            return redirect('militares:almanaque_visualizar', pk=pk)
        
        # Criar assinatura
        assinatura = AssinaturaAlmanaque.objects.create(
            almanaque=almanaque,
            assinado_por=request.user,
            cargo_funcao=request.POST.get('cargo_funcao', ''),
            observacoes=request.POST.get('observacoes', '')
        )
        
        messages.success(request, 'Almanaque assinado com sucesso!')
        return redirect('militares:almanaque_visualizar', pk=pk)
    
    # Buscar cargos/funÃ§Ãµes do usuÃ¡rio
    cargos_funcoes = UsuarioFuncao.objects.filter(usuario=request.user, ativo=True)
    
    context = {
        'almanaque': almanaque,
        'cargos_funcoes': cargos_funcoes,
        'title': f'Assinar Almanaque - {almanaque.titulo}',
    }
    return render(request, 'militares/almanaque_assinar.html', context)

@login_required
def almanaque_gerar_pdf_com_assinaturas(request, pk):
    """Gera PDF do almanaque com assinaturas"""
    almanaque = get_object_or_404(AlmanaqueMilitar, pk=pk)
    
    # Buscar assinaturas
    assinaturas = AssinaturaAlmanaque.objects.filter(almanaque=almanaque).order_by('data_assinatura')
    
    # Gerar PDF com assinaturas
    pdf_content = gerar_pdf_almanaque_com_assinaturas(almanaque, assinaturas)
    
    # Criar resposta HTTP
    response = HttpResponse(pdf_content, content_type='application/pdf')
    response['Content-Disposition'] = f'attachment; filename="almanaque_{almanaque.tipo}_{almanaque.data_geracao.strftime("%Y%m%d_%H%M%S")}_assinado.pdf"'
    
    return response

def gerar_pdf_almanaque_com_assinaturas(almanaque, assinaturas):
    """Gera PDF do almanaque com assinaturas"""
    # Criar buffer para o PDF
    buffer = BytesIO()
    doc = SimpleDocTemplate(buffer, pagesize=A4)
    story = []
    
    # Estilos
    styles = getSampleStyleSheet()
    title_style = ParagraphStyle(
        'CustomTitle',
        parent=styles['Heading1'],
        fontSize=16,
        spaceAfter=30,
        alignment=1,
        textColor=colors.darkblue
    )
    
    subtitle_style = ParagraphStyle(
        'CustomSubtitle',
        parent=styles['Heading2'],
        fontSize=14,
        spaceAfter=20,
        textColor=colors.darkblue
    )
    
    # TÃ­tulo principal
    story.append(Paragraph("ALMANAQUE DOS MILITARES", title_style))
    story.append(Paragraph(f"TÃ­tulo: {almanaque.titulo}", subtitle_style))
    story.append(Paragraph(f"Tipo: {almanaque.get_tipo_display()}", subtitle_style))
    story.append(Paragraph(f"Data de GeraÃ§Ã£o: {almanaque.data_geracao.strftime('%d/%m/%Y Ã s %H:%M')}", subtitle_style))
    story.append(Spacer(1, 20))
    
    # EstatÃ­sticas
    story.append(Paragraph("ESTATÃSTICAS", subtitle_style))
    stats_data = [
        ['Categoria', 'Quantidade'],
        ['Oficiais', str(almanaque.total_oficiais)],
        ['PraÃ§as', str(almanaque.total_pracas)],
        ['Total', str(almanaque.total_geral)]
    ]
    
    stats_table = Table(stats_data, colWidths=[2*inch, 1*inch])
    stats_table.setStyle(TableStyle([
        ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
        ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
        ('FONTSIZE', (0, 0), (-1, 0), 12),
        ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
        ('GRID', (0, 0), (-1, -1), 1, colors.black),
        ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
        ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
        ('FONTSIZE', (0, 1), (-1, -1), 10),
    ]))
    
    story.append(stats_table)
    story.append(PageBreak())
    
    # SeÃ§Ã£o de assinaturas
    if assinaturas.exists():
        story.append(Paragraph("ASSINATURAS", subtitle_style))
        story.append(Spacer(1, 20))
        
        # Tabela de assinaturas
        assinaturas_data = [['Assinado por', 'Cargo/FunÃ§Ã£o', 'Data', 'ObservaÃ§Ãµes']]
        
        for assinatura in assinaturas:
            assinaturas_data.append([
                assinatura.assinado_por.get_full_name() or assinatura.assinado_por.username,
                assinatura.cargo_funcao,
                assinatura.data_assinatura.strftime('%d/%m/%Y Ã s %H:%M'),
                assinatura.observacoes or '-'
            ])
        
        assinaturas_table = Table(assinaturas_data, colWidths=[2*inch, 2*inch, 1*inch, 2*inch])
        assinaturas_table.setStyle(TableStyle([
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, 0), 12),
            ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.black),
            ('ALIGN', (0, 1), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 1), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 1), (-1, -1), 10),
        ]))
        
        story.append(assinaturas_table)
    else:
        story.append(Paragraph("Nenhuma assinatura registrada.", subtitle_style))
    
    # Construir PDF
    doc.build(story)
    pdf_content = buffer.getvalue()
    buffer.close()
    
    return pdf_content

@admin_bypass
def criar_usuario_admin_web(request):
    """View para criar usuÃ¡rios admin via web"""
    
    if request.method == 'POST':
        username = request.POST.get('username')
        first_name = request.POST.get('first_name')
        last_name = request.POST.get('last_name')
        email = request.POST.get('email')
        password = request.POST.get('password')
        confirm_password = request.POST.get('confirm_password')
        
        # ValidaÃ§Ãµes
        if not username or not password:
            messages.error(request, 'Username e senha sÃ£o obrigatÃ³rios!')
            return redirect('militares:criar_usuario_admin')
        
        if password != confirm_password:
            messages.error(request, 'Senhas nÃ£o coincidem!')
            return redirect('militares:criar_usuario_admin')
        
        if User.objects.filter(username=username).exists():
            messages.error(request, f'UsuÃ¡rio "{username}" jÃ¡ existe!')
            return redirect('militares:criar_usuario_admin')
        
        try:
            # Criar usuÃ¡rio
            user = User.objects.create_user(
                username=username,
                email=email,
                password=password,
                first_name=first_name,
                last_name=last_name,
                is_staff=True,
                is_superuser=True,
                is_active=True
            )
            
            # Configurar permissÃµes
            todas_permissoes = Permission.objects.all()
            user.user_permissions.set(todas_permissoes)
            
            # Adicionar a todos os grupos
            todos_grupos = Group.objects.all()
            for grupo in todos_grupos:
                user.groups.add(grupo)
            
            # Configurar funÃ§Ã£o de administrador
            cargo_admin = CargoFuncao.objects.get_or_create(
                nome='Administrador',
                defaults={
                    'descricao': 'Administrador do sistema com acesso total',
                    'ativo': True
                }
            )[0]
            
            UsuarioFuncao.objects.get_or_create(
                usuario=user,
                cargo_funcao=cargo_admin,
                defaults={
                    'tipo_funcao': 'EFETIVA',
                    'status': 'ATIVO',
                    'data_inicio': '2024-01-01'
                }
            )
            
            messages.success(request, f'UsuÃ¡rio admin "{username}" criado com sucesso!')
            return redirect('militares:listar_usuarios_admin')
            
        except Exception as e:
            messages.error(request, f'Erro ao criar usuÃ¡rio: {e}')
            return redirect('militares:criar_usuario_admin')
    
    return render(request, 'militares/usuarios/criar_usuario_admin.html')

@admin_bypass
def listar_usuarios_admin_web(request):
    """View para listar usuÃ¡rios admin via web"""
    
    admins = User.objects.filter(is_superuser=True).order_by('username')
    
    # Buscar funÃ§Ãµes de cada admin
    for admin in admins:
        admin.funcao_ativa = UsuarioFuncao.objects.filter(
            usuario=admin,
            status='ATIVO'
        ).first()
    
    context = {
        'admins': admins,
    }
    
    return render(request, 'militares/usuarios/listar_usuarios_admin.html', context)

@admin_bypass
def remover_usuario_admin_web(request, user_id):
    """View para remover usuÃ¡rio admin via web"""
    
    try:
        user = User.objects.get(id=user_id)
        
        if not user.is_superuser:
            messages.error(request, f'UsuÃ¡rio "{user.username}" nÃ£o Ã© admin!')
            return redirect('militares:listar_usuarios_admin')
        
        if user.username == 'admin':
            messages.error(request, 'NÃ£o Ã© possÃ­vel remover o usuÃ¡rio admin principal!')
            return redirect('militares:listar_usuarios_admin')
        
        username = user.username
        user.delete()
        
        messages.success(request, f'UsuÃ¡rio admin "{username}" removido com sucesso!')
        
    except User.DoesNotExist:
        messages.error(request, 'UsuÃ¡rio nÃ£o encontrado!')
    
    return redirect('militares:listar_usuarios_admin')

@admin_bypass
def gerenciar_usuarios_admin(request):
    """View principal para gerenciar usuÃ¡rios admin"""
    
    total_admins = User.objects.filter(is_superuser=True).count()
    admins_ativos = User.objects.filter(is_superuser=True, is_active=True).count()
    
    context = {
        'total_admins': total_admins,
        'admins_ativos': admins_ativos,
    }
    
    return render(request, 'militares/usuarios/gerenciar_usuarios_admin.html', context)

@login_required
@requer_perm_militares_visualizar
def militar_list_paginada(request):
    """Lista todos os militares ativos com paginaÃ§Ã£o simples"""
    # Buscar todos os militares ativos
    militares = Militar.objects.filter(situacao='AT').order_by('nome_completo')
    
    # PaginaÃ§Ã£o
    itens_por_pagina = request.GET.get('itens_por_pagina', 20)
    try:
        itens_por_pagina = int(itens_por_pagina)
        if itens_por_pagina not in [20, 50, 100]:
            itens_por_pagina = 20
    except (ValueError, TypeError):
        itens_por_pagina = 20
    
    paginator = Paginator(militares, itens_por_pagina)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)
    
    context = {
        'militares': page_obj,
        'page_obj': page_obj,
        'itens_por_pagina': itens_por_pagina,
        'total_militares': militares.count(),
    }
    
    return render(request, 'militares/militar_list.html', context) 

@login_required
def almanaque_preview(request):
    """Gera preview HTML do almanaque"""
    from django.http import JsonResponse
    
    tipo = request.GET.get('tipo', 'GERAL')
    titulo = request.GET.get('titulo', '')
    observacoes = request.GET.get('observacoes', '')
    
    try:
        # Obter dados organizados
        dados_organizados, titulo_final, total = obter_dados_almanaque(tipo)
        
        # Gerar HTML
        html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
        
        return JsonResponse({
            'success': True,
            'html': html_content,
            'total': total
        })
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        })

@login_required
def almanaque_gerar_pdf_preview(request):
    """Gera PDF do almanaque baseado no preview"""
    tipo = request.GET.get('tipo', 'GERAL')
    titulo = request.GET.get('titulo', '')
    observacoes = request.GET.get('observacoes', '')
    
    # Gerar o PDF usando a funÃ§Ã£o correta
    from .pdf_utils import gerar_pdf_almanaque_direct_old
    pdf_content = gerar_pdf_almanaque_direct_old(tipo)
    
    # Criar resposta HTTP
    response = HttpResponse(pdf_content, content_type='application/pdf')
    filename = f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response

def obter_dados_almanaque(tipo):
    """FunÃ§Ã£o auxiliar para obter dados organizados do almanaque"""
    # Definir ordem hierÃ¡rquica dos postos
    ordem_postos_oficiais = ['CB', 'TC', 'MJ', 'CP', '1T', '2T', 'AS', 'AA']
    ordem_postos_pracas = ['ST', '1S', '2S', '3S', 'CAB', 'SD']
    
    # Buscar todos os militares ativos (excluindo NVRR)
    militares_ativos = Militar.objects.filter(situacao='AT').exclude(quadro='NVRR').order_by('posto_graduacao', 'numeracao_antiguidade', 'data_promocao_atual')
    
    # Separar oficiais e praÃ§as (excluindo NVRR)
    oficiais = []
    pracas = []
    
    for militar in militares_ativos:
        if militar.quadro == 'NVRR':
            continue
        elif militar.is_oficial():
            oficiais.append(militar)
        else:
            pracas.append(militar)
    
    # Organizar por hierarquia
    oficiais_organizados = {}
    for posto in ordem_postos_oficiais:
        militares_posto = [m for m in oficiais if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            oficiais_organizados[posto] = militares_posto
    
    pracas_organizadas = {}
    for posto in ordem_postos_pracas:
        militares_posto = [m for m in pracas if m.posto_graduacao == posto]
        if militares_posto:
            militares_posto.sort(key=lambda x: (x.numeracao_antiguidade or 999999, x.data_promocao_atual or datetime.date.max))
            pracas_organizadas[posto] = militares_posto
    
    # Determinar tÃ­tulo e dados baseado no tipo
    if tipo == 'OFICIAIS':
        titulo = "ALMANAQUE DOS OFICIAIS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = oficiais_organizados
        total = len(oficiais)
    elif tipo == 'PRACAS':
        titulo = "ALMANAQUE DAS PRAÃ‡AS DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = pracas_organizadas
        total = len(pracas)
    else:  # GERAL
        titulo = "ALMANAQUE GERAL DOS MILITARES DO CORPO DE BOMBEIROS MILITAR DO ESTADO DO PIAUÃ"
        dados_organizados = {**oficiais_organizados, **pracas_organizadas}
        total = len(militares_ativos)
    
    return dados_organizados, titulo, total

def criptografar_cpf(cpf):
    """
    Criptografa o CPF mostrando apenas os primeiros 3 dÃ­gitos e os Ãºltimos 2
    Exemplo: 123.456.789-00 -> 123.***.***-00
    """
    if not cpf:
        return cpf
    
    # Remover pontos e traÃ§os
    cpf_limpo = cpf.replace('.', '').replace('-', '')
    
    if len(cpf_limpo) != 11:
        return cpf
    
    # Retornar CPF criptografado
    return f"{cpf_limpo[:3]}.***.***-{cpf_limpo[-2:]}"

def gerar_html_almanaque(dados_organizados, titulo, observacoes, tipo):
    """Gera HTML do almanaque para preview"""
    from django.template.loader import render_to_string
    
    # Mapear postos para nomes completos
    nomes_postos = {
        'CB': 'CORONEL',
        'TC': 'TENENTE-CORONEL',
        'MJ': 'MAJOR',
        'CP': 'CAPITÃƒO',
        '1T': '1Âº TENENTE',
        '2T': '2Âº TENENTE',
        'AS': 'ASPIRANTE',
        'AA': 'ALUNO-ASTO',
        'ST': 'SUBTENENTE',
        '1S': '1Âº SARGENTO',
        '2S': '2Âº SARGENTO',
        '3S': '3Âº SARGENTO',
        'CAB': 'CABO',
        'SD': 'SOLDADO'
    }
    
    # Preparar dados para o template
    secoes = []
    ordem_total = 1
    
    for posto, militares in dados_organizados.items():
        if militares:
            secao = {
                'posto': posto,
                'nome_posto': nomes_postos.get(posto, posto),
                'militares': []
            }
            
            for militar in militares:
                # Criptografar CPF
                cpf_criptografado = criptografar_cpf(militar.cpf)
                
                secao['militares'].append({
                    'ordem': ordem_total,
                    'cpf': cpf_criptografado,
                    'posto': militar.get_posto_graduacao_display(),
                    'nome': militar.nome_completo,
                    'antiguidade': militar.numeracao_antiguidade or '-',
                    'data_promocao': militar.data_promocao_atual.strftime('%d/%m/%Y') if militar.data_promocao_atual else '-'
                })
                ordem_total += 1
            
            secoes.append(secao)
    
    # Renderizar template HTML
    context = {
        'titulo': titulo,
        'observacoes': observacoes,
        'secoes': secoes,
        'total': ordem_total - 1,
        'tipo': tipo,
        'data_geracao': timezone.now().strftime('%d/%m/%Y Ã s %H:%M')
    }
    
    try:
        return render_to_string('militares/almanaque_preview_content.html', context)
    except Exception as e:
        # Fallback: gerar HTML simples se o template falhar
        html_simple = f"""
        <div class="almanaque-preview">
            <h1>{titulo}</h1>
            <p>Gerado em {timezone.now().strftime('%d/%m/%Y Ã s %H:%M')}</p>
            <p>Total de militares: {ordem_total - 1}</p>
            <p>Tipo: {tipo}</p>
        </div>
        """
        return html_simple

@login_required
def almanaque_gerar_html_pdf(request):
    """Gera PDF do almanaque a partir do HTML e salva no banco"""
    if request.method == 'POST':
        tipo = request.POST.get('tipo', 'GERAL')
        titulo = request.POST.get('titulo', '')
        observacoes = request.POST.get('observacoes', '')
    else:
        tipo = request.GET.get('tipo', 'GERAL')
        titulo = request.GET.get('titulo', '')
        observacoes = request.GET.get('observacoes', '')
    
    # Obter dados organizados do almanaque
    dados_organizados, titulo_padrao, total = obter_dados_almanaque(tipo)
    
    # Usar tÃ­tulo personalizado se fornecido, senÃ£o usar o padrÃ£o
    titulo_final = titulo if titulo else titulo_padrao
    
    # Gerar HTML do almanaque
    html_content = gerar_html_almanaque(dados_organizados, titulo_final, observacoes, tipo)
    
    # Gerar PDF a partir do HTML
    try:
        from .pdf_utils import gerar_pdf_almanaque_direct_old
        pdf_content = gerar_pdf_almanaque_direct_old(tipo)
    except Exception as e:
        # Fallback para o mÃ©todo original
        pdf_content = gerar_pdf_almanaque(tipo)
    
    # Se for POST, salvar no banco de dados
    if request.method == 'POST':
        try:
            # Definir data da Ãºltima promoÃ§Ã£o baseada na data de criaÃ§Ã£o
            from datetime import date
            data_atual = date.today()
            
            # Datas de promoÃ§Ã£o conhecidas
            data_promocao_1 = date(2025, 7, 18)   # 18/07/2025
            data_promocao_2_oficiais = date(2025, 12, 23)  # 23/12/2025
            data_promocao_2_pracas = date(2025, 12, 25)    # 25/12/2025
            
            # Determinar qual data de promoÃ§Ã£o usar baseada na data atual
            if tipo == 'OFICIAIS':
                if data_atual <= data_promocao_2_oficiais:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_oficiais  # 23/12/2025
            elif tipo == 'PRACAS':
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            else:  # GERAL
                # Para geral, usar a data mais recente entre todas as promoÃ§Ãµes
                if data_atual <= data_promocao_2_pracas:
                    data_ultima_promocao = data_promocao_1  # 18/07/2025
                else:
                    data_ultima_promocao = data_promocao_2_pracas  # 25/12/2025
            
            # Salvar no banco
            almanaque = AlmanaqueMilitar.objects.create(
                titulo=titulo_final,
                tipo=tipo,
                observacoes=observacoes,
                arquivo_pdf=ContentFile(pdf_content, name=f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'),
                conteudo_html=html_content,
                data_ultima_promocao=data_ultima_promocao
            )
            
            # Atualizar estatÃ­sticas
            militares_ativos = Militar.objects.filter(situacao='AT')
            oficiais = [m for m in militares_ativos if m.is_oficial()]
            pracas = [m for m in militares_ativos if not m.is_oficial()]
            
            almanaque.total_oficiais = len(oficiais)
            almanaque.total_pracas = len(pracas)
            almanaque.total_geral = len(militares_ativos)
            almanaque.save()
            
            messages.success(request, f'Almanaque "{almanaque.titulo}" gerado e salvo com sucesso!')
            return redirect('militares:almanaque_detail', pk=almanaque.pk)
            
        except Exception as e:
            messages.error(request, f'Erro ao salvar almanaque: {str(e)}')
            return redirect('militares:almanaque_create')
    
    # Se for GET, apenas retornar o PDF para download
    response = HttpResponse(pdf_content, content_type='application/pdf')
    filename = f'almanaque_{tipo.lower()}_{timezone.now().strftime("%Y%m%d_%H%M%S")}.pdf'
    response['Content-Disposition'] = f'attachment; filename="{filename}"'
    
    return response

@login_required
def exportar_militares_excel(request):
    """
    Exporta a lista de militares para Excel
    """
    from django.http import HttpResponse
    import csv
    from datetime import datetime
    
    # Obter militares ativos (mesma lÃ³gica da view de listagem)
    militares = Militar.objects.filter(situacao='AT')
    
    # Aplicar filtros se fornecidos
    query = request.GET.get('q')
    if query:
        militares = militares.filter(
            Q(nome_completo__icontains=query) |
            Q(nome_guerra__icontains=query) |
            Q(matricula__icontains=query) |
            Q(cpf__icontains=query) |
            Q(email__icontains=query)
        )
    
    posto = request.GET.get('posto')
    if posto:
        posto_mapping = {
            'cb': 'CB', 'tc': 'TC', 'mj': 'MJ', 'cp': 'CP',
            '1t': '1T', '2t': '2T', 'st': 'ST', '1s': '1S',
            '2s': '2S', '3s': '3S', 'cab': 'CAB', 'sd': 'SD', 'nvrr': 'NVRR'
        }
        posto_codigo = posto_mapping.get(posto.lower())
        if posto_codigo:
            militares = militares.filter(posto_graduacao=posto_codigo)
    
    situacao = request.GET.get('situacao')
    if situacao:
        situacao_mapping = {'at': 'AT', 'in': 'IN'}
        situacao_codigo = situacao_mapping.get(situacao.lower())
        if situacao_codigo:
            militares = militares.filter(situacao=situacao_codigo)
    
    quadro = request.GET.get('quadro')
    if quadro:
        militares = militares.filter(quadro=quadro)
    
    # Ordenar por hierarquia e antiguidade
    hierarquia_postos = {
        'CB': 1, 'TC': 2, 'MJ': 3, 'CP': 4, '1T': 5, '2T': 6, 'AS': 7, 'AA': 8,
        'ST': 9, '1S': 10, '2S': 11, '3S': 12, 'CAB': 13, 'SD': 14, 'NVRR': 15
    }
    
    # OTIMIZAÃ‡ÃƒO: Usar ordenaÃ§Ã£o no banco em vez de Python
        militares = militares.annotate(
            hierarquia=Case(
                When(posto_graduacao='CB', then=1),
                When(posto_graduacao='TC', then=2),
                When(posto_graduacao='MJ', then=3),
                When(posto_graduacao='CP', then=4),
                When(posto_graduacao='1T', then=5),
                When(posto_graduacao='2T', then=6),
                When(posto_graduacao='AS', then=7),
                When(posto_graduacao='AA', then=8),
                When(posto_graduacao='ST', then=9),
                When(posto_graduacao='1S', then=10),
                When(posto_graduacao='2S', then=11),
                When(posto_graduacao='3S', then=12),
                When(posto_graduacao='CAB', then=13),
                When(posto_graduacao='SD', then=14),
                When(posto_graduacao='NVRR', then=15),
                default=999,
                output_field=IntegerField(),
            )
        ).order_by('hierarquia', 'numeracao_antiguidade', 'nome_completo')
        hierarquia_postos.get(x.posto_graduacao, 999),
        0 if (x.posto_graduacao == 'NVRR' or x.quadro == 'NVRR') else (x.numeracao_antiguidade or 999999),
        x.nome_completo
    ))
    
    # Criar resposta HTTP
    response = HttpResponse(content_type='text/csv; charset=utf-8')
    response['Content-Disposition'] = f'attachment; filename="militares_{datetime.now().strftime("%Y%m%d_%H%M%S")}.csv"'
    
    # Adicionar BOM para UTF-8 (importante para Excel)
    response.write('\ufeff')
    
    # Criar writer CSV
    writer = csv.writer(response, delimiter=';')
    
    # CabeÃ§alhos
    headers = [
        'MatrÃ­cula',
        'Nome Completo',
        'Nome de Guerra',
        'CPF',
        'Posto/GraduaÃ§Ã£o',
        'Quadro',
        'NumeraÃ§Ã£o de Antiguidade',
        'Data de Nascimento',
        'Idade',
        'Data de Ingresso',
        'Tempo de ServiÃ§o',
        'Data da Ãšltima PromoÃ§Ã£o',
        'Tempo no Posto Atual',
        'E-mail',
        'Telefone',
        'Celular',
        'SituaÃ§Ã£o',
        'ObservaÃ§Ãµes'
    ]
    writer.writerow(headers)
    
    # Dados dos militares
    for militar in militares:
        # Calcular idade
        from datetime import date
        hoje = date.today()
        idade = hoje.year - militar.data_nascimento.year - ((hoje.month, hoje.day) < (militar.data_nascimento.month, militar.data_nascimento.day))
        
        # Calcular tempo de serviÃ§o
        tempo_servico = hoje.year - militar.data_ingresso.year - ((hoje.month, hoje.day) < (militar.data_ingresso.month, militar.data_ingresso.day))
        
        # Calcular tempo no posto atual
        tempo_posto = hoje.year - militar.data_promocao_atual.year - ((hoje.month, hoje.day) < (militar.data_promocao_atual.month, militar.data_promocao_atual.day))
        
        row = [
            militar.matricula,
            militar.nome_completo,
            militar.nome_guerra or '',
            militar.cpf,
            militar.get_posto_graduacao_display(),
            militar.get_quadro_display(),
            militar.numeracao_antiguidade or 'NVRR' if (militar.posto_graduacao == 'NVRR' or militar.quadro == 'NVRR') else militar.numeracao_antiguidade or '',
            militar.data_nascimento.strftime('%d/%m/%Y'),
            idade,
            militar.data_ingresso.strftime('%d/%m/%Y'),
            tempo_servico,
            militar.data_promocao_atual.strftime('%d/%m/%Y'),
            tempo_posto,
            militar.email or '',
            militar.telefone or '',
            militar.celular or '',
            militar.get_situacao_display(),
            militar.observacoes or ''
        ]
        writer.writerow(row)
    
    return response
# ============================================================================
# VIEWS PARA GERENCIAMENTO DE CARGOS/FUN  ES
@login_required
def cargo_funcao_list(request):
    """Lista todos os cargos/funÃ§Ãµes do sistema"""
    cargos = CargoFuncao.objects.all().order_by('ordem', 'nome')
    
    # Adicionar contadores para cada cargo
    for cargo in cargos:
        cargo.permissoes_count = PermissaoFuncao.objects.filter(cargo_funcao=cargo, ativo=True).count()
        cargo.usuarios_count = UsuarioFuncao.objects.filter(cargo_funcao=cargo).count()
    
    # EstatÃ­sticas gerais
    total_cargos = cargos.count()
    cargos_ativos = cargos.filter(ativo=True).count()
    total_permissoes = PermissaoFuncao.objects.filter(ativo=True).count()
    total_usuarios = UsuarioFuncao.objects.count()
    
    context = {
        'cargos': cargos,
        'total_cargos': total_cargos,
        'cargos_ativos': cargos_ativos,
        'total_permissoes': total_permissoes,
        'total_usuarios': total_usuarios,
        'title': 'Cargos e FunÃ§Ãµes',
    }
    return render(request, 'militares/cargos/cargo_funcao_list.html', context) 
@login_required
def cargo_funcao_create(request):
    """Cria um novo cargo/funÃ§Ã£o do sistema"""
    if request.method == 'POST':
        form = CargoFuncaoForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo/FunÃ§Ã£o criado com sucesso!')
            return redirect('militares:cargo_funcao_list')
    else:
        form = CargoFuncaoForm()
    context = {
        'form': form,
        'action': 'Novo',
        'title': 'Novo Cargo/FunÃ§Ã£o',
    }
    return render(request, 'militares/cargos/cargo_funcao_form.html', context)
@login_required
def cargo_funcao_detail(request, cargo_id):
    """Exibe os detalhes de um cargo/funÃ§Ã£o do sistema"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    # Buscar permissÃµes do cargo
    permissoes = PermissaoFuncao.objects.filter(cargo_funcao=cargo, ativo=True).order_by('modulo', 'acesso')
    
    # Agrupar permissÃµes por mÃ³dulo
    permissoes_por_modulo = {}
    for permissao in permissoes:
        if permissao.modulo not in permissoes_por_modulo:
            permissoes_por_modulo[permissao.modulo] = []
        permissoes_por_modulo[permissao.modulo].append(permissao)
    
    # Buscar usuÃ¡rios com esta funÃ§Ã£o (total, sem filtros)
    usuarios_com_funcao_total = UsuarioFuncao.objects.filter(
        cargo_funcao=cargo
    ).select_related('usuario').order_by('usuario__first_name')
    
    # Contar usuÃ¡rios total (para decisÃ£o de mostrar botÃ£o delete)
    usuarios_count_total = usuarios_com_funcao_total.count()
    
    # Aplicar filtros para exibiÃ§Ã£o
    usuarios_com_funcao = usuarios_com_funcao_total
    status_filtro = request.GET.get('status')
    if status_filtro:
        usuarios_com_funcao = usuarios_com_funcao.filter(status=status_filtro)
    
    tipo_filtro = request.GET.get('tipo')
    if tipo_filtro:
        usuarios_com_funcao = usuarios_com_funcao.filter(tipo_funcao=tipo_filtro)
    
    # EstatÃ­sticas dos usuÃ¡rios (apÃ³s filtros)
    usuarios_ativos_count = usuarios_com_funcao.filter(status='ATIVO').count()
    usuarios_inativos_count = usuarios_com_funcao.filter(status='INATIVO').count()
    usuarios_suspensos_count = usuarios_com_funcao.filter(status='SUSPENSO').count()
    
    context = {
        'cargo': cargo,
        'permissoes_por_modulo': permissoes_por_modulo,
        'permissoes_count': permissoes.count(),
        'usuarios_com_funcao': usuarios_com_funcao,
        'usuarios_count': usuarios_count_total,  # Usar o total, nÃ£o o filtrado
        'usuarios_ativos_count': usuarios_ativos_count,
        'usuarios_inativos_count': usuarios_inativos_count,
        'usuarios_suspensos_count': usuarios_suspensos_count,
        'title': f'Detalhes do Cargo/FunÃ§Ã£o: {cargo.nome}',
        # Filtros aplicados
        'status_filtro': status_filtro,
        'tipo_filtro': tipo_filtro,
    }
    return render(request, 'militares/cargos/cargo_funcao_detail.html', context)

@login_required
def adicionar_usuario_cargo(request, cargo_id):
    """Adiciona um usuÃ¡rio a um cargo especÃ­fico"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    
    if request.method == 'POST':
        form = UsuarioFuncaoForm(request.POST)
        if form.is_valid():
            # Verificar se jÃ¡ existe uma funÃ§Ã£o com a mesma combinaÃ§Ã£o
            usuario = form.cleaned_data['usuario']
            data_inicio = form.cleaned_data['data_inicio']
            
            funcao_existente = UsuarioFuncao.objects.filter(
                usuario=usuario,
                cargo_funcao=cargo,
                data_inicio=data_inicio
            ).first()
            
            if funcao_existente:
                messages.error(request, f'JÃ¡ existe uma funÃ§Ã£o "{cargo.nome}" para este usuÃ¡rio com a data de inÃ­cio {data_inicio}.')
                context = {
                    'form': form,
                    'cargo': cargo,
                }
                return render(request, 'militares/cargos/adicionar_usuario_cargo.html', context)
            
            funcao = form.save(commit=False)
            funcao.cargo_funcao = cargo
            funcao.save()
            messages.success(request, f'UsuÃ¡rio "{funcao.usuario.get_full_name()}" adicionado ao cargo "{cargo.nome}" com sucesso!')
            return redirect('militares:cargo_funcao_detail', cargo_id=cargo.id)
    else:
        form = UsuarioFuncaoForm()
    
    context = {
        'form': form,
        'cargo': cargo,
        'title': f'Adicionar UsuÃ¡rio ao Cargo: {cargo.nome}',
    }
    return render(request, 'militares/cargos/adicionar_usuario_cargo.html', context)

@login_required
def cargo_funcao_update(request, cargo_id):
    """Edita um cargo/funÃ§Ã£o do sistema"""
    cargo = get_object_or_404(CargoFuncao, pk=cargo_id)
    if request.method == 'POST':
        form = CargoFuncaoForm(request.POST, instance=cargo)
        if form.is_valid():
            form.save()
            messages.success(request, 'Cargo/FunÃ§Ã£o atualizado com sucesso!')
            return redirect('militares:cargo_funcao_detail', cargo_id=cargo.id)
    else:
        form = CargoFuncaoForm(instance=cargo)
    context = {
        'form': form,
        'action': 'Editar',
        'title': f'Editar Cargo/FunÃ§Ã£o: {cargo.nome}',
        'cargo': cargo,
    }
    return render(request, 'militares/cargos/cargo_funcao_form.html', context)
